#+STARTUP: showall indent hidestars

~Упражнение 2.1~
Определите улучшенную версию mul-rat, которая принимала бы как положительные, так и
отрицательные аргументы. Make-rat должна нормализовывать знак так, чтобы в случае, если
рациональное число положительно, то и его числитель, и знаменатель были бы
положительны, а если оно отрицательно, то чтобы только его числитель был отрицателен.

#+BEGIN_SRC scheme
  (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))

  (define (numer x) (car x))
  (define (denom x) (cdr x))

  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))

  (define (make-rat n d)
    (let ((g (gcd n d)))
      (if (< g 0)
          (cons (/ n (abs g)) (/ d g))
          (cons (/ n g) (/ d g)))))

#+END_SRC


~Упражнение 2.2~
Рассмотрим задачу представления отрезков прямой на плоскости. Каждый отрезок
представляется как пара точек: начало и конец. Определите конструктор make-segment
и селекторы start-segment и end-segment, которые определяют представление отрезков
в терминах точек. Далее, точку можно представить как пару чисел: координата x и
координата y. Соответственно, напишите конструктор make-point и селекторы x-point и
y-point, которые определяют такое представление. Наконец, используя свои селекторы и
конструктор, напишите процедуру midpoint-segment, которая принимает отрезок в качестве
аргумента и возвращает его середину (точку,координаты которой являются средним
координат концов отрезка). Чтобы опробовать эти процедуры, Вам потребуется способ
печатать координаты точек:
#+BEGIN_SRC scheme

  (define (print-point p)
    (newline)
    (display "(")
    (display (x-point p))
    (display ",")
    (display (y-point p))
    (display ")"))

#+END_SRC

Есть какая-то плоскость. На ней располагаются отрезки. Каждый отрезок - это начальная
и конечная точка.
#+BEGIN_SRC scheme
  (define (print-point p)
    (newline)
    (display "(")
    (display (x-point p))
    (display ",")
    (display (y-point p))
    (display ")\n"))

  (define (y-point point)
    (cdr point))

  (define (x-point point)
    (car point))

  (define (make-point x y)
    (cons x y))

  (define (start-segment segment)
    (car segment))

  (define (end-segment segment)
    (cdr segment))

  (define (make-segment start end)
    (cons start end))

  (define (midpoint-segment segment)
    (let ((start (start-segment segment))
          (end (end-segment segment)))
      (print-point (make-point (/ (+ (x-point start) (x-point end)) 2)
                               (/ (+ (y-point start) (y-point end)) 2)))))

  (midpoint-segment (cons (cons 10 20) (cons 30 80)))
#+END_SRC

~Упражнение 2.3~
Реализуйте представление прямоугольников на плоскости. (Подсказка: Вам могут
потребоваться результаты упражнения 2.2.) Определите в терминах своих конструкторов
и селекторов процедуры, которые вычисляют периметр и площадь прямоугольника.
Теперь реализуйте другое представление для прямоугольников. Можете ли Вы спроектировать
свою систему с подходящими барьерами абстракции так, чтобы одни и те же процедуры
вычисления периметра и площади работали с любым из Ваших представлений?

#+BEGIN_SRC scheme
  (define (P sqaure-figure)
    (let* ((length-segment (car sqaure-figure))
           (height-segment (cdr sqaure-figure))
           (start-length (start-segment length-segment))
           (end-length (end-segment length-segment))
           (start-height (start-segment height-segment))
           (end-height (end-segment height-segment))
           (length (- (x-point end-length) (x-point start-length)))
           (height (- (y-point end-height) (y-point start-height))))
      (* (+ length height) 2)))

  (define (square sqaure-figure)
    (let* ((length-segment (car sqaure-figure))
           (height-segment (cdr sqaure-figure))
           (start-length (start-segment length-segment))
           (end-length (end-segment length-segment))
           (start-height (start-segment height-segment))
           (end-height (end-segment height-segment))
           (length (- (x-point end-length) (x-point start-length)))
           (height (- (y-point end-height) (y-point start-height))))
      (* length height)))


  ;; P и S квадрата
  (P (cons (cons (make-point 10 20) (make-point 40 20))
           (cons (make-point 40 20) (make-point 40 50))))

  (square (cons (cons (make-point 10 20) (make-point 40 20))
                (cons (make-point 40 20) (make-point 40 50))))

  ;; P и S прямоугольника
  (P (cons (cons (make-point 10 20) (make-point 40 20))
           (cons (make-point 40 20) (make-point 40 80))))

  (square (cons (cons (make-point 10 20) (make-point 40 20))
                (cons (make-point 40 20) (make-point 40 80))))
#+END_SRC

~Упражнение 2.4~
Вот еще одно процедурное представление для пар. Проверьте для этого представления, что
при любых двух объектах x и y (car (cons x y)) возвращает x.

Каково соответствующее определение cdr?
(Подсказка: Чтобы проверить, что это работает, используйте подстановочную модель из
раздела 1.1.5.)

#+BEGIN_SRC scheme
  (define (test-cons x y)
    ;; видимо m - это процедура от двух аргументов
    (lambda (m)
      (m x y)))

  (define (test-car z)
    ;; лямбда принимает 2 аргумента
    ;; и возвращает первый
    (z (lambda (p q) p)))

  (define (test-cdr z)
    ;; лямбда принимает 2 аргумента
    ;; и возвращает второй11
    (z (lambda (p q) q)))


  (test-car (test-cons 1 2))
  (test-cdr (test-cons 1 2))
#+END_SRC

~Упражнение 2.5~
Покажите, что можно представлять пары неотрицательных целых чисел, используя только
числа и арифметические операции, если представлять пару a и b как произведение 2^a
3^b. Дайте соответствующие определения процедур cons, car и cdr.

#+BEGIN_SRC scheme
  (define (even? n)
    (= (remainder n 2) 0))

  (define (fast-expt b n)
    (cond ((= n 0) 1)
          ((even? n) (square (fast-expt b (/ n 2))))
          (else (* b (fast-expt b (- n 1))))))

  (define (crazy-cons a b)
    (* (fast-expt 2 a) (fast-expt 3 b)))

  (define (crazy-car pair)
    (find-value 2 pair))

  (define (find-value base value)
    (define (iter value count)
      (if (= (remainder value base) 0)
          (iter (/ value base) (+ 1 count))
          count))
    (iter value 0))

#+END_SRC

~Упражнение 2.6~
Если представление пар как процедур было для Вас еще недостаточно сумасшедшим, то
заметьте, что в языке, который способен манипулировать процедурами, мы можем обойтись
и без чисел (по крайней мере, пока речь идет о неотрицательных числах), определив
0 и операцию прибавления 1 так:

#+BEGIN_SRC scheme
  (define zero
    (lambda (f) (lambda (x) x)))

  ((zero +) 4)

  ;; n - какая-то функция, которая принимает другую фукцию на вход
  (define (add-1 n)
    (lambda (f)
      (lambda (x)
        (f ((n f) x)))))

  (add-1 zero)
  (lambda (f)
    (lambda (x)
      (f (((lambda (f) (lambda (x) x)) f) x))))

  (lambda (f)
    (lambda (x)
      (f ((lambda (x) x) x))))

  (define (one f)
    (lambda (f)
      (lambda (x) (f x))))

  (add-1 one)
  (define (two f)
    (lambda (f)
      (lambda (x)
        (f (((lambda (f)
               (lambda (x) (f x))) f) x)))))

  n раз применить s к применённому m раз s к z
  (add-1 add-1)
  (define (Plus m n)
    (lambda (f x)
      (m f (n f x))))
#+END_SRC

Такое представление известно как числа Чёрча (Church numerals), по имени его
изобретателя, Алонсо Чёрча, того самого логика, который придумал λ-исчисление.
Определите one (единицу) и two (двойку) напрямую (не через zero и add-1).
(Подсказка: вычислите (add-1 zero) с помощью подстановки.)
Дайте прямое определение процедуры сложения +
(не в терминах повторяющегося применения add-1).

~Упражнение 2.7.~
Программа Лизы неполна, поскольку она не определила, как реализуется абстракция
интервала.
Вот определение конструктора интервала:
(define (make-interval a b) (cons a b))
Завершите реализацию, определив селекторы upper-bound и lower-bound.

исходник:
#+BEGIN_SRC scheme
  (define (make-interval a b)
    (cons a b))

  (define (upper-bound n)
    (cdr n))

  (define (lower-bound n)
    (car n))

  (define (add-interval x y)
    (make-interval (+ (lower-bound x) (lower-bound y))
                   (+ (upper-bound x) (upper-bound y))))

  (define (mul-interval x y)
    (let ((p1 (* (lower-bound x) (lower-bound y)))
          (p2 (* (lower-bound x) (upper-bound y)))
          (p3 (* (upper-bound x) (upper-bound y)))
          (p4 (* (upper-bound x) (lower-bound y))))
      (make-interval (min p1 p2 p3 p4)
                     (max p1 p2 p3 p4))))

  (define (div-interval x y)
    (mul-interval x
                  (make-interval (/ 1.0 (upper-bound y))
                                 (/ 1.0 (lower-bound y)))))

#+END_SRC

~Упражнение 2.8~
Рассуждая в духе Лизы, опишите, как можно вычислить разность двух интервалов. Напишите
соответствующую процедуру вычитания, называемую sub-interval.

#+BEGIN_SRC scheme
  (define (sub-interval x y)
    (cond ((and (> (lower-bound x) (lower-bound y))
                (> (upper-bound x) (upper-bound y)))
           (make-interval (- (lower-bound x) (lower-bound y))
                          (- (upper-bound x) (upper-bound y))))
          ((and (< (lower-bound x) (lower-bound y))
                (< (upper-bound x) (upper-bound y)))
           (make-interval (- (lower-bound y) (lower-bound x))
                          (- (upper-bound y) (upper-bound x))))
          ((and (> (lower-bound x) (lower-bound y))
                (< (upper-bound x) (upper-bound y)))
           (make-interval (- (lower-bound x) (lower-bound y))
                          (- (upper-bound y) (upper-bound x))))
          (else (make-interval (- (lower-bound y) (lower-bound x))
                               (- (upper-bound x) (upper-bound y))))))
#+END_SRC

~Упражнение 2.9~
Радиус (width) интервала определяется как половина расстояния между его верхней и
нижней границами. Радиус является мерой неопределенности числа, которое обозначает
интервал. Есть такие математические операции, для которых радиус результата зависит
только от радиусов интервалов-аргументов, а есть такие, для которых радиус результата
не является функцией радиусов аргументов.
Покажите, что радиус суммы (или разности) двух интервалов зависит только от
радиусов интервалов, которые складываются (или вычитаются). Приведите примеры, которые
показывают, что для умножения или деления это не так.

Предположим есть интервал (2 . 8) Его радиус будет равен 3, посольку это половина
расстояния от 2 до 8.

#+BEGIN_SRC scheme
  (define (width i)
    (/ (- (upper-bound i) (lower-bound i)) 2))

  (define A (cons 2.0 5.0))
  (define B (cons 4.0 8.0))

  ;; радиусы равны
  (width (add-interval A B))
  (+ (width A) (width B))

  ;; радиусы не равны
  (width (mul-interval A B))
  (* (width A) (width B))

#+END_SRC

~Упражнение 2.10.~
Бен Битобор, системный программист-эксперт, смотрит через плечо Лизы и замечает:
неясно, что должно означать деление на интервал, пересекающий ноль.
Модифицируйте код Лизы так, чтобы программа проверяла это условие и сообщала об ошибке,
если оно возникает.

#+BEGIN_SRC scheme

(define (my-div-interval x y)
    (if (or (<= (lower-bound x) 0) (<= (lower-bound y) 0)
            (<= (upper-bound y) 0)  (<= (upper-bound x) 0))
        (display "error!\n")
        (let ((p1 (/ (lower-bound x) (lower-bound y)))
              (p2 (/ (lower-bound x) (upper-bound y)))
              (p3 (/ (upper-bound x) (upper-bound y)))
              (p4 (/ (upper-bound x) (lower-bound y))))
          (make-interval (min p1 p2 p3 p4)
                         (max p1 p2 p3 p4)))))

#+END_SRC

~Доделать! Упражнение 2.11~
Проходя мимо, Бен делает туманное замечание: «Если проверять знаки концов интервалов,
можно разбить mul-interval на девять случаев, из которых только в одном требуется
более двух умножений». Перепишите эту процедуру в соответствии с предложением Бена.

- проверить знаки на концах интервалов
- реализовать конд, в котором будет 9 случаев
- 9ый - else, в котором будет более 2х умножений

#+BEGIN_SRC scheme
  (define (mul-interval x y)
    (let ((p1 (* (lower-bound x) (lower-bound y)))
          (p2 (* (lower-bound x) (upper-bound y)))
          (p3 (* (upper-bound x) (upper-bound y)))
          (p4 (* (upper-bound x) (lower-bound y))))
      (make-interval (min p1 p2 p3 p4)
                     (max p1 p2 p3 p4))))


  (define A (cons 2.0 5.0))
  (define B (cons 4.0 8.0))

  (define (mul-interval x y)
    (let ((p1 (* (lower-bound x) (lower-bound y)))
          (p2 (* (lower-bound x) (upper-bound y)))
          (p3 (* (upper-bound x) (upper-bound y)))
          (p4 (* (upper-bound x) (lower-bound y))))
      (format #t "p1 ~A p2 ~A p3 ~A p4 ~A\n" p1 p2 p3 p4)
      (make-interval (min p1 p2 p3 p4)
                     (max p1 p2 p3 p4))))

  (define (my-mul-interval x y)
    (cond ((and (< (lower-bound x) 0) (> (upper-bound y) 0) (> (upper-bound x) 0))
           (make-interval (* (lower-bound x) (upper-bound y)) (* (upper-bound y)
                                                                 (upper-bound x))))
          ((and (< (lower-bound y) 0) (> (upper-bound x) 0) (> (upper-bound y) 0))
           (make-interval (* (lower-bound y) (upper-bound x)) (* (upper-bound y)
                                                                 (upper-bound x))))
          ((and (> (lower-bound x) 0) (< (upper-bound y) 0) (> (upper-bound x) 0)
                (> (lower-bound y) 0))
                (make-interval (* (lower-bound x) (upper-bound y)) (* (lower-bound y)
                                                                      (upper-bound x))))
          ((and (> (lower-bound x) 0) (< (upper-bound y) 0) (> (upper-bound x) 0)
                (> (lower-bound y) 0))
           (make-interval (* (lower-bound x) (upper-bound y)) (* (lower-bound y)
                                                                 (upper-bound x))))


#+END_SRC

~Упражнение 2.12~
Определите конструктор make-center-percent, который принимает среднее значение и по-
грешность в процентах и выдает требуемый интервал. Нужно также определить селектор
percent, который для данного интервала выдает погрешность в процентах.
Селектор center остается тем же, что приведен выше.

#+BEGIN_SRC scheme
  (define (make-center-width c w)
    (make-interval (- c w) (+ c w)))

  (define (center i)
    (/ (+ (lower-bound i) (upper-bound i)) 2))

  (define (width i)
    (/ (- (upper-bound i) (lower-bound i)) 2))

  (define (percent i)
    (let* ((c (center i))
           (inaccuracy (- (upper-bound i) c)))
           (* (/ inaccuracy c) 100)))

  (define (make-center-percent c p)
    (let ((inaccuracy (* (/ c 100) p)))
      (make-interval (- c inaccuracy) (+ c inaccuracy))))

#+END_SRC

~Упражнение 2.13~
Покажите, что, если предположить, что погрешность составляет малую долю величины
интервала, то погрешность в процентах произведения двух интервалов можно получить
из погрешности в процентах исходных интервалов по простой приближенной формуле.
Задачу можно упростить, если предположить, что все числа положительные.

- берем интервалы с небольшой погрешностью
- умножаем интервалы друг на друга
- получаем погрешность в процентах
- считаем погрешность в процентах у одного исходного интервала и у другого
- доказать, что погрешность у интервала-произведения можно получить из
  интервалов-исходников по приближенной формуле (какой?)

#+BEGIN_SRC scheme
  (define A (make-center-percent 40.0 3.0))
  (define B (make-center-percent 30.0 3.0))

  ;; процент погрешности при произведении 2х исходных интервалов примерно = проценту
  ;; погрешности при складывании погрешностей и исходных интервалов
  ;; (если изначальная погрешность не более 10%)
  (percent (mul-interval A B))
  (+ (percent A) (percent B))

#+END_SRC

~Упражнение 2.14~
Покажите, что Дайко прав. Исследуйте поведение системы на различных арифметических
выражениях. Создайте несколько интервалов A и B и вычислите с их помощью выражения A/A
и A/B. Наибольшую пользу Вы получите, если будете использовать интервалы, радиус которых
составляет малую часть от среднего значения.
Исследуйте результаты вычислений в форме центр/проценты.
(См. упр 2.12)

То есть надо найти интервалы с небольшим разбросом и работать с ними.

#+BEGIN_SRC scheme

  (define (par1 r1 r2)
    (div-interval (mul-interval r1 r2)
                  (add-interval r1 r2)))

  (define (par2 r1 r2)
    (let ((one (make-interval 1 1)))
      (div-interval one
                    (add-interval (div-interval one r1)
                                  (div-interval one r2)))))

  ;; Проверка:
  (define A (cons 2 5))
  (define B (cons 4 8))

  (percent (par2 A A))
  = 42.857142857142854

  (percent (par2 A B))
  = 39.53488372093024

  (percent (par1 A B))
  = 83.09859154929579

  (percent (par1 A A))
  = 87.96992481203006

  (center (par1 A A))
  = 3.325

  (center (par2 A A))
  = 1.75

  (center (par2 A B))
  = 2.205128205128205

  (center (par1 A B))
  = 3.6410256410256405
#+END_SRC

~Упражнение 2.15~
Ева Лу Атор, другой пользователь Лизиной программы, тоже заметила, что алгебраически
эквивалентные, но различные выражения могут давать разные результаты. Она говорит, что
формула для вычисления интервалов, которая использует Лизину систему, будет
давать более узкие границы погрешности, если ее удастся записать так, чтобы ни одна
переменная, представляющая неточную величину, не повторялась. Таким образом, говорит
она, par2 «лучше» как программа для параллельных резисторов, чем par1.
Права ли она? Почему?

Ответ: логично предположить, что чем больше неточных данных мы используем, тем больше
общая неточность результата. Поскольку par2 использует только 2 неточные величины
вместо четырех, мы можем сказать, что par2 лучше.

~Упражнение 2.16~
Объясните в общем случае, почему эквивалентные алгебраические выражения могут давать
разные результаты. Можете ли Вы представить себе пакет для работы с интервальной
арифметикой, который бы не обладал этим недостатком, или такое невозможно?
(Предупреждение: эта задача очень сложна.)

Ответ: например, дело может быть в особенностях хранения цифр с плавающей
запятой. Из-за, казалось бы, эквивалентных алгебраических действий, неточность может
накапливаться и приводить к разным результатам.

Решение подобной проблемы - это задать меру точности, т.е. сколько знаком после запятой
мы будем оставлять на каждом этапе вычисления.

~Упражнение 2.17.~
Определите процедуру last-pair, которая возвращает список, содержащий только последний
элемент данного (непустого) списка.
(last-pair (list 23 72 149 34))
= (34)

#+BEGIN_SRC scheme
  (define (last-pair lst)
    (list-ref lst (- (length lst) 1)))
#+END_SRC

~Упражнение 2.18~
Определите процедуру reverse, которая принимает список как аргумент и возвращает
список, состоящий из тех же элементов в обратном порядке:
(reverse (list 1 4 9 16 25))
(25 16 9 4 1)

#+BEGIN_SRC scheme
  (define (reverse lst)
    (define (iter lst new-lst)
      (if (null? lst)
          new-lst
          (iter (cdr lst) (cons (car lst) new-lst))))
    (iter lst (list)))
#+END_SRC

~Упражнение 2.19.~
Рассмотрим программу подсчета способов размена из раздела 1.2.2. Было бы приятно иметь
возможность легко изменять валюту, которую эта программа использует, так, чтобы можно
было, например, вычислить, сколькими способами можно разменять британский фунт.
Эта программа написана так, что знание о валюте распределено между процедурами
first-denomination и count-change (которая знает, что существует пять видов
американских монет). Приятнее было бы иметь возможность просто задавать список монет,
которые можно использовать при размене.
Мы хотим переписать процедуру cc так, чтобы ее вторым аргументом был список монет, а не
целое число, которое указывает, какие монеты использовать. Тогда у нас могли бы быть
списки, определяющие типы валют:
(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))
Можно было бы вызывать cc следующим образом:
(cc 100 us-coins)
= 292
Определите процедуры first-denomination, except-first-denomination и no-more? в
терминах элементарных операций над списковыми структурами. Влияет ли порядок списка
coin-values на результат, получаемый cc? Почему?
#+BEGIN_SRC scheme
  (define (no-more? coin-values)
    (if (null? coin-values)
        #t
        #f))

  (define (except-first-denomination coin-values)
    (cdr coin-values))

  (define (first-denomination coin-values)
    (car coin-values))

  (define (cc amount coin-values)
    (cond ((= amount 0) 1)
          ((or (< amount 0) (no-more? coin-values)) 0)
          (else
           (+ (cc amount
                  (except-first-denomination coin-values))
              (cc (- amount
                     (first-denomination coin-values))
                  coin-values)))))

  (define us-coins (list 50 25 10 5 1))
  (define uk-coins (list 100 50 20 10 5 2 1 0.5))

  (cc 100 us-coins)
#+END_SRC

Ответ: порядок в списке coin-values не влияет на результат, потому что важен не порядок
элементов, а их общее количество. Например, если в список добавить еще один элемент,
то количество вариантов размена изменится.

~Упражнение 2.20~
Используя точечную нотацию, напишите процедуру same-parity, которая принимает одно или
более целое число и возвращает список всех тех аргументов, у которых четность та же,
что у первого аргумента. Например,
(same-parity 1 2 3 4 5 6 7)
(1 3 5 7)
(same-parity 2 3 4 5 6 7)
(2 4 6)

#+BEGIN_SRC scheme
  (define (even? n)
    (= (remainder n 2) 0))

  (define (same-parity n . nums)
    (let ((lst (list n)))
      (define (iter nums new-lst)
        (cond ((null? nums) (reverse new-lst))
              ((and (even? (car nums)) (even? (car new-lst)))
               (iter (cdr nums) (cons (car nums) new-lst)))
              ((and (not (even? (car nums))) (not (even? (car new-lst))))
               (iter (cdr nums) (cons (car nums) new-lst)))
              (else (iter (cdr nums) new-lst))))
      (iter nums lst)))
#+END_SRC

~Упражнение 2.21~
Процедура square-list принимает в качестве аргумента список чисел и возвращает список
квадратов этих чисел.
(square-list (list 1 2 3 4))
(1 4 9 16)
Перед Вами два различных определения square-list. Закончите их, вставив пропущенные вы-
ражения:

#+BEGIN_SRC scheme
  ;; первый вариант решения без map
  (define (square-list items)
    (define (iter items lst)
      (if (null? items)
          (reverse lst)
          (iter (cdr items) (cons (* (car items) (car items)) lst))))
    (iter items (list)))

  ;; правильный вариант
  (define (square-list items)
    (if (null? items)
        #nil
        (cons (* (car items) (car items))
              (square-list (cdr items)))))

  (define (square-list items)
    (map (lambda (x)  (* x x))
         items))
#+END_SRC

~Упражнение 2.22~
Хьюго Дум пытается переписать первую из процедур square-list из упражнения 2.21 так,
чтобы она работала как итеративный процесс. К сожалению, такое определение square-list
выдает список результатов в порядке, обратном желаемому. Почему?
Затем Хьюго пытается исправить ошибку, обменяв аргументы cons, но этот вариант так же
не срабатывает, объясните, почему.

В первом случае список выходит перевернутым, поскольку элемент, который мы добавляем к
списку с помощью cons, добавляется в начало списка. Если же попытаться поменять
аргументы cons местами, то мы попытаемся приклеить элементк концу списка. Только конец
списка - это не его последний элемент, а nil. В результате мы получаем пару, а не
склеенный список.


~Упражнение 2.23.~
Процедура for-each похожа на map. В качестве аргументов она принимает процедуру и спи-
сок элементов. Однако вместо того, чтобы формировать список результатов, for-each
просто применяет процедуру по очереди ко всем элементам слева направо.
Результаты применения процедуры к аргументам не используются вообще — for-each
применяют к процедурам, которые осуществляют какое-либо действие вроде печати.
Например,
(for-each (lambda (x) (newline) (display x))
(list 57 321 88))
57
321
88
Значение, возвращаемое вызовом for-each (оно в листинге не показано) может быть каким
угодно, например истина. Напишите реализацию for-each.

#+BEGIN_SRC scheme
  (define (for-each fn lst)
    (if (null? lst)
        #nil
        (and (fn (car lst)) (for-each fn (cdr lst)))))
#+END_SRC

~Упражнение 2.24~
Предположим, мы вычисляем выражение (list 1 (list 2 (list 3 4))). Укажите, какой
результат напечатает интерпретатор, изобразите его в виде стрелочной диаграммы, а также
его интерпретацию в виде дерева (как на рисунке 2.6)

#+BEGIN_SRC scheme
  (list 1 (list 2 (list 3 4)))

  = (1 (2 (3 4)))
#+END_SRC

~Упражнение 2.25~
Укажите комбинации car и cdr, которые извлекают 7 из следующих списков:

#+BEGIN_SRC scheme
  ;; (1 3 (5 7) 9)

  (car (cdr (car (cdr (cdr (list 1 3 (list 5 7) 9))))))

  ;; ((7))

  (car (car (list (list 7))))

  ;; (1 (2 (3 (4 (5 (6 7))))))

  (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7))))))))))))))))))
#+END_SRC

~Упражнение 2.26~.
Допустим, мы определили x и y как два списка.
Какой результат напечатает интерпретатор в ответ на следующие выражения:
#+BEGIN_SRC scheme
  (define x (list 1 2 3))
  (define y (list 4 5 6))

  (append x y)
  = (1 2 3 4 5 6)

  (cons x y)
  = ((1 2 3) 4 5 6)

  (list x y)
  = ((1 2 3) (4 5 6))
#+END_SRC

~Упражнение 2.27.~
Измените свою процедуру reverse из упражнения 2.18 так, чтобы получилась процедура
deep-reverse, которая принимает список в качестве аргумента и возвращает в качестве
значения список, где порядок элементов обратный и подсписки также обращены.

#+BEGIN_SRC scheme
  ;; например:

  (define x (list (list 1 2) (list 3 4)))

  x
  = ((1 2) (3 4))

  (reverse x)
  = ((3 4) (1 2))

  (deep-reverse x)
  = ((4 3) (2 1))

  ;; решение:

  (define (reverse lst)
    (define (iter lst new-lst)
      (if (null? lst)
          new-lst
          (iter (cdr lst) (cons (car lst) new-lst))))
    (iter lst (list)))

  (define (deep-reverse lst)
    (define (iter lst new-lst)
      (if (null? lst)
          new-lst
          (iter (cdr lst) (cons (reverse (car lst)) new-lst))))
    (iter lst (list)))
#+END_SRC

~Упражнение 2.28.~
Напишите процедуру fringe, которая берет в качестве аргумента дерево (представленное в
виде списка) и возвращает список, элементы которого — все листья дерева, упорядоченные
слева направо.

#+BEGIN_SRC scheme
  ;; Например

  (define x (list (list 1 2) (list 3 4)))

  (fringe x)
  = (1 2 3 4)

  (fringe (list x x))
  = (1 2 3 4 1 2 3 4)

  ;; решение
  (define (fringe lst)
    (if (pair? lst)
        (append (fringe (car lst)) (fringe (cdr lst)))
        (if (null? lst)
            #nil
            (list lst))))
#+END_SRC

~Упражнение 2.29~
Бинарный мобиль состоит из двух ветвей, левой и правой. Каждая ветвь представляет собой
стержень определенной длины, с которого свисает либо гирька, либо еще один бинарный
мобиль.
Мы можем представить бинарный мобиль в виде составных данных, соединив две ветви
(например, с помощью ~list~):

#+BEGIN_SRC scheme
(define (make-mobile left right)
(list left right))
#+END_SRC

Ветвь составляется из длины ~length~ (которая должна быть числом) и структуры
~structure~, которая может быть либо числом (представляющим простую гирьку),
либо еще одним мобилем

#+BEGIN_SRC scheme
(define (make-branch length structure)
(list length structure))
#+END_SRC

а. Напишите соответствующие селекторы ~left-branch~ и ~right-branch~, которые возвраща-
ют левую и правую ветви мобиля, а также ~branch-length~ и ~branch-structure~, которые
возвращают компоненты ветви.
б. С помощью этих селекторов напишите процедуру ~total-weight~, которая возвращает общий
вес мобиля.
в. Говорят, что мобиль сбалансирован, если момент вращения, действующий на его левую
ветвь, равен моменту вращения, действующему на правую ветвь (то есть длина левого
стержня, умноженная на вес груза, свисающего с него, равна соответствующему
произведению для правой стороны), и если все подмобили, свисающие с его ветвей,
также сбалансированы. Напишите предикат, который проверяет мобили на
сбалансированность.

Будем считать мобиль своеобразным неупорядоченным бинарным деревом.
Исходя из идеи, что соединение 2х веток с помощью list дает мобиль, скажем, что
левая ветка - это car, а правая - cdr списка.
Аналогично с компонентами ветви. Каждый узел ветви - эт длина + структура. Значит,
длина ветви (узла?) - это car текущего подсписка, а структура - cadr. Использование
cadr позволяет убрать один уровень вложенности.


~total-weight~ должна вернуть общий вес мобиля, т.е. пройтись по каждой структуре,
дойти до "гирек" и суммировать значения.


#+BEGIN_SRC scheme
  (define test-mobile
    (make-mobile (make-branch 10 (make-branch 10 (make-branch 10 13)))
                 (make-branch 10 (make-branch 10 (make-branch 10 18)))))

  (define test2-mobile
    (make-mobile (make-branch 10 (make-branch 10 (make-branch 10 (make-branch 10 20))))
                 (make-branch 10 (make-branch 10 (make-branch 10 18)))))

  (define (left-branch mobile)
    (car mobile))

  (define (right-branch mobile)
    (cadr mobile))

  (define (branch-length branch)
    (car branch))

  (define (branch-structure branch)
    (cadr branch))

  (define (total-weight mobile)
    (define (iter mobile)
      (cond ((and (pair? mobile)
                  (pair? (left-branch mobile))
                  (pair? (right-branch mobile)))
             (+ (iter (right-branch mobile))
                (iter (left-branch mobile))))
            ((and (pair? mobile) (pair? (right-branch mobile)))
                  (iter (right-branch mobile)))
            ((and (pair? mobile) (pair? (left-branch mobile)))
                  (iter (left-branch mobile)))
            (else (right-branch mobile))))
    (iter mobile))

  (define (balanced? mobile)
    (cond ((and (pair? mobile)
                (pair? (left-branch mobile))
                (pair? (right-branch mobile)))
           ( = (balanced? (right-branch mobile))
               (balanced? (left-branch mobile))))
          ((and (pair? mobile) (pair? (right-branch mobile)))
           (balanced? (right-branch mobile)))
          ((and (pair? mobile) (pair? (left-branch mobile)))
           (balanced? (left-branch mobile)))
          (else (*  (branch-length mobile) (branch-structure mobile)))))

#+END_SRC

г. Допустим, мы изменили представление мобилей, так что конструкторы теперь приняли
такой вид:

#+BEGIN_SRC scheme
(define (make-mobile left right)
(cons left right))

(define (make-branch length structure)
(cons length structure))
#+END_SRC

Как много пришлось поменять в остальной программе?
Ответ: пришлось поменять только селекторы.
#+BEGIN_SRC scheme
  (define (left-branch mobile)
    (car mobile))

  (define (right-branch mobile)
    (cdr mobile))

  (define (branch-length branch)
    (car branch))

  (define (branch-structure branch)
    (cdr branch))

#+END_SRC

~Упражнение 2.30~
Определите процедуру square-tree, подобную процедуре square-list из упражнения 2.21. А
именно, square-tree должна вести себя следующим образом:

#+BEGIN_SRC scheme
  (square-tree
   (list 1
         (list 2 (list 3 4) 5)
         (list 6 7)))
  = (1 (4 (9 16) 25) (36 49))

  (define (square-tree tree)
    (define (square x)
      (* x x))
    (map (lambda (sub-tree)
           (if (pair? sub-tree)
               (square-tree sub-tree)
               (square sub-tree)))
         tree))

  (define (square-tree tree)
    (define (square x)
      (* x x))
    (cond ((null? tree) #nil)
          ((not (pair? tree)) (square tree))
          (else (cons (square-tree (car tree))
                      (square-tree (cdr tree))))))
#+END_SRC

~Упражнение 2.31~
Абстрагируйте свой ответ на упражнение 2.30, получая процедуру tree-map, так, чтобы
square-tree можно было определить следующим образом:
(define (square-tree tree) (tree-map square tree))

#+BEGIN_SRC scheme
  (define (square-tree tree)
    (define (square x)
      (* x x))
    (tree-map square tree))

  (define (tree-map fn tree)
    (map (lambda (sub-tree)
           (if (pair? sub-tree)
               (tree-map fn sub-tree)
               (fn sub-tree)))
         tree))

#+END_SRC

~Упражнение 2.32.~
Множество можно представить как список его различных элементов, а множество его
подмножеств как список списков. Например, если множество равно (1 2 3), то множество его
подмножеств равно (() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3)).
Закончите следующее определение процедуры, которая порождает множество подмножеств
и дайте ясное объяснение, почему она работает:

#+BEGIN_SRC scheme
  (define (subsets s sp)
    (if (null? s)
        (list #nil)
        (let ((rest (subsets (cdr s) (+ 1 sp))))
          (space sp)
          (format #t "~A\n" rest)
          (space sp)
          (format #t "~A\n" s)
          (append rest (map (lambda (x)
                              (if (pair? s)
                                  (and (cons (cdr s) x) (cons (car s) x))
                                  (cons s x))) rest)))))
#+END_SRC

Сначала я предположила, что элементы, которые содержатся в ~rest~ нужно просто обернуть
в список. Но в ~rest~ перманентно содержится nil. Тогда я поняла, что элементы содержит
что-то еще. В нашем случае это ~s~, я подумала, что следует соединить элементы из  ~s~
и ~rest~ с помощью cons, результат был уже ближе, но все еще не тот.
Тогда я поняла, что в конечном результате есть закономерность: элементы из ~rest~
последовательно соединяется с ~car~ и ~cdr~ возвращенной последовательности, если это
последовательность. Так удалось написать верную лямбду.

О работе процедуры:
Чтобы образовать множество, нам нужно откатиться к концу исходной последовательности,
а затем начать последовательно комбинировать элементы друг с другом. Для этого мы
сначала рекурсивно вызваем ~subsets~ с cdr последовательности, таким образом мы доходим
до конца списка. Достигнув его, возвращаем nil, который попадает в ~rest~ как
возвращаемое значение рекурсии, и начинаем откатываться назад по стеку вызовов. Прежде
чем вызвать любую функцию, программе нужно запомнить состояние параметров, чтоб
вернуться к исходному состоянию стека, которое было до вызова функции, и корректно
продолжить работу. Соответственно, состояние ~s~, которая хранит в себе
последовательность, тоже сохраняется на стеке перед каждым рекурсивным вызовом. А при
откате назад значения восстанавливаются. Так в ~s~ постепенно попадает исходная
последовательность и и это позволяет написанной мною лямбде работать.


~Упражнение 2.33.~
Заполните пропущенные выражения, так, чтобы получились определения некоторых базовых
операций по работе со списками в виде накопления:

#+BEGIN_SRC scheme
  (define (accumulate op initial sequence)
    (if (null? sequence)
        initial
        (op (car sequence)
            (accumulate op initial (cdr sequence)))))


  (define (my-map p sequence)
    (accumulate (lambda (x y)
                  (cons (p x) y)) (list) sequence))

  (my-map (lambda (x) (*  x x)) (list 1 2 3 4))

  ;; вторая последовательность является базовым значением для
  ;; нового append, поскольку если первая последовательность окажется пустой
  ;; реальный append вернет вторую
  (define (my-append seq1 seq2)
    (accumulate cons seq2 seq1))

  (my-append (list 1 2 3 4) (list 4 5 6 7))

  ;; достигнув конца списка мы возвращаем 0, который при откате назад по стеку
  ;; вызовов будет восприниматься как возвращаемое значение вызова и займет место параметра Y
  (define (my-length sequence)
    (accumulate (lambda (x y)
                 (+ y 1)) 0 sequence))

  (my-length (list 1 2 3 4))
#+END_SRC

~Упражнение 2.34.~
Вычисление многочлена с переменной x при данном значении x можно сформулировать в виде
накопления. Мы вычисляем многочлен
AnX^n + An−1X^n−1 + . . . + A1x + A0
по известному алгоритму, называемому схема Горнера (Horner’s rule).

(. . . (AnX + An−1 )X + . . . + A1 )X + A0 )

Другими словами, мы начинаем с An , умножаем его на x, и так далее, пока не достигнем
A0.
Заполните пропуски в следующей заготовке так, чтобы получить процедуру, которая
вычисляет многочлены по схеме Горнера. Предполагается, что коэффициенты многочлена
представлены в виде последовательности, от A0 до An .

#+BEGIN_SRC scheme

  (define (horner-eval x coefficient-sequence)
    (accumulate (lambda (this-coeff higher-terms)
                  (+ this-coeff (* x higher-terms)))
                0
                coefficient-sequence))

  ;; Например, чтобы вычислить 1 + 3x + 5x^3 + x^5 в точке x = 2, нужно ввести
  ;; возможно, нули стоят потому, что нет икса в первой степени...
  (horner-eval 2 (list 1 3 0 5 0 1))
#+END_SRC

~Упражнение 2.35~
Переопределите count-leaves из раздела 2.2.2 в виде накопления.

Видимо, map должна собрать все листья (т.е. все непары)  и вернуть последовательность,
состоющую из листьев, после чего мы посчитаем их количество. Идея оказалась неверной.
Во-первых, map не может работать с деревьями, нужно было рекурсивно обойти дерево на
каждой итерации прохода по дереву. Но даже после того, как это удалось реализовать,
список результатов, возвращенный map, содержал вложенные списки. С которыми не может
работать и accumulate, поэтому пришлось рекурсивно обходить список и при подсчете
листов. В общем, громоздко, не понятно, не работало.

Нужно было разделить дерево на подпоследовательности и возвращать не список листьев,
а список единиц, где единица - это каждый найденный лист. Т.к. map проходит по
подпоследовательности и, встретив лист, записывает в список результатов 1. А затем все
значения в списке суммируются.


#+BEGIN_SRC scheme
  (define (accumulate op initial sequence)
    (format #t "~A\n" sequence)
    (if (null? sequence)
        initial
        (op (car sequence)
            (accumulate op initial (cdr sequence)))))

  ;; исходный вариант
  (define (count-leaves x)
    (cond ((null? x) 0)
          ((not (pair? x)) 1)
          (else (+ (count-leaves (car x))
                   (count-leaves (cdr x))))))
  ;; новый вариант
  (define (count-leaves tree)
    (accumulate + 0 (map (lambda (x)
                           (if (pair? x)
                               (count-leaves x)
                               1))
                         tree)))

#+END_SRC


~Упражнение 2.36.~
Процедура ~accumulate-n~ подобна ~accumulate~, только свой третий аргумент она
воспринимает как последовательность последовательностей, причем предполагается,
что все они содержат одинаковое количество элементов. Она применяет указанную процедуру
накопления ко всем первым элементам последовательностей, вторым элементам
последовательностей и так далее, и возвращает последовательность результатов.
Например, если ~s~ есть последовательность, состоящая из четырех последовательностей,
((1 2 3) (4 5 6) (7 8 9) (10 11 12)), то значением (accumulate-n + 0 s)
будет последовательность (22 26 30).
Заполните пробелы в следующем определении accumulate-n.

Ясно, что в ~accumulate-n~ третьим аргументом всегда должна быть последовательность
последовательностей. Cитуация, когда car последовательности оказался
пустым списком, возможно только если список стал похож на (()).

Это значит, что нужно постепенно вытаскивать из каждого подсписка по элементу,
пока они не станут пустыми.

Вариант написать 2 процедуры: одна выстаскивает каждый раз из всех подсписков списка,
другая делает то же, но с cdr. Так пришла идея использовать ~map~

#+BEGIN_SRC scheme
  (define (accumulate op initial sequence)
    (if (null? sequence)
        initial
        (op (car sequence)
            (accumulate op initial (cdr sequence)))))

  (define (accumulate-n op init seqs)
    (if (null? (car seqs))
        #nil
        (cons (accumulate op init (map (lambda (x)
                                         (car x)) seqs))
              (accumulate-n op init (map (lambda (x)
                                           (cdr x)) seqs)))))

  (define s (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))

  (accumulate-n + 0 s)
#+END_SRC

~Упражнение 2.37.~
Заполните пропуски в следующих процедурах для вычисления остальных матричных операций.

#+BEGIN_SRC scheme
  (define mat (list (list 1 2 3) (list 4 5 6)))
  (define vec (list 10 11 12))
  (define mat2 (list (list 1 2 3) (list 4 5 6) (list 7 8 9)))

  ;; скалярное произведение
  (define (dot-product v w)
    (accumulate + 0 (map * v w)))

  ;; произведение матрицы и вектора
  ;; чтоб умножить матрицу на ветор, нужно умножить первый компонент вектора
  ;; на все первые элементы строк матрицы, потом так же второй и т.д., а потом сложить
  ;; значения в каждой строке матрицы. Так получится новый вектор.
  (define (matrix-*-vector m v)
    (map (lambda (x)
           (dot-product v x)) m))

  ;; транспозиция матрицы
  ;; для получения транспонированной матрицы из исходной нужно каждую строчку исходной
  ;; матрицы записать в виде столбца в том же порядке
  (define (transpose mat)
    (accumulate-n (lambda (x y)
                    (cons x y)) #nil mat))

  ;; произведение матриц
  ;; кол-во строк в матрице А должно совпадать с кол-вом столбцов в матрице В
  (define mat-A (list (list 1 2 2) (list 3 1 1)))
  (define mat-B (list (list 4 2) (list 3 1) (list 1 5)))

  ;; сначала я думала, что надо задать 2 идентичные по размеру матрицы, но потом поняла, что
  ;; следует задавать матрицы так, как мы бы делали от руки, т.к. по правилу, описанному выше
  ;; А транспозиция превратит вторую матрицу в идентичную первой по размеру. И таким образом
  ;; мы сможем представить матрицы как набор векторов.
  ;; А раз это набор векторов, то можно использовать скалярное произведение. Все завернуто в
  ;; в list, чтоб можно было использовать append, тогда все красиво выводится.
  (define (matrix-*-matrix m n)
    (let ((cols (transpose n)))
      (map (lambda (x)
             (append (list (dot-product (car cols) x)) (list (dot-product (cadr cols) x))))
           m)))
#+END_SRC

~Упражнение 2.38.~
Процедура accumulate известна также как fold-right (правая свертка), поскольку она
комбинирует первый элемент последовательности с результатом комбинирования
всех элементов справа от него.
Существует также процедура fold-left (левая свертка), которая подобна
fold-right, но комбинирует элементы в противоположном направлении.
Каковы значения следующих выражений?

Укажите свойство, которому должна удовлетворять op, чтобы для любой последовательности
fold-right и fold-left давали одинаковые результаты.

Ответ: op должно быть коммутативно, т.е. чтоб порядок аргументов для предиката не имел
значения

#+BEGIN_SRC scheme
    (define (fold-left op initial sequence)
      (define (iter result rest)
        (if (null? rest)
            result
            (iter (op result (car rest))
                  (cdr rest))))
      (iter initial sequence))

    ;; раз fold-right подобна accumulate, то и выражения я проверяла с помощью accumulate
    (fold-right / 1 (list 1 2 3))
    = 3/2

    (fold-left / 1 (list 1 2 3))
    = 1/6

    (fold-right list #nil (list 1 2 3))
    = (1 (2 (3 #nil)))

    (fold-left list #nil (list 1 2 3))
    = (((#nil 1) 2) 3)


  ;; Пример для ответа:
  (accumulate * 1 (list 1 2 3))
  (fold-left * 1 (list 1 2 3))
#+END_SRC

~Упражнение 2.39~
Закончите следующие определения reverse (упражнение 2.18) в терминах процедур fold-
right и fold-left из упражнения 2.38.

#+BEGIN_SRC scheme
  (define (reverse lst)
    (define (iter lst new-lst)
      (if (null? lst)
          new-lst
          (iter (cdr lst) (cons (car lst) new-lst))))
    (iter lst (list)))

  (define (reverse-right sequence)
    (accumulate (lambda (x y) (append y (list x))) #nil sequence))

  (define (reverse-left sequence)
    (fold-left (lambda (x y) (cons y x)) #nil sequence))
#+END_SRC

~Упражнение 2.40.~
Определите процедуру unique-pairs, которая, получая целое число n, порождает последова-
тельность пар (i, j), таких, что 1 ≤ j < i ≤ n. С помощью unique-pairs упростите данное
выше определение prime-sum-pairs.

i = n - 1 или n
j = диапазон от 1<=j до i - 1
нужно породить пары i и j. 2 вложенных чикла, которые будут выполняться, пока i не
достигнет значение n и n-1

для каждого целого i ≤ n перечислить целые числа j < i, и для каждых таких i и j
породить пару (i, j)

Фактически меня просят разбить процедуру на подпроцедуры, чтоб ее стало проще
воспринимать.

У автора процедура ~enumerate-interval~ встроена в стандарт его схемы, мне же ее
пришлось написать.

#+BEGIN_SRC scheme
  (define (square x) (* x x))

  (define (divides? a b)
    (= (remainder b a) 0))

  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor n (+ test-divisor 1)))))

  (define (smallest-divisor n)
    (find-divisor n 2))

  (define (prime? n)
    (= n (smallest-divisor n)))

  ;; отсюда начинается определение процедуры мана. Все функции до этого места вспомогательны,
  ;; рассчитано, что они уже залиты в интерпритатор, поэтому они просто используются по ходу
  ;; книги

  (define (prime-sum? pair)
    (prime? (+ (car pair) (cadr pair))))

  (define (flatmap proc seq)
    (accumulate append #nil (map proc seq)))

  (define (make-pair-sum pair)
    (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))

  (define (enumerate-interval start end)
    (if (< start end)
        (cons start (enumerate-interval (+ 1 start) end))
        (list end)))

  ;; исходный вариант
  (define (prime-sum-pairs n)
    (map make-pair-sum
         (filter prime-sum?
                 (flatmap
                  ;; сюда попадает последовательность
                  (lambda (i)
                    ;; для каждого i получаем пару (i j), где j всегда меньше i
                    (map (lambda (j) (list i j))
                         (enumerate-interval 1 (- i 1))))
                  ;; порождаем последовательность от 1 до n
                  (enumerate-interval 1 n)))))


  (define (unique-pairs n)
    (flatmap
     ;; сюда попадает последовательность
     (lambda (i)
       ;; для каждого i получаем пару (i j), где j всегда меньше i
       (map (lambda (j) (list i j))
            (enumerate-interval 1 (- i 1))))
     ;; порождаем последовательность от 1 до n
     (enumerate-interval 1 n)))

  ;; мой вариант
  (define (prime-sum-pairs n)
    (map make-pair-sum
         (filter prime-sum?
                 (unique-pairs n))))
#+END_SRC

~Упражнение 2.41.~
Напишите процедуру, которая находит все такие упорядоченные тройки различных
положительных целых чисел i, j и k, меньших или равных данному целому числу n,
сумма которых равна данному числу s.

i, j ,k <= n
найти такие i j k, которые при сложении дадут s. собрать их в последоватлеьность
значит, надо сгенерировать 3 последовтаельности, где числа <=n.
затем попробовать сложить
Пусть последовательности разворачиваются в разных порядках: две от n до 1,
а одна от 1 до n

#+BEGIN_SRC scheme
  (define (new-enumerate-interval end start)
    (if (> end start)
        (cons end (new-enumerate-interval (- end 1) start))
        (list start)))

  (define (flatmap proc seq)
    (accumulate append #nil (map proc seq)))

  ;; вариант с грязным хаком
  ;; как состоит в использовании cond. но так есть возможность предусмотреть все варианты
  (define (find-sum s n)
    (define (sum? seq)
      (format #t "i ~A j ~A k ~A\n" (car seq) (cadr seq) (cadr (cdr seq)))
      (= s (+ (car seq) (cadr seq) (cadr (cdr seq)))))
    (filter sum?
            (flatmap
             (lambda (i)
               (map (lambda (j k)
                      (cond ((sum? (list (+ i) j k)) (list (+ i) j k))
                            ((sum? (list i (+ 1 j) k)) (list i (+ j) k))
                            ((sum? (list i (- j 1) k)) (list i (- j 1) k))
                            ((sum? (list (- i 1) j k)) (list (- i) j k))
                            (else (list i j k))))
                    (enumerate-interval 1 n) (new-enumerate-interval n 1)))
             (new-enumerate-interval n 1))))


  ;; подсмотренный вариант без грязного хака
  ;; но мне кажется, что мой более правильный в плане того, что у меня
  ;; i, j , k могут быть = n, а у этого решения j и k никогда не будут = n
  ;; к тому же, у него отсутствуют некоторые варианты слагаемых суммы
  ;; если, к примеру, вызвать (triples-with-sum 10 8), то будут отсутствовать варианты
  ;; (6 2 2), (8 1 1) и т.д. а у меня они есть ;)

  (define (unique-triples n)
    (flatmap (lambda (i)
               (flatmap (lambda (j)
                          (map (lambda (k) (list i j k))
                               (enumerate-interval 1 (- j 1))))
                        (enumerate-interval 1 (- i 1))))
             (enumerate-interval 1 n)))

  (define (triples-with-sum s n)
  (filter (lambda (t) (= (accumulate + 0 t) s))
                    (unique-triples n)))
#+END_SRC


~Упражнение 2.42.~
В «задаче о восьми ферзях» спрашивается, как расставить на шахматной доске восемь
ферзей так, чтобы ни один из них не бил другого (то есть никакие два ферзя не должны
находиться на одной вертикали, горизонтали или диагонали).
Один из способов решать эту задачу состоит в том, чтобы идти поперек доски,
устанавливая по ферзю в каждой вертикали. После того, как k − 1 ферзя мы уже
разместили, нужно разместить k-го в таком месте, где он не бьет ни одного из тех,
которые уже находятся на доске. Этот подход можно сформулировать рекурсивно:
предположим, что мы уже породили последовательность из всех возможных способов
разместить k − 1 ферзей на первых k − 1 вертикалях доски. Для каждого из этих способов
мы порождаем расширенный набор позиций, добавляя ферзя на каждую горизонталь k-й
вертикали. Затем эти позиции нужно отфильтровать, оставляя только те, где
ферзь на k-й вертикали не бьется ни одним из остальных. Продолжая этот процесс, мы
породим не просто одно решение, а все решения этой задачи.

Это решение мы реализуем в процедуре ~queens~, которая возвращает последовательность ре-
шений задачи размещения n ферзей на доске n × n. В процедуре queens есть внутренняя
процедура ~queen-cols~, которая возвращает последовательность всех способов разместить
ферзей на первых k вертикалях доски.
В этой процедуре ~rest-of-queens~ есть способ размещения k − 1 ферзя на первых k − 1
вертикалях, а ~new-row~ — это горизонталь, на которую предлагается поместить ферзя с k-й
вертикали.
Завершите эту программу, реализовав представление множеств позиций ферзей на доске,
включая процедуру ~adjoin-position~, которая добавляет нового ферзя на определенных
горизонтали и вертикали к заданному множеству позиций, и empty-board, которая
представляет пустое множество позиций. Еще нужно написать процедуру safe?,
которая для множества позиций определяет, находится ли ферзь с k-й вертикали в
безопасности от остальных. (Заметим, что нам требуется
проверять только то, находится ли в безопасности новый ферзь — для остальных ферзей
безопасность друг от друга уже гарантирована.)

Бередом доску 8 на 8. Расставляем на ней 7 ферзей по вертикалям (пофиг, что сейчас они
все бьют друг друга). Теперь нужно придумать, как поставить восьмого ферзя так, чтоб
его не могли быть ни один из уже стоящих на доске.

Как это сделать? Нужна рекурсия.
- мы уже разместили всех ферзей по вертикалям всеми возможными способами
- для каждого из этих вариантов мы получаем набор вариантов, добавляя по ферзю на
  каждую горизонталь текущей вертикали.
- затем фильтруем позици, оставляя только те, где ферзь на конкретной вертикали не
  бьется никаким из остальных ферзей

Функция filter похожа на map, но: работает с последовательностями, которые состоят из
подпоследовательностей. Применяет к подспискам предикат, и если предикат дает t,
включает подсписок в список результатов

Написать safe, adjoin-position и empty-board
Сначала мы получаем пустые вертикали (видимо).



#+BEGIN_SRC scheme
  ;; возвращает последовательность, которая отображает все варианты постановки ферзей
  ;; принимает число клеток доски по вертикали или горизонтали
  ;; т.е. если ввести 8, то мы получим доску 8х8
  (define (queens board-size)
    ;; возвращает последовательность, которая отображает все варианты
    ;; расстановки ферзей по вертикали
    (define (queen-cols k)
      (if (= k 0)
          ;; empty-board должна представлять пустое множество позиций
          ;; видимо, должна эмулировать пустую доску
          (list empty-board)
          (filter
           ;; предикат фильтра
           (lambda (positions)
             (format #t "lambda k ~A positions ~A\n" k positions)
             (safe? k positions))
           ;; это должно вернуть некую последовательность из всех
           ;; вариантов расстановки ферзей
           (flatmap
            ;; rest-of-queens - это последовательность (?)
            ;; способов расставить k - 1 ферзей на k-1 вертикалях
            (lambda (rest-of-queens)
              ;; new-row - горизонталь, на которую нужно поставить ферзя
              ;; с конкретной вертикали
              (map (lambda (new-row)
                     ;; adjoin-position добавляет нового ферзя на определенную клетку
                     (adjoin-position new-row k rest-of-queens))
                   ;; это список горизонталей
            (queen-cols (- k 1))))))
                   (enumerate-interval 1 board-size)))
    ;; первый вызов функции
    (queen-cols board-size))

  (define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        ;; empty-board должна представлять пустое множество позиций
        ;; видимо, должна эмулировать пустую доску
        (list empty-board)
         (flatmap
          ;; rest-of-queens - это последовательность (?)
          ;; способов расставить k - 1 ферзей на k-1 вертикалях
          (lambda (rest-of-queens)
            ;; new-row - горизонталь, на которую нужно поставить ферзя
            ;; с конкретной вертикали
            (map (lambda (new-row)
                   ;; adjoin-position добавляет нового ферзя на определенную клетку
                   (adjoin-position new-row k rest-of-queens))
                 ;; это список горизонталей
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1)))))
  (queen-cols board-size))

  (define (even? n)
    (= (remainder n 2) 0))

  (filter (lambda (pair)
            (format #t "~A\n" pair)
            (even? (+ (car pair) (cadr pair))))
            (list (list 2 3) (list 3 3) (list 5 3)))

  ;; предположим так мы ставим ферзя на заданную позицию
  (define (adjoin-position new-row k rest-of-queens)
    (cons new-row rest-of-queens))

  ;; у нее нет никаких аргументов. с чем она может работать?
  ;; предположим, что пустое множество - это nil
  (define empty-board
    (list))

  ;; как проверить, стоит ли ферзь в безопасности?
  (define (safe? k positions)
    (format #t "lambda k ~A positions ~A\n" k positions)
    (not (or (= k (car positions)) (= k (cdr positions)))))

 #+END_SRC

~Упражнение 2.44.~
Определите процедуру up-split, которую использует corner-split. Она подобна right-
split, но только меняет местами роли below и beside.

beside - получает на вход 2 процедуры отрисовки и порождает отрисовку, которая
рисует в правой половине листа рисунок первой отрисовки, а в левой - второй

below - получает на вход 2 процедуры отрисовки и порождает отрисовку, которая
рисует в верхней половине листа рисунок первой отрисовки, а в нижней - второй

#+BEGIN_SRC scheme
  ;; позволяет дробить рисунок вправо, т.е. левую половину листа будет занимать сам паттерн,
  ;; следующее изображение паттерна будет занимать правую верхнюю четверть листа, потом
  ;; половину от нижней четверти и т.д. пока лист не кончится
  (define (right-split painter n)
    (if (= n 0)
        painter
        (let ((smaller (right-split painter (- n 1))))
          (beside painter (below smaller smaller)))))

  (define (up-split (painter n))
    (if (= n 0)
        painter
        (let ((smaller (up-split painter (- n 1))))
          (below painter (beside smaller smaller)))))

  ;; порождает сбалансированные узоры, позволяя наращивать их вверх
  (define (corner-split painter n)
    (if (= n 0)
        painter
        (let ((up (up-split painter (- n 1)))
              (right (right-split painter (- n 1))))
          (let ((top-left (beside up up))
                (bottom-right (below right right))
                (corner (corner-split painter (- n 1))))
            (beside (below painter top-left)
                    (below bottom-right corner))))))

#+END_SRC

~Упражнение 2.45.~
Right-split и up-split можно выразить как разновидности общей операции разделения.
Определите процедуру split с таким свойством, что вычисление

(define right-split (split beside below))
(define up-split (split below beside))

порождает процедуры right-split и up-split с таким же поведением, как и определенные
ранее.

сплит - общая операция разделения. нам явно нужна рисовлка, которую мы будем делить и
указание, как мы ее будем делить
получает 2 аргумента на вход
должен быть рекурсивный проход
при этом right-split и up-split перестали получать на вход аргументы.
аргументы beside и below - это 2 рисовлки у каждой
значит, split должна породить другую процедуру, которая принимает на вход
рисовалку-паттерн и кол-во раз, которое скажет нам, сколько раз разделить картинку,
а затем отрисует наш паттерн так, как мы укажем на входе split

#+BEGIN_SRC scheme

  (define (split painter1 painter2)
      (define (split-iter patern-paiter n)
        (if (= n 0)
            patern-paiter
            (let ((smaller (split patern-paiter (- n 1))))
              (painter1 patern-paiter (painter2 smaller smaller))
              )))
      split-iter)

#+END_SRC

~Упражнение 2.46.~

Двумерный вектор v, идущий от начала координат к точке, можно представить в виде пары,
состоящей из x-координаты и y-координаты. Реализуйте абстракцию данных для векторов,
написав конструктор ~make-vect~ и соответствующие селекторы ~xcor-vect~ и ~ycor-vect~.
В терминах своих селекторов и конструктора реализуйте процедуры ~add-vect~, ~sub-vect~
и ~scale-vect~, которые выполняют операции сложения, вычитания векторов и умножения
вектора на скаляр.

#+BEGIN_SRC scheme
  (define (make-vect x y)
    (cons x y))

  (define (xcor-vect v)
    (car v))

  (define (ycor-vect v)
    (cdr v))

  (define (add-vect v1 v2)
    (make-vect (+ (xcor-vect v1) (xcor-vect v2))
               (+ (ycor-vect v1) (ycor-vect v2))))

  (define (sub-vect v1 v2)
    (make-vect (- (xcor-vect v1) (xcor-vect v2))
               (- (ycor-vect v1) (ycor-vect v2))))

  (define (scale-vect v scale)
    (make-vect (* scale (xcor-vect v))
               (* scale (ycor-vect v))))

  (define v1 (make-vect 3 7))
  (define v2 (make-vect 2 4))

  (ycor-vect v1)
  (xcor-vect v2)
  (add-vect v1 v2)
  (sub-vect v1 v2)
  (scale-vect v1 3)
#+END_SRC

~Упражнение 2.47.~
Вот два варианта конструкторов для рамок.
К каждому из этих конструкторов добавьте соответствующие селекторы, так, чтобы получить
реализацию рамок.

цитата из мана:
каким образом представляются рамки; нужно только сказать, что
есть конструктор make-frame, который принимает три вектора и выдает рамку, и что
есть еще три селектора, ~origin-frame~, ~edge1-frame~ и ~edge2-frame~

видимо, нужно написать такие селекторы, чтоб можно было получить из списка, который
представляет собой рамку, origin, edge1 и edge2

#+BEGIN_SRC scheme
  ;; вариант 1
  (define (make-frame origin edge1 edge2)
    (list origin edge1 edge2))

  (define (origin-frame frame)
    (car frame))

  (define (edge1-frame frame)
    (cadr frame))

  (define (edge2-frame frame)
    (cdr (cdr frame)))

  (define frame1 (make-frame (make-vect 0 3) (make-vect 1 8) (make-vect 2 6)))
  (origin-frame frame1)
  (edge1-frame frame1)
  (edge2-frame frame1)

  ;; вариант 2
  (define (make-frame origin edge1 edge2)
    (cons origin (cons edge1 edge2)))

  ;; первые два селектора идентичны у первого и второго вариантов
  (define (edge2-frame frame)
    (cadr (cdr frame)))
#+END_SRC

~Упражнение 2.48.~
Направленный отрезок на плоскости можно представить в виде пары векторов: вектор от
начала координат до начала отрезка и вектор от начала координат до конца отрезка.
Используйте свое представление векторов из упражнения 2.46 и определите
представление отрезков с конструктором ~make-segment~ и селекторами ~start-segment~ и
~end-segment~.

#+BEGIN_SRC scheme
  (define (make-segment v1 v2)
    (make-vect v1 v2))

  (define (start-segment segment)
    (xcor-vect segment))

  (define (end-segment segment)
    (ycor-vect segment))

  (define segment (make-segment (make-vect 3 4) (make-vect 8 10)))

  (start-segment segment)
  (end-segment segment)
#+END_SRC

~Упражнение 2.49.~
С помощью segments->painter определите следующие элементарные рисовалки:

а. Рисовалку, которая обводит указанную рамку.
б. Рисовалку, которая рисует «Х», соединяя противоположные концы рамки.
в. Рисовалку, которая рисует ромб, соединяя между собой середины сторон рамки.
г. Рисовалку wave.

Рисовалка "х":
чтоб соединить противоположные концы рамки, нужно получить вектор, параллельный вектору
edge2, так мы получим третью сторону рамки, от которой можно провести линию по
диагонали
edge3 - назовем новую сторону так, от edge2 будет отличаться только координатой икс:
игреки у них будут одинаковые. Коодината иксбудет совпадать с edge1
после того, как мы получим третью сторону, останется соединить координату вектор
третьей стороны и ветор orgigin, образовав отрезок таким образом, а затем вектор edge2
и edge1. Так полчится нарисовать "x".

Рисовалка "ромб":
для рисовалки нам понадобятся все 4 строны рамки. найдем середину у каждой стороны,
затем создадим отрезки и передадим в процеудуру

Рисовалка wave.
Из решения последуюих упражнений стало ясно, что нужно передавать функции отрисовки
коркнетные координаты (от 0 до 1), а не переменные.
#+BEGIN_SRC scheme
  ;; frame-coord-map к рамке дает нам процедуру, которая,
  ;; получая вектор, возвращает тоже вектор. Если вектор-аргумент находится в единичном
  ;; квадрате, вектор-результат окажется в рамке.

  ;; чтоб получить рамку, надо иметь 3 ветора и единичный квадрат - это такой квадрат,
  ;; где сторона x >= 0, а y <=1. затем по вот такой формуле преобразуем это  рамку
  ;; Origin(Frame) + x · Edge 1 (Frame) + y · Edge 2 (Frame)

  ;; draw-line рисует отрезок между двумя точками. т.е. надо сформировать координаты
  ;; отрезка (два вектора) и передать ей

  ;; все процедуры для операций над векторами и сегментами следует искать в двух
  ;; предыдущих упражнениях
  (define (frame-coord-map frame)
    (lambda (v)
      (add-vect
       (origin-frame frame)
       (add-vect (scale-vect (xcor-vect v)
                             (edge1-frame frame))
                 (scale-vect (ycor-vect v)
                             (edge2-frame frame))))))

  (define (segments->painter segment-list)
    (lambda (frame)
      ;; применяем процедуру к каждому сегменту
      (for-each
       (lambda (segment)
         (draw-line
          ((frame-coord-map frame) (start-segment segment))
          ((frame-coord-map frame) (end-segment segment))))
       segment-list)))

  (define (rhomb frame)
    (let* ((edge3 (make-vect (xcor-vect (edge1-frame frame))
                             (ycor-vect (edge2-frame frame))))
           (edge4 (xcor-vect edge3)
                  (ycor-vect (edge2-frame frame)))
           (origin-edge1-middle (make-vect (/ (xcor-vect (edge1-frame frame)) 2)
                                           (ycor-vect (edge1-frame frame))))
           (edge1-edge3-middle (make-vect (xcor-vect edge3)
                                          (/ (ycor-vect edge3) 2)))
           (edge2-edge3-middle (make-vect (/ (xcor-vect edge3) 2)
                                          (ycor-vect edge3)))
           (origin-edge2-middle (make-vect (xcor-vect (origin-frame frame)))
                                           (/ (ycor-vect (edge2-frame frame)) 2)))

           (segm-list (list (make-segment origin-edge1-middle
                                          edge1-edge3-middle)
                            (make-segment edge1-edge3-middle
                                          edge2-edge3-middle)
                            (make-segment edge2-edge3-middle
                                          origin-edge2-middle)
                            (make-segment origin-edge2-middle
                                          origin-edge1-middle)))
           ((segments->painter segm-list) frame)))

  (define (cross frame)
    (let* ((edge3 (make-vect (xcor-vect (edge1-frame frame))
                             (ycor-vect (edge2-frame frame))))
           (segm-list (list (make-segment edge3 (origin-frame frame))
                            (make-segment (edge2-frame frame) (edge1-frame frame)))))
      ((segments->painter segm-list) frame)))

  (define (draw-frame frame)
    (let* ((edge3 (make-vect (xcor-vect (edge1-frame frame))
                             (ycor-vect (edge2-frame frame))))
           (edge4 (xcor-vect (edge3-frame frame))
                  (ycor-vect (edge2-frame frame)))
           (segm-list (list (make-segment (edge1-frame frame) (origin-frame frame))
                            (make-segment (edge2-frame frame) (origin-frame frame))
                            (make-segment (edge2-frame frame) edge3)
                            (make-segment (edge1-frame frame) edge3)))
           ((segments->painter segm-list) frame))))

  ;; чтоб не генерировать каждый отрезок, создадим вспомогательные функции. Например,
  ;; функцию, генерирующую ломанную линию

  ;; это довольно тупое задание, суть которого - приблизительно прикинуть координаты отрезков. Доделаю его позже.

  (define (wave frame)
  (let* ((head (make-vector

#+END_SRC

~попытка написать растор~

#+BEGIN_SRC scheme
  (define in (open-input-file "in.txt"))

  (read-line in)

  ;; написатьв файл
  (define draw
  (call-with-output-file "in.txt"
    (lambda (p)
      (format p " I am\n"))))

  ;; прочитать из файла
  (call-with-input-file "in.txt"
    (lambda (p)
      (let f ((x (read p)))
        (if (eof-object? x)
            '()
                      (cons x (f (read p)))))))

#+END_SRC

~Упражнение 2.50.~
Определите преобразование flip-horiz, которое обращает изображение вокруг
горизонтальной оси, а также преобразования, которые вращают рисовалки против
часовой стрелки на 180 и 270 градусов.

#+BEGIN_SRC scheme
  (define (transform-painter painter origin corner1 corner2)
    (lambda (frame)
      (let ((m (frame-coord-map frame)))
        (let ((new-origin (m origin)))
          (painter
           (make-frame new-origin
                       (sub-vect (m corner1) new-origin)
                       (sub-vect (m corner2) new-origin)))))))

  (define (rotate90 painter)
    (transform-painter painter
                       (make-vect 1.0 0.0)
                       (make-vect 1.0 1.0)
                       (make-vect 0.0 0.0)))

  (define (rotate180 painter)
    (transform-painter painter
                       (make-vect 1.0 1.0)
                       (make-vect 0.0 1.0)
                       (make-vect 1.0 0.0)))

  (define (rotate270 painter)
    (transform-painter painter
                       (make-vect 0.0 1.0)
                       (make-vect 0.0 0.0)
                       (make-vect 1.0 1.0)))

  (define (flip-horiz painter)
    (transform-painter painter
                       (make-vect 1.0 0.0)
                       (make-vect 0.0 0.0)
                       (make-vect 1.0 1.0)))
#+END_SRC


~Упражнение 2.51.~
Определите для рисовалок операцию below. Below принимает в качестве аргументов две ри-
совалки. Когда получившейся рисовалке передается рамка, она рисует в нижней ее половине
при помощи первой рисовалки, а в верхней при помощи второй. Определите below двумя
способами — один раз аналогично процедуре beside, как она приведена выше, а второй раз
через beside и операции вращения (см. упражнение 2.50).

#+BEGIN_SRC scheme
  ;; beside из мана
  (define (beside painter1 painter2)
    (let ((split-point (make-vect 0.5 0.0)))
      (let ((paint-left
             (transform-painter painter1
                                (make-vect 0.0 0.0)
                                split-point
                                (make-vect 0.0 0.1)))
            (paint-right
             (transform-painter painter2
                                split-point
                                (make-vect 1.0 0.0)
                                (make-vect 0.5 1.0)))
            (lambda (frame)
              (paint-left frame)
              (paint-right frame))))))

  ;; вариант 1
  (define (below painter1 painter2)
    (let ((split-point (make-vect 0.0 0.5)))
      (let ((paint-down
             (transform-painter painter1
                                (make-vect 0.0 0.0)
                                (make-vect 1.0 0.0)
                                split-point))
            (paint-up
             (transform-painter painter2
                                split-point
                                (make-vect 1.0 0.5)
                                (make-vect 0.0 1.0)))
            (lambda (frame)
              (paint-down frame)
              (paint-up frame))))))

  (define (below painter1 painter2)
    (let* ((new-painter (beside (rotate270 painter1) (rotate270 painter2)))
           (below-painter (rotate90 new-painter)))
      (lambda (frame)
        (below-painter frame))))

#+END_SRC


~Упражнение 2.52.~
Измените предел квадрата рисовалки wave, показанный на рисунке 2.9, работая на каждом
из вышеописанных уровней. А именно:
а. Добавьте новые отрезки к элементарной рисовалке wave из упражнения 2.49 (например,
изобразив улыбку). (доделаю этот кусок, когда сделаю wave)
б. Измените шаблон, который порождает corner-split (например, используя только одну
копию образов up-split и right-split вместо двух).
в. Измените версию square-limit, использующую square-of-four, так, чтобы углы компо-
новались как-нибудь по-другому. (Например, можно сделать так, чтобы большой мистер
Роджерс выглядывал из каждого угла квадрата.)

#+BEGIN_SRC scheme
  ;; изначальный вариант
  ;; видимо цель не просто заполнить рамку изображениями, но и сделать
  ;; окаймовку изображением по краям рамки
  (define (corner-split painter n)
    (if (= n 0)
        painter
        ;; наращиваем изображение вверх
        (let ((up (up-split painter (- n 1)))
              ;; наращиваем изображение вправо
              (right (right-split painter (- n 1))))
          ;; наращиваем изображение влево
          (let ((top-left (beside up up))
                ;; наращиваем изображение вниз
                (bottom-right (below right right))
                ;; повторяем, пока не заполним всю рамку
                (corner (corner-split painter (- n 1))))
            (beside (below painter top-left)
                    (below bottom-right corner))))))

  ;; используем 1 копию образов вместо двух, как сказано в задании
  (define (corner-split painter n)
    (if (= n 0)
        painter
        (let ((up (up-split painter (- n 1)))
              (right (right-split painter (- n 1))))
          (let ((corner (corner-split painter (- n 1))))
            (beside (below painter up)
                    (below right corner))))))
  ;; задание "в"
  ;; изначальный вариант
  (define (square-of-four tl tr bl br)
    (lambda (painter)
      (let ((top (beside (tl painter) (tr painter)))
            (bottom (beside (bl painter) (br painter))))
        (below bottom top))))

  (define (square-limit painter n)
    (let ((combine4 (square-of-four flip-horiz identity
                                    rotate180 flip-vert)))
      (combine4 (corner-split painter n))))

  ;; мой вариант
  (define (square-limit painter n)
    (let ((combine4 (square-of-four flip-vert identity
                                    rotate180 flip-horiz)))
      (combine4 (corner-split painter n))))
#+END_SRC

~Упражнение 2.53.~
Что напечатает интерпретатор в ответ на каждое из следующих выражений?
#+BEGIN_SRC scheme
  (list 'a 'b 'c)
  = (a b c)

  (list (list 'george))
  = ((george))

  (cdr '((x1 x2) (y1 y2)))
  = ((y1 y2))

  (cadr '((x1 x2) (y1 y2)))
  =(y1 y2)

  (pair? (car '(a short list)))
  = #f

  (memq 'red '((red shoes) (blue socks)))
  = #f

  (memq 'red '(red shoes blue socks))
  =(red shoes blue socks)
#+END_SRC

~Упражнение 2.54.~
Предикат ~equal?~ для двух списков возвращает истину, если они содержат одни и те же
элементы в одинаковом порядке.
Например,
~(equal? '(this is a list) '(this is a list))~ истинно, но
~(equal? '(this is a list) '(this (is a) list))~ ложно.
Более точно, можно определить equal? рекурсивно в терминах базового равенства
символов eq?, сказав, что a равно b, если оба они символы и для них выполняется eq? либо
оба они списки и при этом верно, что (car a) равняется в смысле ~equal?~ (car b),
а (cdr a) равняется в смысле equal? (cdr b).
Пользуясь этой идеей, напишите ~equal?~ в виде процедуры.

- eq? берет 2 символа и проверяет, равны ли они (имеют один и тот же набор печатных
  знаков, которые стоят в одинаковом порядке)
- нужна рекурсия
- два списка равны если:
  символ "а" равен символу "б"
  либо они оба списки и при этом у них равны car-ы b cdr-ы
-
#+BEGIN_SRC scheme

  (define (equal? lst1 lst2)
    (cond ((and (not (pair? lst1)) (not (pair? lst2)) (eq? lst1 lst2)) #t)
          ((and (pair? lst1) (pair? lst1) (eq? (car lst1) (car lst2)))
           (equal? (cdr lst1) (cdr lst2)))
          (else #f)))

#+END_SRC

~Упражнение 2.55.~
Ева Лу Атор вводит при работе с интерпретатором выражение
~(car ''abracadabra)~
К ее удивлению, интерпретатор печатает quote. Объясните.

Ответ:
~quote~ предотвращает вычисление символа, следующего сразу за ней. Вторая ~'~ не дает
вычислиться ~abracadabra~, а стоящая перед ней первая ~quote~ не дает вычислиться
второй. Таким образом, последняя запятая попадает в список как символ, она не читается
интерпритатором как функция. Соответственно, ~сar~ полученного списка - это
невычисленная ~quote~.

~Упражнение 2.56.~
Покажите, как расширить простейшую программу дифференцирования так, чтобы она восприни-
мала больше разных типов выражений.
Добавьте еще одну проверку к программе ~deriv~ и определив соответствующие процедуры
exponentiation?, base, exponent и make-exponentiation (обозначать возведение в
степень можно символом **). Встройте правила, что любое выражение, возведенное в
степень 0, дает 1, а возведенное в степень 1 равно самому себе.

Полный код процедуры, представленный в мане:
#+BEGIN_SRC scheme
    (define (variable? x) (symbol? x))

    (define (same-variable? v1 v2)
      (and (variable? v1) (variable? v2) (eq? v1 v2)))

    (define (make-sum a1 a2) (list '+ a1 a2))

    (define (make-product m1 m2) (list '* m1 m2))

    (define (sum? x)
      (and (pair? x) (eq? (car x) '+)))

    (define (addend s) (cadr s))

    (define (augend s) (caddr s))

    (define (product? x)
      (and (pair? x) (eq? (car x) '*)))

    (define (multiplier p) (cadr p))

    (define (multiplicand p) (caddr p))

    (define (=number? exp num)
      (and (number? exp) (= exp num)))

    (define (make-sum a1 a2)
      (cond ((=number? a1 0) a2)
            ((=number? a2 0) a1)
            ((and (number? a1) (number? a2)) (+ a1 a2))
            (else (list '+ a1 a2))))

    (define (make-product m1 m2)
      (cond ((or (=number? m1 0) (=number? m2 0)) 0)
            ((=number? m1 1) m2)
            ((=number? m2 1) m1)
            ((and (number? m1) (number? m2)) (* m1 m2))
            (else (list '* m1 m2))))

    (define (deriv exp var)
      (cond ((number? exp) 0)
            ((variable? exp)
             (if (same-variable? exp var) 1 0))
            ((sum? exp)
             (make-sum (deriv (addend exp) var)
                       (deriv (augend exp) var)))
            ((product? exp)
             (make-sum
              (make-product (multiplier exp)
                            (deriv (multiplicand exp) var))
              (make-product (deriv (multiplier exp) var)
                            (multiplicand exp))))
            (else
             (error "неизвестный тип выражения -- DERIV" exp))))

#+END_SRC

Мои дополнения:

#+BEGIN_SRC scheme
  ;; функция проверяет, является ли данное выражение возведением в степень
  ;; действуем по аналогии с суммой и произведением:
  (define (exponentiation? expr)
    (and (pair? expr) (eq? (car expr) '**)))

  ;; получаем основание из возведения в степень
  (define (base expr)
    (and (pair? expr) (cadr expr)))

  ;; полуаем экспоненту из возведения в степень
  (define (exponent expr)
    (and (pair? expr) (caddr expr)))

  ;; создаем выражение, которое возводит в заданную степень заданное число
  (define (make-exponentiation base exp)
    (list '** base exp))

  (define test (make-exponentiation 8 2))

  ;; дополненный вариант процедуры
  ;; прочитай про производные
  (define (deriv exp var)
    (cond ((number? exp) 0)
          ((variable? exp)
           (if (same-variable? exp var) 1 0))
          ((sum? exp)
           (make-sum (deriv (addend exp) var)
                     (deriv (augend exp) var)))
          ((product? exp)
           (make-sum
            (make-product (multiplier exp)
                          (deriv (multiplicand exp) var))
            (make-product (deriv (multiplier exp) var)
                          (multiplicand exp))))
          ((exponentiation? exp)
           (make-sum
            (make-product (base exp)
                          (deriv (exponent exp) var))
            (make-product (deriv (exponent exp) var)
                          (base exp))))
          (else
           (error "неизвестный тип выражения -- DERIV" exp))))
#+END_SRC

~Упражнение 2.57.~
Расширьте программу дифференцирования так, чтобы она работала с суммами и
произведениями любого (больше двух) количества термов.
Тогда последний из приведенных выше примеров мог бы быть записан как
~(deriv '(* x y (+ x 3)) 'x)~
Попытайтесь сделать это, изменяя только представление сумм и произведений, не трогая
процедуру deriv. Тогда, например, процедура ~addend~ будет возвращать первое
слагаемое суммы, а ~augend~ сумму остальных.

#+BEGIN_SRC scheme
  ;; изначальный вариант
  (define (addend s) (cadr s))

  (define (augend s) (caddr s))

  (define (make-sum a1 a2)
    (list '+ a1 a2))

  ;; мой вариант
  ;; принимает неограниченное кол-во слагаемых
  (define (make-sum a1 . a2)
    (if (pair? a2)
        (append (list '+ a1) a2)
        (list '+ a1 a2)))

  ;; возвращает 1 слагаемое суммы
  (define (addend s) (cadr s))

  ;; возвращает сумму всех слагаемых кроме первого
  (define (augend s)
    (define (iter s)
      (if (null? s)
          0
          (+ (car s) (iter (cdr s)))))
    (iter (cddr s)))

  ;;тестовые примеры
  (define test (make-sum 1 2))

  (define test2 (make-sum 1 2 3 4))

#+END_SRC

~Упражнение 2.58.~
Предположим, что нам захотелось изменить программу дифференцирования так, чтобы она ра-
ботала с обычной математической нотацией, где + и * не префиксные, а инфиксные
операции.
Поскольку программа взятия производных определена в терминах абстрактных данных, мы
можем изменять представление выражений, с которыми она работает, меняя только предикаты,
селекторы и конструкторы, определяющие представление алгебраических выражений, с
которыми должен работать дифференциатор.
а. Покажите, как это сделать так, чтобы брать производные от выражений, представленных
в инфиксной форме, например (x + (3 * (x + (y + 2)))). Для упрощения задачи предполо-
жите, что + и * всегда принимают по два аргумента, и что в выражении расставлены все
скобки.
б. Задача становится существенно сложней, если мы разрешаем стандартную алгебраическую
нотацию, например (x + 3 * (x + y + 2)), которая опускает ненужные скобки и предпола-
гает, что умножение выполняется раньше, чем сложение. Можете ли Вы разработать
соответствующие предикаты, селекторы и конструкторы для этой нотации так, чтобы
наша программа взятия производных продолжала работать?

Вариант "а":
- раньше знаки умножения и сложения всегда стояли первым элементом списка, т.е.
(+ 1 2) или (* 1 (+ 2 8)) и т.д. А теперь они всегда будут стоять вторым элементом.
Таким образом надо только переделать конструкторы и селекторы, отвечающие за сложение и
умножение.
#+BEGIN_SRC scheme
  ;; инфиксная нотация
  (x + (3 * (x + (y + 2))))

  (define (make-sum a1 a2) (list a1 '+ a2))

  (define (make-product m1 m2) (list m1 '* m2))

  (define (sum? x)
    (and (pair? x) (eq? (cadr x) '+)))

  (define (addend s) (car s))

  (define (augend s) (caddr s))

  (define (product? x)
    (and (pair? x) (eq? (cadr x) '*)))

  (define (multiplier p) (car p))

  (define (multiplicand p) (caddr p))

  ;; тестовые примеры
  (define test (make-sum 2 4))

  (define test2 (make-product 3 5))

#+END_SRC

Вариант "б" с стандартной алгебраической нотацией
(это фактически инфиксная нотация, но без вспомогательных скобок. Тем не менее, знак
умножения или сложения окажется "между" своими аргументами, а не перед ними)

1. нужно разработать систему правил:
- внутрениие скобки решаются первыми, т.е. нужно дойти до самого глубокого уровня
  вложенности и начать от него
- установить приоритет операций: умножение и деление выполняются перывыми, сложение и
  вычитание - следом. Если у нас несколько операций умножения или сложения, то начинаем
  их применять слева направо
2. Для осуществления этой системы необходим проход по выражению. Необходима рекурсия.
Текущий элемент списка является парой?
Да!
- зайти внутрь подспика, вычислить его, вернуть значение вычисления, вернуться назад,
  если нет подсписка
Нет!
проверяем следующий элемент списка, пока они не кончатся

Фактически, нужно разработать экспертную систему
проблемы:
- пока не дошли до конца списка, ничего нельзя вычислить: мы не знаем, встретится ли нам
  приоритетная операция или уже можно вычислять, значит, придется проходить по
  выражению несколько раз (но можно сформировать новое, с уже вычисленными частями,
  использовать нехвостовую рекурсию)

#+BEGIN_SRC scheme
  ;; алгебраическая нотация
  (x + 3 * (x + y + 2))

  (define (make-sum a1 a2) (list a1 '+ a2))

  (define (make-product m1 m2) (list m1 '* m2))

  (define (sum? x)
    (and (pair? x) (eq? (cadr x) '+)))

  (define (addend s) (car s))

  (define (augend s) (caddr s))

  (define (product? x)
    (and (pair? x) (eq? (cadr x) '*)))

  (define (multiplier p) (car p))

  (define (multiplicand p) (caddr p))

  ;; тестовые примеры
  (define test (make-sum 2 4))

  (define test2 (make-product 3 5))

#+END_SRC

~Упражнение 2.59.~

Реализуйте операцию ~union-set~ для представления множеств в виде неупорядоченных
списков.
Union-set вычисляет объединение двух множеств, то есть множество, содержащее те
элементы, которые присутствуют хотя бы в одном из аргументов.

То есть два множества (1 2 3 4) и (4 5 6 2) соединятся в (1 2 3 4 5 6), видимо. Потому
что если бы была цель просто соединить два списка, подошла бы операция append. На это
так же указывает утверждение из мана, что "можно представить множество как список, в
котором ни один элемент не содержится более одного раза", таким образом множестве,
которое является результатом объединения, не должно содержаться повторяющихся
элементов.

- как проверить, встречался ли этот элемент?
использовать element-of-set?, который проверяет наличие элемента в множестве
добавить новый элемент можно с помощью adjoin-set

#+BEGIN_SRC scheme
  (define (element-of-set? x set)
    (cond ((null? set) #f)
          ((equal? x (car set)) #t)
          (else (element-of-set? x (cdr set)))))

  (define (adjoin-set x set)
    (if (element-of-set? x set)
        set
        (cons x set)))

  (define (union-set set1 set2)
    (define (iter set new-set)
      (if (null? set)
          new-set
          (iter (cdr set) (adjoin-set (car set) new-set))))
    ;; добавляем элементы из первого множества
    (let ((uni-set (iter set1 (list))))
      ;; добавляем элементы из второго моножества
      (iter set2 uni-set)))

  (union-set (list 1 2 3 4) (list 2 3 4 5 6 7))

  (union-set (list 11 2 32 4) (list 22 3 4 42 5 6 7))
#+END_SRC

~Упражнение 2.60.~
Мы указали, что множество представляется как список без повторяющихся элементов. Допу-
стим теперь, что мы разрешаем повторяющиеся элементы. Например, множество {1, 2, 3}
могло бы быть представлено как список (2 3 2 1 3 2 2).
Разработайте процедуры ~element-of-set?~, ~adjoin-set~, ~union-set~ и
~intersection-set~, которые бы работали с таким представлением.
Как соотносится эффективность этих операций с эффективностью соответствующих процедур
для представления без повторений?
Существуют ли приложения, в которых Вы бы использовали скорее
это представление, чем представление без повторений?

Первый вывод: старое представление операций работает корректно на новом представлении
множеств.
Второй вывод: некоторые операции определить теперь проще, раз не надо проверять, был
элемент в множестве или нет. Так, например, для написания ~adjoin-set~ и ~union-set~
теперь не требуется проходить по всем множествам-аргументам, поскольку нет больше
проверки элементов на повторение. Соответственно, мы можем просто присоединить
необходимые элементы, что эффективнее и проще с точки зрения расходования ресурсов.
Но ~element-of-set?~ и ~intersection-set~ переписать невозможно, в результате с
повторяющимися элементами их сложность возрастает линейно.


#+BEGIN_SRC scheme
  ;; проверяет, есть ли элемент в множестве
  (define (element-of-set? x set)
    (cond ((null? set) #f)
          ((equal? x (car set)) #t)
          (else (element-of-set? x (cdr set)))))

  ;; добавляет новый элемент в множество, если множество не содержит такой же
  (define (adjoin-set x set)
    (if (element-of-set? x set)
        set
        (cons x set)))

  ;;объяединяет неповторяющиеся элементы 2х множеств в одно
  (define (union-set set1 set2)
    (define (iter set new-set)
      (if (null? set)
          new-set
          (iter (cdr set) (adjoin-set (car set) new-set))))
    ;; добавляем элементы из первого множества
    (let ((uni-set (iter set1 (list))))
      ;; добавляем элементы из второго моножества
      (iter set2 uni-set)))

  ;;возвращает элементы, которые присуствуют в обоих множествах
  (define (intersection-set set1 set2)
    (cond ((or (null? set1) (null? set2)) '())
          ((element-of-set? (car set1) set2)
           (cons (car set1)
                 (intersection-set (cdr set1) set2)))
          (else (intersection-set (cdr set1) set2))))

  ;; новый вариант функций:
  (define (union-set set1 set2)
    (append set1 set2))

  (define (adjoin-set x set)
    (cons x set))

#+END_SRC

~Упражнение 2.61.~
Напишите реализацию ~adjoin-set~ для упорядоченного представления множеств.
По аналогии с ~element-of-set?~ покажите, как использовать упорядочение, чтобы
получить процедуру, которая в среднем требует только половину числа шагов,
которое требуется при неупорядоченном представлении.

Упорядоченные множества позволяют реализовать зачатки бинарного поиска.
~adjoin-set~ построено на ~element-of-set~, которое теперь использует в среднем
в половину меньше шагов. Соответственно, ~adjoin-set~ теперь тоже использует в
полоивну меньше шагов даже при том, что я ничего в нем не изменила.

Но есть и второй вариант, реализованный "с нуля".
#+BEGIN_SRC scheme
  ;; усовершенствованный вариант процедуры для упорядоченных множеств
  (define (element-of-set? x set)
    (cond ((null? set) #f)
          ((= x (car set)) #t)
          ((< x (car set)) #f)
          (else (element-of-set? x (cdr set)))))

  (define (adjoin-set x set)
    (if (element-of-set? x set)
        set
        (cons x set)))

  ;; второй вариант
  (define (adjoin-set x set)
    (cond ((or (null? set) (> x (car set))) (cons x set))
          ((= x (car set)) set)
          (else (adjoin-set x (cdr set)))))

  (define test (list 1 2 3 4 5 6 7 8))
#+END_SRC

~Упражнение 2.62.~
Дайте представление порядка Θ(n) для операции ~union-set~ с представлением в виде
упорядоченных списков.

В переводе на человеческий язык, от меня требуется реализация ~union-set~ для
упорядоченных списков, который будет расти линейно.

Внимание: в качестве аргументов моено передавать только упорядоченные списки, причем
упорядочены они должны быть "в одну сторону", т.е. в обоих числа должны располагаться от
меньшего к большему или от большего к меньшему, в противном случае новый список будет
неупорядоченным и может содержать повторяющиеся элементы.

#+BEGIN_SRC scheme
  (define (union-set set1 set2)
    (cond ((and (null? set1) (null? set2)) '())
          ((null? set1) set2)
          ((null? set2) set1)
          (else
           (let ((x1 (car set1)) (x2 (car set2)))
             (cond ((= x1 x2)
                    (cons x1 (union-set (cdr set1) (cdr set2))))
                   ((< x1 x2)
                    (cons x1 (union-set (cdr set1) set2)))
                   (else
                    (cons x2 (union-set set1 (cdr set2)))))))))

  (define set1 (list 2 8 9 13))

  (define set2 (list 1 5 8 10))
#+END_SRC

~Упражнение 2.63.~
Каждая из следующих двух процедур (~tree->list-1~ и ~tree->list-2~) преобразует
дерево в список.
#+BEGIN_SRC scheme
  (define (entry tree) (car tree))

  (define (left-branch tree) (cadr tree))

  (define (right-branch tree) (caddr tree))

  (define (make-node entry left right)
    (list entry left right))

  (define (element-of-set? x set)
    (cond ((null? set) #f)
          ((= x (entry set)) #t)
          ((< x (entry set))
           (element-of-set? x (left-branch set)))
          ((> x (entry set))
           (element-of-set? x (right-branch set)))))

  (define (adjoin-set x set)
    (cond ((null? set) (make-node x '() '()))
          ((= x (entry set)) set)
          ((< x (entry set))
           (make-node (entry set)
                      (adjoin-set x (left-branch set))
                      (right-branch set)))
          ((> x (entry set))
           (make-node (entry set)
                      (left-branch set)
                      (adjoin-set x (right-branch set))))))

  (define (tree->list-1 tree)
    (if (null? tree)
        '()
         (append (tree->list-1 (left-branch tree))
                 (cons (entry tree)
                       (tree->list-1 (right-branch tree))))))

  (define (tree->list-2 tree)
    (define (copy-to-list tree result-list)
      (if (null? tree)
          result-list
          (copy-to-list (left-branch tree)
                        (cons (entry tree)
                              (copy-to-list (right-branch tree)
                                            result-list)))))
    (copy-to-list tree '()))


  (define test-tree (list->tree (list 1 2 3 4 5 6 7)))
  (define test-tree2 (list->tree (list 1 3 5 7 9 11)))
  (define test-tree3 (list->tree (list 1 7 5 3 11 9)))


  (define (list->tree elements)
    (car (partial-tree elements (length elements))))

  (define (partial-tree elts n)
    (if (= n 0)
        (cons '() elts)
        (let ((left-size (quotient (- n 1) 2)))
          (let ((left-result (partial-tree elts left-size)))
            (let ((left-tree (car left-result))
                  (non-left-elts (cdr left-result))
                  (right-size (- n (+ left-size 1))))
              (let ((this-entry (car non-left-elts))
                    (right-result (partial-tree (cdr non-left-elts)
                                                right-size)))
                (let ((right-tree (car right-result))
                      (remaining-elts (cdr right-result)))
                  (cons (make-node this-entry left-tree right-tree)
                        remaining-elts))))))))
#+END_SRC

а. Для всякого ли дерева эти процедуры дают одинаковый результат? Если нет, то как их
результаты различаются? Какой результат дают эти две процедуры для деревьев с рисунка
2.16?

б. Одинаков ли порядок роста этих процедур по отношению к числу шагов, требуемых для
преобразования сбалансированного дерева с n элементами в список? Если нет, которая из
них растет медленнее?

Добавлены вспомогательный функции из мана. Оригинальная ~make-tree~ переименована
в ~make-node~, поскольку это лучше отражает ее суть.
Для построения дерева из списка использована ~list->tree~, представленная в следующем
упражнении.

Для множества {1, 3, 5, 7, 9, 11}, представленного бинарными диревьямис рисунка 2.16 не
найдено различий пи использовании ~tree->list-1~ и ~tree->list-2~ (для ~test-tree~
тоже).

~tree->list-1~ представляет собой нехвостовую рекурсию. То есть по достижению дна
рекурсии м еще будем вынуждены откатываться назад по стеку. Хранение всех переменных на
каждом вызове рекурсии требует памяти, чем больше элементов дерева, тем больше вызовов
рекурсии, тем больше памяти.

~tree->list-2~ представляет собой хвостовую рекурсию, то есть не производить никаких
вычислений по достижению дна рекурсии, а возвращает конечный результат. Это не требует
хранения всех переменных на каждомй итерации рекурсии, соответственно, меньше
расходуется ресурсов. Я думаю, что эта функция будет расти медленнее.

~Упражнение 2.64~
Следующая процедура ~list->tree~ преобразует упорядоченный список в сбалансированное би-
нарное дерево. Вспомогательная процедура ~partial-tree~ принимает в качестве аргументов
целое число n и список по крайней мере из n элементов, и строит сбалансированное дерево
из первых n элементов дерева.
Результат, который возвращает ~partial-tree~, — это пара (построенная
через cons), car которой есть построенное дерево, а cdr — список элементов,
не включенных в дерево.

а. Дайте краткое описание, как можно более ясно объясняющее работу ~partial-tree~.
Нарисуйте дерево, которое ~partial-tree~ строит из списка (1 3 5 7 9 11).

б. Каков порядок роста по отношению к числу шагов, которые требуются процедуре
~list->tree~ для преобразования дерева из n элементов?

#+BEGIN_SRC scheme
  (define (entry tree) (car tree))

  (define (left-branch tree) (cadr tree))

  (define (right-branch tree) (caddr tree))

  (define (make-node entry left right)
    (list entry left right))

  ;; возвращает car от результата partial-tree, который является динарным деревом
  (define (list->tree elements)
    (car (partial-tree elements (length elements))))


  (define (partial-tree elts n)
    ;; если элементы кончились
    (if (= n 0)
        (cons '() elts)
        ;; возвращает разность от деления
        ;; предполагаемый размер левой ветки
        (let ((left-size (quotient (- n 1) 2)))
          ;; строим левую ветку
          (let ((left-result (partial-tree elts left-size)))
            ;; получаем элементы для левой ветки
            (let ((left-tree (car left-result))
                  ;; получаем элементы, которые в левую ветку не вошли
                  (non-left-elts (cdr left-result))
                  ;; получаемразмер правой ветки
                  (right-size (- n (+ left-size 1))))
              ;; получаем первый элемент из элементов, не вошедших в левую ветку
              (let ((this-entry (car non-left-elts))
                    ;; строим правую ветку
                    (right-result (partial-tree (cdr non-left-elts)
                                                right-size)))
                ;; получаем правую ветку
                (let ((right-tree (car right-result))
                      ;; получаем элементы, не вошедшие в правую ветку
                      (remaining-elts (cdr right-result)))
                  ;; соединяем все в дерево и присоединяем элменты, не вошедшие в ветку
                  (cons (make-node this-entry left-tree right-tree)
                        remaining-elts))))))))
#+END_SRC

Итак, процедура ~partial-tree~ возвращает конс-пару, где car - это построенное дерево,
а cdr - элементы, не вошедшие в него.
~partial-tree~ принимает в качестве аргумента список элементов и длину списка. Все
вместе это позволяет создать отдельно левую и правые ветки, а затем соединить их от
корня: делим исходное кол-во элементов примерно поровну, помещаем первую половину
элементов в левую ветку, а оставшиеся - в правую.

Я думаю, что данная процедура имеет порядок роста O(n), поскольку нам необходимо
обработать кажды элемент списка по одному разу, сколько бы их ни было.

~Упражнение 2.65.~
Используя результаты упражнений 2.63 и 2.64, постройте реализации ~union-set~ и
~intersection-set~ порядка Θ(n) для множеств, реализованных как (сбалансированные)
бинарные деревья.

Для ~union-set~ нам требуется проверять, не повторяются ли элементы в деревьях
и создать новое дерево на основе 2х предыдущих. Сначала получим список элементов после
обхода обоих деревьев, а затем создадим дерево из этого списка.


#+BEGIN_SRC scheme

  (define (tree->list tree)
    (define (copy-to-list tree result-list)
      (if (null? tree)
          result-list
          (copy-to-list (left-branch tree)
                        (cons (entry tree)
                              (copy-to-list (right-branch tree)
                                            result-list)))))
    (copy-to-list tree '()))

  (define (union-tree tree1 tree2)
    (define (union-set set1 set2)
      (cond ((and (null? set1) (null? set2)) '())
            ((null? set1) set2)
            ((null? set2) set1)
            (else
             (let ((x1 (car set1)) (x2 (car set2)))
               (cond ((= x1 x2)
                      (cons x1 (union-set (cdr set1) (cdr set2))))
                     ((< x1 x2)
                      (cons x1 (union-set (cdr set1) set2)))
                     (else
                      (cons x2 (union-set set1 (cdr set2)))))))))
    (let* ((tree1-list (tree->list tree1))
           (tree2-list (tree->list tree2))
           (new-list (union-set tree1-list tree2-list)))
      (list->tree new-list)))

  (define (intersection-tree tree1 tree2)
    (define (element-of-set? x set)
      (cond ((null? set) #f)
            ((= x (car set)) #t)
            ((< x (car set)) #f)
            (else (element-of-set? x (cdr set)))))
    (define (intersection-set set1 set2)
      (cond ((or (null? set1) (null? set2)) '())
            ((element-of-set? (car set1) set2)
             (cons (car set1)
                   (intersection-set (cdr set1) set2)))
            (else (intersection-set (cdr set1) set2))))
    (let* ((tree1-list (tree->list tree1))
           (tree2-list (tree->list tree2))
           (new-list (intersection-set tree1-list tree2-list)))
      (list->tree new-list)))


  (define test-tree1 (list->tree (list 8 9 10 11 17 19)))
  (define test-tree2 (list->tree (list 1 3 5 7 9 11)))
#+END_SRC

Для написания ~union-tree~ я воспользовалась ~tree->list-2~ (поскольку она
использует звостовую рекурсию) из упр. 2.63, чтоб сформировать списки из деревьев,
но переименовала в ~tree->list~ для ясности. Затем уже написанную версию
~union-set~ для объединения 2х множеств, получила новый список и из него составила
новое дерево.

В ~intersection-tree~ логика аналогичная, только к тому же использована версия
~element-of-set?~ для упорядоченных списков, а не бинарных деревьев.

~Упражнение 2.66.~
Реализуйте процедуру ~lookup~ для случая, когда множество записей организовано в виде
бинарного дерева, отсортированного по числовым значениям ключей.

При написании воспользовалась логикой ~element-of-set?~ для упорядоченных списков.
Клчи в базе данных должны возрастать от меньшего к большему, а не наоборот.
Здесь присутствует процедура ~key~, код которой отсуствует в мане.

#+BEGIN_SRC scheme
  (define (lookup given-key set-of-records)
    (cond ((or (null? set-of-records)
               (<  given-key (key (car set-of-records)))) #f)
          ((equal? given-key (key (car set-of-records)))
           (car set-of-records))
          (else (lookup given-key (cdr set-of-records)))))
#+END_SRC


~Упражнение 2.67.~
Пусть нам даны дерево кодирования и пример сообщения.
Раскодируйте сообщение при помощи процедуры decode.

#+BEGIN_SRC scheme
  (define sample-tree
    (make-code-tree (make-leaf 'A 4)
                    (make-code-tree
                     (make-leaf 'B 2)
                     (make-code-tree (make-leaf 'D 1)
                                     (make-leaf 'C 1)))))

  (define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
#+END_SRC

Все процедуры из мана, касающиеся деревьев Хаффмана:

#+BEGIN_SRC scheme
    ;; создает лист,который содержитв  себе символ и частоту его употребления
    (define (make-leaf symbol weight)
      (list 'leaf symbol weight))

    (define (leaf? object)
      (eq? (car object) 'leaf))

    (define (symbol-leaf x) (cadr x))

    (define (weight-leaf x) (caddr x))

    (define (make-code-tree left right)
      (list left
            right
            (append (symbols left) (symbols right))
            (+ (weight left) (weight right))))

    (define (left-branch tree) (car tree))

    (define (right-branch tree) (cadr tree))

    (define (symbols tree)
      (if (leaf? tree)
          (list (symbol-leaf tree))
          (caddr tree)))

    (define (weight tree)
      (if (leaf? tree)
          (weight-leaf tree)
          (cadddr tree)))

    (define (choose-branch bit branch)
      (cond ((= bit 0) (left-branch branch))
            ((= bit 1) (right-branch branch))
            (else (error "плохой бит -- CHOOSE-BRANCH" bit))))

    (define (decode bits tree)
      (define (decode-1 bits current-branch)
        (if (null? bits)
            '()
             (let ((next-branch
                    (choose-branch (car bits) current-branch)))
               (if (leaf? next-branch)
                   (cons (symbol-leaf next-branch)
                         (decode-1 (cdr bits) tree))
                   (decode-1 (cdr bits) next-branch)))))
      (decode-1 bits tree))
#+END_SRC

Ответ:
(A D A B B C A)


~Упражнение 2.68.~
Процедура ~encode~ получает в качестве аргументов сообщение и дерево, и порождает список
битов, который представляет закодированное сообщение.

~encode-symbol~ — процедура, которую Вы должны написать, возвращает список битов, кото-
рый кодирует данный символ в соответствии с заданным деревом. Вы должны спроектировать
encode-symbol так, чтобы она сообщала об ошибке, если символ вообще не содержится в
дереве.
Проверьте свою процедуру, закодировав тот результат, который Вы получили в упражнении
2.67, с деревом-примером и проверив, совпадает ли то, что получаете Вы,
с исходным сообщением.

Итак, это обратная операция по отношению к ~decode~: имея дерево и сообщения, мне нужно
закодировать сообщение в биты.
Есть неявное присовение кодов буквам, т.е. у нас нет хэш-таблицы, например, где было бы
сказано, что код А - это 0, B- это 100 и т.д. Но это следует из построения самого
дерева и выбора пути. Если дерево из предыдущего упражнения будет переопределено другим
образом, то сообщение изменится, поскольку код буквы определяется по достижению листа,
где лежит эта буква. Например, чтоб достичь "B" ~decode~ должена "повернуть" один раз
направо и 2 раза налево, поскольку встреченный бит 1 означает выбор правой ветки, а 0 -
выбор левой ветки.

Следовательно, чтоб закодировать букву в в биты, нам нужно запомнить, куда мы
поворачивали, пока искали ту саму букву. Буква - это символ, для определения
соответствия между данной и искомой буквы будем пользоваться ~equal?~. Если достигли
нужную букву, возвращаем список "поворотов" в виде битов.

Сообщение об ошибке - это если мы достигли листа, но не нашли там искомую букву -
возвращаем false

#+BEGIN_SRC scheme

(define (elements-of-set? symbol set)
    (cond ((null? set) #f)
          ((equal? (car set) symbol) #t)
          (else (elements-of-set? symbol (cdr set)))))

  (define (encode-symbol letter tree)
    (define (test letter tree)
      (cond ((and (leaf? tree) (equal? (symbol-leaf tree) letter)) '())
            ((elements-of-set? letter (symbols (left-branch tree)))
             (cons 0 (test letter (left-branch tree))))
            ((elements-of-set? letter (symbols (right-branch tree)))
             (cons 1 (test letter (right-branch tree))))
            (else #f)))
    (test letter tree))

  (define (encode message tree)
    (if (null? message)
        '()
         (append (encode-symbol (car message) tree)
                 (encode (cdr message) tree))))

#+END_SRC

~Упражнение 2.69.~
Следующая процедура берет в качестве аргумента список пар вида символ-частота (где ни
один символ не встречается более, чем в одной паре) и порождает дерево кодирования по
Хаффману в соответствии с алгоритмом Хаффмана.

#+BEGIN_SRC scheme

  (define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))

#+END_SRC

Приведенная выше процедура ~make-leaf-set~ преобразует список пар в упорядоченное множе-
ство пар. Вам нужно написать процедуру ~successive-merge~, которая при помощи
~make-code-tree~ сливает наиболее легкие элементы множества, пока не останется только
один элемент, который и представляет собой требуемое дерево Хаффмана.
(Эта процедура устроена немного хитро, но она не такая уж сложная. Если Вы видите,
что строите сложную процедуру, значит, почти наверняка Вы делаете что-то не то.
Можно извлечь немалое преимущество из того, что мы используем упорядоченное
представление для множеств.)

Видимо, упорядоченное множество пар - это пары, отсортирортированные от реже
встречающихся букв до чаще встречающихся. То есть дерево нужно построить не от корня, а
от листьев.

Поправка к заданию: это не просто пары, а "листья", сконструированные с помощью
~make-leaf~ , в противном случае процедуры ~symbols~ и ~weight~ внутри
~make-code-tree~ выдают ошибки, поскольку на вход лолжны получать списки вида
~(leaf A 4)~, а не ~(A 4)~ или ~(A . 4)~.


#+BEGIN_SRC scheme

  (define set (list (make-leaf 'D 1) (make-leaf 'C 1) (make-leaf 'B 2) (make-leaf 'A 4)))

  (define set2
    (list (make-leaf 'D 1) (make-leaf 'C 1) (make-leaf 'B 2) (make-leaf 'A 4)
          (make-leaf 'F 4) (make-leaf 'G 4)))


  (define (successive-merge set)
    (define (iter set tree)
      (cond ((null? set) tree)
            ((null? tree) (iter (cddr set) (make-code-tree (car set) (cadr set))))
            (else (iter (cdr set) (make-code-tree (car set) tree)))))
    (iter set '()))

#+END_SRC

~Упражнение 2.70.~
Нижеприведенный алфавит из восьми символов с соответствующими им относительными часто-
тами был разработан, чтобы эффективно кодировать слова рок-песен 1950-х
годов. (Обратите внимание, что «символы» «алфавита» не обязаны быть отдельными
буквами.)
A     2
BOOM  1
GET   2
JOB   2

NA    16
SHA   3
YIP   9
WAH   1

При помощи ~generate-huffman-tree~ (упр. 2.69) породите соответствующее дерево Хаффмана,
и с помощью encode закодируйте следующее сообщение:
Get a job
Sha na na na na na na na na
Get a job
Sha na na na na na na na na
Wah yip yip yip yip yip yip yip yip yip
Sha boom
Сколько битов потребовалось для кодирования? Каково наименьшее число битов, которое
потребовалось бы для кодирования этой песни, если использовать код с
фиксированной длиной для алфавита из восьми символов?

Придется написать ~make-leaf-set~ самой.
#+BEGIN_SRC scheme
  ;; получает на вход пару и множество, из которого ее надо удалить
  ;; если данной пары нет в множестве, возвращается исходное множество
  ;; в противном случае возвращается список без указанной пары
  (define (remove-elem pair set)
    (define (iter set list)
      (cond ((null? set) list)
            ((equal? (car pair) (car (car set))) (iter (cdr set) list))
            (else (iter (cdr set) (cons (car set) list)))))
    (iter set '()))

  ;; превращает список пар в список листьев, где каждый подсписок иммет вид
  ;; (leaf D 3)
  (define (list->list-of-leafs list)
    (define (iter list list-leafs)
    (if (null? list)
        list-leafs
        (iter (cdr list) (cons (make-leaf (car (car list))
                                          (cadr (car list)))
                               list-leafs))))
    (iter list '()))

  ;; принимает на вход неупорядоченный список,
  ;; возвращает успорядочееный список листьев по принципу от меньшего к большему
  (define (make-leaf-set pairs)
    (define (iter elem pairs list)
      ;; если список кончился, присоединяем оставшийся элемент к новому списку
      (cond ((null? pairs) (cons elem list))
            ;; если cdr первой пары списка <= cdr текущего элемента
            ((<= (cadr (car pairs)) (cadr elem))
             ;; заменяем текущий элемент первой парой списка
             (iter (car pairs) (cdr pairs) list))
            ;; иначе сравниваем текущий элемент со следующей парой
            (else (iter elem (cdr pairs) list))))
    (define (make-ordered-set set leaf-set)
      (if (null? set)
          leaf-set
          (let* ((new-list (iter (car set) set leaf-set))
                 (newest-leaf (car new-list)))
            (make-ordered-set (remove-elem newest-leaf set) new-list))))
    (list->list-of-leafs (make-ordered-set pairs '())))

  ;; тестовый пример
  (define test (list '(F 3) '(G 2) '(D 4) '(S 1)))

  ;; запуск
  (make-leaf-set test2)
#+END_SRC

Теперь можно и к самому заданию приступить.
#+BEGIN_SRC scheme
  (define (generate-huffman-tree pairs)
    (successive-merge (make-leaf-set pairs)))

  (define (successive-merge set)
    (define (iter set tree)
      (cond ((null? set) tree)
            ((null? tree) (iter (cddr set) (make-code-tree (car set) (cadr set))))
            (else (iter (cdr set) (make-code-tree (car set) tree)))))
    (iter set '()))

  (define alphabet  (list '(a 2) '(boom 1) '(Get 2) '(job 2)
                          '(na 16) '(Sha 3) '(yip 9) '(Wah 1)))

  (define message '(Get a job
                        Sha na na na na na na na na
                        Get a job
                        Sha na na na na na na na na
                        Wah yip yip yip yip yip yip yip yip yip
                        Sha boom))

  (define (make-message alphabet message)
    (let ((tree (generate-huffman-tree alphabet)))
      (encode message tree)))

#+END_SRC

Ответ: 87 битов потребовалось, чтоб закодировать сообщение.
'(1 1 1 0 1 1 1 1 0 1 1 1 1 1 0 1 1 0 0 0 0 0 0 0 0 0 1 1 1 0 1 1 1 1 0 1
 1 1 1 1 0 1 1 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
 0 1 0 1 0 1 1 0 1 1 1 1 1 1 1)

Так выглядит кодирование каждой "буквы" алфавита. В среднем каждой букве
нужно по 4 бита. Таким образом, если бы все коды имели фиксированную
длину в 4 бита, то ничего бы не изменилось. В закодированном сообщении
все так же было бы 87 символов.
job:
(1 1 1 1 1 0)
Wah:
(1 1 1 1 1 1 0)
yip:
(1 0)
Sha:
(1 1 0)
Get:
(1 1 1 0)
na:
(0)
a:
(1 1 1 1 0)

~Упражнение 2.71.~
Допустим, у нас есть дерево Хаффмана для алфавита из n символов, и
относительные частоты символов равны 1, 2, 4, . . . , 2^n−1 .
Изобразите дерево для n = 5; для n = 10. Сколько битов в таком
дереве (для произвольного n) требуется, чтобы закодировать самый частый
символ? Самый редкий символ?

Значит, если у нас 5 символов, наприммер, А B C D E, то A будет иметь относительную
частоту 1, B - 2, C - 4, D - 8, E - 16. Если символов 10, то 10ый символ
будет иметь относительную частоту 512, поскольку это 2^9.

В обоих деревьях понадобится всегда 1 бит для кодирования наиболее часто
встречающегося символа, поскольку такой символ будет в самом верху
дерева. А чтоб достичь самого редкого символа понадобится n-1 шагов.

~Упражнение 2.72.~
Рассмотрим процедуру кодирования, которую Вы разработали в упражнении
2.68. Каков порядок роста в терминах количества шагов,
необходимых для кодирования символа?
Не забудьте включить число шагов, требуемых для поиска символа в каждой следующей
вершине. Ответить на этот вопрос в общем случае сложно. Рассмотрите
особый случай, когда относительные частоты символов таковы, как описано в
упражнении 2.71, и найдите порядок роста (как функцию от n) числа шагов,
необходимых, чтобы закодировать самый частый и самый редкий символ алфавита.

Процедура в упражнении 2.68 работает следующим образом: с помощью
субпроцедуры ~symbols~ собираем с левой ветки символы и проверяем, есть
ли там наш, потом то же самое проделываем с правой веткой. В какой ветке
символ обнаружился, туда и сворачиваем. И продолжаем так, пока не найдем
символ.  Вопрос, что считать одним шагом?
Предположим, что на одну итерацию рекурсии приходится в худшем случае 5
операций: сбор символов с одной ветки, проверка, если символ в наборе
символов, то же саоме проделываем в другой веткой, и переход на новый
уровень рекурсии. В упражнении 2.71 мы выяснили, что достижение самого
редкого символа обходится в n-1 вызовов рекурсии. Значит, чтоб обозначить
кол-во шагов для поиска символа в самом худшем случае, нужно умножить
кол-во операций на каждом шаге рекурсии (в нашем случае это 5) на n-1,
где n - это кол-во элементов в дереве. В O-нотации это будет выглядеть
примерно так: О(n-1 * 5).

~Упражнение 2.73.~
В разделе 2.3.2 описывается программа, которая осуществляет символьное
дифференцирование:

#+BEGIN_SRC scheme
  (define (deriv exp var)
    (cond ((number? exp) 0)
          ((variable? exp) (if (same-variable? exp var) 1 0))
          ((sum? exp)
           (make-sum (deriv (addend exp) var)
                     (deriv (augend exp) var)))
          ((product? exp)
           (make-sum
            (make-product (multiplier exp)
                          (deriv (multiplicand exp) var))
            (make-product (deriv (multiplier exp) var)
                          (multiplicand exp))))
          ;;Здесь можно добавить еще правила
          (else (error "неизвестный тип выражения -- DERIV" exp))))
#+END_SRC

Можно считать, что эта программа осуществляет диспетчеризацию по типу
выражения, которое требуется продифференцировать. В этом случае «меткой типа» элемента
данных является символ алгебраической операции (например, +), а операция, которую нужно
применить – deriv. Эту программу можно преобразовать в управляемый
данными стиль,  если переписать основную процедуру взятия производной в
виде

#+BEGIN_SRC scheme
  (define (deriv exp var)
    (cond ((number? exp) 0)
          ((variable? exp) (if (same-variable? exp var) 1 0))
          (else ((get 'deriv (operator exp)) (operands exp)
                 var))))

  (define (operator exp) (car exp))

  (define (operands exp) (cdr exp))
#+END_SRC

а. Объясните, что происходит в приведенном фрагменте кода. Почему нельзя
включить в операцию выбора, управляемого данными, предикаты ~number?~ и ~variable?~?
б. Напишите процедуры для вычисления производных от суммы и произведения,
а также дополнительный код, чтобы добавить их к таблице, которой пользуется
приведенный фрагмент.
в. Выберите еще какое-нибудь правило дифференцирования, например для
возведения в степень (упражнение 2.56), и установите его в систему.
г. В этой простой алгебраической системе тип выражения — это
алгебраическая операция верхнего уровня. Допустим, однако, что мы индексируем процедуры
противоположным образом, так что строка диспетчеризации в ~deriv~ выглядит как
~((get (operator exp) 'deriv) (operands exp) var)~
Какие изменения потребуются в системе дифференцирования?

Ответы:
а) Если выражение - это число, возвращаем 0. Если выражение - это
переменная, причем там же самая, что и ~var~, то возвращаем 1, иначе 0.Ну
и если это ни то, ни другое, то мы получаем из таблицы с помощью
процедуры ~get~ содержимое ячейки, чей индекс - это ~deriv~, а тип - это
car выражения. Содержимому ячейки передается cdr выражения и
переменная. Предикаты ~number?~ и ~variable?~ работают с разными
представлениями данных, но не содержат в себе процедуру, по которой можно
произвести диспетчеризацию. Их включение в процедуру выбора просто не
имеет смысла.
б)
#+BEGIN_SRC scheme
  (define (deriv exp var)
    (cond ((number? exp) 0)
          ((variable? exp) (if (same-variable? exp var) 1 0))
          (else ((get 'deriv (operator exp)) (operands exp)
                 var))))

  (define (operator exp) (car exp))

  (define (operands exp) (cdr exp))

  (define (sum-product-package exp var)
    (define (variable? x) (symbol? x))
    (define (same-variable? v1 v2)
      (and (variable? v1) (variable? v2) (eq? v1 v2)))
    (define (make-sum a1 a2) (list '+ a1 a2))
    (define (make-product m1 m2) (list '* m1 m2))
    (define (addend s) (cadr s))
    (define (augend s) (caddr s))
    (define (multiplier p) (cadr p))
    (define (multiplicand p) (caddr p))
    (define (=number? exp num)
      (and (number? exp) (= exp num)))
    (define (make-sum a1 a2)
      (cond ((=number? a1 0) a2)
            ((=number? a2 0) a1)
            ((and (number? a1) (number? a2)) (+ a1 a2))
            (else (list '+ a1 a2))))
    (define (make-product m1 m2)
      (cond ((or (=number? m1 0) (=number? m2 0)) 0)
            ((=number? m1 1) m2)
            ((=number? m2 1) m1)
            ((and (number? m1) (number? m2)) (* m1 m2))
            (else (list '* m1 m2))))
  (define sum (exp var)
    (cond ((number? exp) 0)
          ((variable? exp) (if (same-variable? exp var) 1 0))
          (else
           (make-sum (deriv (addend exp) var)
                     (deriv (augend exp) var)))))
  (define product (exp var)
    (cond ((number? exp) 0)
          ((variable? exp) (if (same-variable? exp var) 1 0))
          (else (make-sum
                 (make-product (multiplier exp)
                               (deriv (multiplicand exp) var))
                 (make-product (deriv (multiplier exp) var)
                               (multiplicand exp))))))
  (put 'deriv '+ sum)
  (put 'deriv '* product)
#+END_SRC

в) - надо разобраться с диффурами

г)  Понадобится только изменить способ, с помощью которого мы заносим данные
в таблицу.

~Упражнение 2.74.~
Insatiable Enterprises, Inc. — децентрализованная компания-конгломерат,
которая состоит из большого количества независимых подразделений, раскиданных по всему
миру. Недавно вычислительные мощности компании были связаны умной
вычислительной сетью, создающей для пользователя иллюзию, что он работает
с единым компьютером. Президент компании, когда она в первый раз
пытается воспользоваться способностью системы осуществлять доступ к
файлам подразделений, с изумлением и ужасом обнаруживает, что, несмотря
на то, что все эти файлы реализованы в виде структур данных на Scheme,
конкретная структура данных отличается от подразделения к подразделению.
Спешно созывается совещание менеджеров подразделений, чтобы найти стратегию,
которая позволила бы собрать файлы в единую систему для удовлетворения
нужд главного офиса, и одновременно сохранить существующую автономию подразделений.

Покажите, как такую стратегию можно реализовать при помощи
программирования, управляемого данными. К примеру, предположим, что
сведения о персонале каждого подразделения устроены в виде единого файла,
который содержит набор записей, проиндексированных по имени служащего.
Структура набора данных от подразделения к подразделению различается. Более того,
каждая запись сама по себе — набор сведений (в разных подразделениях
устроенный по-разному), в котором информация индексируется метками вроде
address (адрес) или salary (зарплата).
В частности:

а. Для главного офиса реализуйте процедуру get-record, которая получает
запись, относящуюся к указанному служащему, из указанного файла персонала. Процедура
должна быть применима к файлу любого подразделения. Объясните, как должны
быть структурированы файлы отдельных подразделений.
В частности, какую информацию о типах нужно хранить?

б. Для главного офиса реализуйте процедуру get-salary, которая возвращает
зарплату указанного служащего из файла любого подразделения.
Как должна быть устроена запись, чтобы могла работать эта процедура?

в. Для главного офиса напишите процедуру find-employee-record. Она должна
искать в файлах всех подразделений запись указанного служащего и возвращать эту
запись. Предположим, что в качестве аргументов эта процедура принимает имя служащего и
список файлов всех подразделений.

г. Какие изменения требуется внести в систему, чтобы внести в центральную
систему информацию о новых служащих, когда Insatiable поглощает новую компанию?

а) Нам сказано, что данные о сотрудниках подразделения хранятся в едином
файле. Файл содержит в себе набор записей, доступ к конкретному набору записей
можно получить с помощью фамилии сотрудника, к которому относится этот набор.
При этом структура файла у всех подразделений различается, как и
структура набора записей сотрудника. Но при этом этот набор индексируется
метками типа "адрес" или "зп".

Чтобы унифицировать все это безобразие, я бы сказала, что файл каждого
подразделения должен быть представлен как таблица, где ячейка
индексируется фамилией сотрудника и названием подразделения (вдруг есть 2
человека с одной фамилией в разных подраделениях).
Ячейка каждого сотруднника тоже будет
представлять из себя таблицу, где ячейки будут индексироваться с помощью
ключевых слов, таких как "зп", "семейное положение" и т.д.

К сожалению, эта идея не очень укладывается в предложенные
задания. Поэтому мы видоизменим идею. Педположим у нас все по-прежнему
организованно так же разномастно, но мы создадим процедуры, которые
функционируют по-разному в зависимости от того, с каким типом они
работают, и положим их в общую таблицу. Таблица будет проиндексирована с
помощью названия операции и типа, с которым которым операция работает. А
внутри ячейка будет содержать саму операцию.

Предположим, есть 2 подраздения. Программисты и менеджеры. Файл
программистов построен в виде таблицы, где каждая ячейка
проиндексирована названием подразделения и именем сотрудника. А записи
менеджеров оформлены в виде списка с подсписками.

Создадим 2 процедуры получения записи для каждого подразделения отдельно
и положим их в таблицу:
#+BEGIN_SRC scheme
  (define (get-record-programmer office name)
    (get office name))

  (define Office_ND (предположим, здесь какая-то таблица))
  ;; внесем эту процедуру в таблицу:
  ;; процедура обобщенно называется get-record, работает она с типом работников из Office_ND
  ;; и содержит в себе get-record-programmer, которая и достанет нам имя сотрудника.
  (put 'get-record 'Office_ND get-record-programmer)


  ;; предположим, записи менеджеров устроены как списки списков. Нам нужно просто найти
  ;; подсписок, который начинается с имени сотруждника
  (define (get-record-manager office name)
    (cond ((null? office) #f)
          ((equal? name (car (car office))) (cdr (car office)))
          (else (get-record-manager (cdr office) name))))

  ;; проверим, что эта процедура работает (с предыдущей процедурой этого сделать нельзя,
  ;; поскольку процедура get не определена в манепока что

  (define Office-NY (list (list 'Leemann (list 'salary 1000) (list 'adress 195204))
                     (list 'Kandinsky (list 'salary 1300) (list 'adress 947181))
                     (list 'Grauman (list 'salary 1100) (list 'adress 197382))))


  (get-record-manager Office-NY 'Leemann)
  (get-record-manager Office-NY 'Grauman)
  (get-record-manager Office-NY 'Durkess)

  ;; положим эту процедуру в таблицу тоже
  (put 'get-record 'Office-NY get-record-manager)

#+END_SRC

В соответствии с этой логикой ~get-record~ будет выглядеть так:
#+BEGIN_SRC scheme
  (define (get-record office name)
    ;; получаем процедуру и передаем ей параметры: офис и имя сотрудника
    ((get 'get-record office) office name))
#+END_SRC

б) Раз мы научились получать набор записей сотрудника и в общем
ориентироваться в файле, теперь на основе этого можно получить зарплату.
Предположим, что несмотря на то, что набор записей сотрудника в отделах
организован по-разному (у программеров этот файл выглядит как таблица, а
у манагеров - как список списков), но сведения о конкретном сотруднике
организованны в виде списка.
Таким образом нам сначала надо получить набор записей конкретного
сотрудника, а уже потом вытащить оттуда зп.
#+BEGIN_SRC scheme
  (define (get-salary office name)
    ;; получили конкретную запись
    (let ((record ((get 'get-record office) office name)))
      ;;процедура для поиска зп
      (define (iter record)
        (cond ((null? record) #f)
              ((equal? 'salary (car (car record))) (cadr (car record)))
              (else (iter (cdr record)))))
      (iter record)))

  ;; проверка iter отдельно от основной процедуры
  (define (iter record)
    (cond ((null? record) #f)
          ((equal? 'salary (car (car record))) (cadr (car record)))
          (else (iter (cdr record)))))

  (define test (list (list 'salary 1000)
                     (list 'adress 'street_1) (list 'wife 'Angel)))

  (define test2 (list (list 'adress 'street_1)  (list 'salary 1000) (list 'wife 'Angel)))
#+END_SRC

в)
Для главного офиса напишите процедуру find-employee-record. Она должна
искать в файлах всех подразделений запись указанного служащего и возвращать эту
запись. Предположим, что в качестве аргументов эта процедура принимает имя служащего и
список файлов всех подразделений.

Я бы вместо списка файлов организовала бы общую таблицу, где каждая
ячейка была бы проиндексирована именем сотрудника и названием
подразделения. Но пусть будет список файлов, записи в которых
представлены списками.

#+BEGIN_SRC scheme
  (define (find-employee-record office-list name)
    ;; пытаемся получить запись сотрудника из текуего файла
    (let ((record ((get 'get-record (car office-list)) (car office-list) name)))
      ;; запись пустая и список подразделений кончится на след итерации? - #f
      (cond ((and (null? record) (null? (cdr office-list))) #f)
            ;; запись пустая, но список еще не кончился?  - ищем по файлам дальше
            ((null? record) (find-employee-record (cdr office-list) name))
            ;; запись нашли
             (else record))))
#+END_SRC

г) Потребуется просто завести еще один файл и добавить его в общую
систему файлов.

~Упражнение 2.75.~
Реализуйте в стиле передачи сообщений конструктор ~make-from-mag-ang~. Он
должен быть аналогичен приведенной выше процедуре ~make-from-real-imag~.

#+BEGIN_SRC scheme
  (define (make-from-mag-ang magnitude angle)
    (define (dispatch op)
      (cond ((eq? op 'real-part) (* magnitude (cos angle)))
            ((eq? op 'imag-part) (* magnitude (sin angle)))
            ((eq? op 'magnitude) magnitude)
            ((eq? op 'angle) angle)
            (else
             (error "Неизвестная оп. -- MAKE-FROM-REAL-IMAG" op))))
    dispatch)
#+END_SRC

~Упражнение 2.76.~
Когда большая система с обобщенными операциями развивается, могут
потребоваться новые типы объектов данных или новые операции. Для каждой
из трех стратегий — обобщенные операции с явной диспетчеризацией, стиль,
управляемый данными, и передача сообщений, – опишите, какие изменения
нужно произвести в системе, чтобы добавить новый тип или новую
операцию. Какая организация лучше подходит для системы, в которую часто
добавляются новые типы? Какая для системы, где часто появляются новые операции?

Ответ:
Для стиля, управляемого данными потребуется просто вносить новые
процедуры и типы в таблицу. При модели передачи сообщений нужно будет
дополнять сами процедуры изнутри, дописывать код. Грубо говоря, если у
нас процедура рассчитывает работать с треугольником, кругом и овалом, то
при попытке передать ей в качестве типа квадрат, мы натолкнемся на
ошибку, чтоб ее избежать придется добавить еще один ~if~. В случае с
явной диспетчеризацией, т.е. я так понимаю, идет речь о разделе про
помеченные данные в мане, придется просто писать новые процедуры.

Я думаю, что в случае с расширяющейя системой, не важно чаще ли в ней
добавляются типы или операции, больше подходит стиль, управляемый
данными, поскольку добавить что-то в таблицу значительно проще, чем
переписывать уже существующий код или писать его заново.

~Упражнение 2.77.~
Хьюго Дум пытается вычислить выражение (magnitude z), где z — объект,
показанный на рис. 2.24.
К своему удивлению, вместо ответа 5 он получает сообщение об ошибке от apply-
generic, гласящее, что у операции magnitude нет методов для типа
(complex). Он показывает результат Лизе П. Хакер. Та заявляет:
"Дело в том, что селекторы комплексных чисел для чисел с меткой complex
определены не были, а были только для чисел с меткой polar
и rectangular.
Все, что требуется, чтобы заставить это работать — это добавить к пакету
complex следующее:"

#+BEGIN_SRC scheme

  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)

#+END_SRC
Подробно опишите, почему это работает. В качестве примера, проследите все
процедуры, которые вызываются при вычислении (magnitude z), где z —
объект, показанный на рис. 2.24. В частности, сколько раз вызывается
apply-generic? На какую процедуру она диспетчирует в каждом случае?

Ответ:
Это в человек может увязать, что раз операции написаны для типов ~polar~ и
~rectangular~, то и для типа complex эти операци должны сработать, ведь
~polar~ и ~rectangular~ - это всего дишь 2 варианта представления типа
complex, как декартовая форма или полярная форма - это форма
представления комплексных чисел. Но компьютер об этом ничего не знает,
соответственно,нужно прямо указать, что данные операции подходят и для
типа complex.

Так выглядит процедура magnitude в разделе 2.4.3.
#+BEGIN_SRC scheme

  (define magnitude z) (apply-generic 'magnitude z))

#+END_SRC

При ее вызове ~(magnitude z)~, где z - это объекст типа ~complex~,
происходит следующее: сначала ~apply-generic~ ищет в таблице
операцию ~magnitude~, которая работает с типом ~complex~. В этой ячейке
теперь не пусто, там содержится сама процедура magnitude. Мы помним, что
у нас двухуровневая диспетчеризация: за уровнем complex есть 2 возможных
варианта: polar или rectangular. На рисунке 2.24 указан тип
~rectangular~. Следовательно, мы теперь применяем найденную в ячейке с
пометкой ~'magnitude 'complex~ процедуру ~magnitude~ к типу
~rectangular~. ~apply-generic~ ищет по таблице второй раз (но уже на уровень
ниже) и применяет вариант magnitude для декартового представления
комплексных чисел.

~Упражнение 2.78.~
В пакете ~scheme-number~ внутренние процедуры, в сущности, ничего не
делают, только вызывают элементарные процедуры +, -, и т.д. Прямо
использовать примитивы языка не было возможности, поскольку наша система
меток типов требует, чтобы каждый объект данных был снабжен меткой.
Однако на самом деле все реализации Лиспа имеют систему типов, которую
они используют внутри себя.
Элементарные процедуры вроде symbol? или number? определяют,
относится ли объект к определенному типу. Измените определения type-tag, contents и
attach-tag из раздела 2.4.2 так, чтобы наша обобщенная система использовала внутреннюю
систему типов Scheme.
То есть, система должна работать так же, как раньше, но только обычные
числа должны быть представлены просто в виде чисел языка Scheme, а не в виде пары, у
которой первый элемент символ ~scheme-number~.

Формально одниих предикатов number? и symbol? недостаточно, для
нормальной типизации: number? возвраает t и на дробные числа тоже, а
не только на обычные. А для рациональных чисел есть пакет, котоый не
будет работать если данные не помечены как 'rational. Так что хоррошо бы
иметь предикаты, определяющие, целое число перед нами или нет. Но таковых
пока не дано, так что мой вариант решения:

#+BEGIN_SRC scheme

  ;; исходный вариант
  ;;  помечивает данные
  (define (attach-tag type-tag contents)
    (cons type-tag contents))

  ;; получает тип данных
  (define (type-tag datum)
    (if (pair? datum)
        (car datum)
        (error "Некорректные помеченные данные -- TYPE-TAG" datum)))

  ;; получает содержимое
  (define (contents datum)
    (if (pair? datum)
        (cdr datum)
        (error "Некорректные помеченные данные -- CONTENTS" datum)))

  ;; новый вариант
  (define (attach-tag type-tag contents)
    (if (number? contens)
        contens
        (cons type-tag contents)))

  ;; распознает тип данных (может работать только с числами или символами)
  (define (type-tag datum)
    (cond ((pair?  datum) (car datum))
          ((symbol?  datum) 'symbol)
          ((number?  datum) 'number))
    (else (error "Некорректные помеченные данные -- TYPE-TAG" datum)))

  (define (contents datum)
    (cond ((pair? datum) (cdr datum))
          ((not (pair? datum)) datum)
          (else (error "Некорректные помеченные данные -- CONTENTS" datum))))
#+END_SRC

~Упражнение 2.79.~
Определите обобщенный предикат равенства equ?, который проверяет два
числа на равенство, и вставьте его в пакет обобщенной арифметики.
Операция должна работать для обычных чисел, рациональных и комплексных.

#+BEGIN_SRC scheme

  (define (equ? n1 n2)
    (equal? n1 n2))

  (put 'equ '(complex complex) equ)
  (put 'equ '(rational rational) equ)
  (put 'equ '(scheme-number scheme-number) equ)

  ;; другое воплощение из частично подсмотренного варианта
  (define (equ? n1 n2)
    (apply-generic 'equ n1 n2))

  (define (equ-complex? n1 n2)
    (if (and (= (real-part n1) (real-part n1))
             (= (imag-part n1) (imag-part n2)))
        #t
        #f))

  (define (equ-rational? n1 n2)
    (if (and (= (denom n1) (denom n1))
             (= (numer n1) (numer n2)))
        #t
        #f))

  (put 'equ? '(complex complex) equ-complex?)
  (put 'equ? '(rational rational) equ-rational?)
  (put 'equ? '(scheme-number scheme-number) =)

#+END_SRC

~Упражнение 2.80.~
Определите обобщенный предикат =zero?, который проверяет, равен ли его
аргумент нулю, и вставьте его в пакет обобщенной арифметики.
Предикат должен работать для обычных, рациональных и комплексных чисел.

#+BEGIN_SRC scheme
  (define (=zero? n)
    (apply-generic '=zero? n))

  (define (zero-complex? n)
    (if (and (= 0 (real-part n))
             (= 0 (imag-part n)))
        #t
        #f))

  (define (zero-rational? n)
    (if (and (= 0 (denom n) (= 0 (numer n))))
        #t
        #f))

  (put '=zero? '(complex) zero-complex?)
  (put '=zero? '(rational) zero-rational?)
  (put '=zero? '(scheme-number) (lambda (n) (= 0 n)))
#+END_SRC

~Упражнение 2.81.~
Хьюго Дум заметил, что apply-generic может пытаться привести аргументы к
типу друг друга даже тогда, когда их типы и так совпадают.
Следовательно, решает он, нам нужно вставить в таблицу приведения
процедуры, которые «приводят» аргументы каждого типа к нему самому.
Например, в дополнение к приведению scheme-number->complex, описанному
выше, он бы написал еще:

#+BEGIN_SRC scheme
  (define (scheme-number->scheme-number n) n)

  (define (complex->complex z) z)

  (put-coercion 'scheme-number 'scheme-number
                 scheme-number->scheme-number)
  (put-coercion 'complex 'complex complex->complex)
#+END_SRC

а. Если установлены процедуры приведения типов, написанные Хьюго, что
произойдет, когда apply-generic будет вызвана с двумя аргументами типа
scheme-number или двумя аргументами типа complex для операции, которая не
находится в таблице для этих типов?
Допустим, например, что мы определили обобщенную процедуру возведения в
степень и добавили процедуру возведения в степень в пакет чисел Scheme и
ни в какой другой:

#+BEGIN_SRC scheme
  (define (exp x y) (apply-generic 'exp x y))

  ;; Следующие строки добавляются в пакет scheme-number
  (put 'exp '(scheme-number scheme-number)
        (lambda (x y) (tag (expt x y)))) ;; используется элементарная expt
#+END_SRC

Что произойдет, если мы позовем exp с двумя комплексными числами в
качестве аргументов?

Ответ:
У нас есть таблица приведения типов, где часть ячек - пустая, поскольку
невозможно привести объкт произвольного типа ко всем остальным типам. В
этой таблице ячейки проиндексированы типами, а содержимое их - операции,
по приведению одного типа в другой.

Новый вид apply-generic:
#+BEGIN_SRC scheme
  (define (apply-generic op . args)
    (let ((type-tags (map type-tag args)))
      (let ((proc (get op type-tags)))
        (if proc
            (apply proc (map contents args))
            (if (= (length args) 2)
                (let ((type1 (car type-tags))
                      (type2 (cadr type-tags))
                      (a1 (car args))
                      (a2 (cadr args)))
                  (let ((t1->t2 (get-coercion type1 type2))
                        (t2->t1 (get-coercion type2 type1)))
                    (cond (t1->t2
                           (apply-generic op (t1->t2 a1) a2))
                          (t2->t1
                           (apply-generic op a1 (t2->t1 a2)))
                          (else
                           (error "Нет метода для этих типов"
                                  (list op type-tags))))))
                (error "Нет метода для этих типов"
                       (list op type-tags)))))))
#+END_SRC

сейчас apply-generic работает по следующему принципу: получив 2
аргумента, ищет в таблице типов операцию для них. Если таковой нет, то
пробует привести аргумент пераого типа к аргументу второго и ищет
операцию снова. Если это не сработало, то пытается привести второй
аргумент к типа первого и опять ищет. Если и это не прокатило, то выдает
сообщение об ошибке.

Если установлены процедуры приведения типов, написанные Хьюго, то, когда
apply-generic будет вызвана с двумя аргументами типа scheme-number или
двумя аргументами типа complex для операции, которая не находится в
таблице для этих типов, apply-generic сначала попытается привести типы к
самим себе, затем пройдет по описанному выше сценарию, преджде чем выдать
сообщение об ошибке.
Посмотрим на обобщенную процедуру exp: внутри нее та же
apply-generic. Значит при вызове exp apply-generic приведет типы к самим
себе и вернемся к тому, с чего начали: к приведению типов. exp зациклится
навечно.

б) б. Прав ли Хьюго, что нужно что-то сделать с приведением однотипных
аргументов, или все и так работает правильно?

Ответ: конечно, прав. Какой смысл приводить типы аргументов друг к другу,
если они одинаковые? Только время тратить. В этом случае имеет смысл
поискать, для каких типов существует желаемая операция, и попробовать
привести типы аргументов к нужным.

в. Измените apply-generic так, чтобы она не пыталась применить
приведение, если у обоих аргументов один и тот же тип.

#+BEGIN_SRC scheme
  (define (apply-generic op . args)
    (let ((type-tags (map type-tag args)))
      (let ((proc (get op type-tags)))
        (if proc
            (apply proc (map contents args))
            (if (= (length args) 2)
                (let ((type1 (car type-tags))
                      (type2 (cadr type-tags))
                      (a1 (car args))
                      (a2 (cadr args)))
                  (if (equal? type1 type2)
                      (error "Нет метода для этих одинаковых типов" (list op type-tags))
                  (let ((t1->t2 (get-coercion type1 type2))
                        (t2->t1 (get-coercion type2 type1)))
                    (cond (t1->t2
                           (apply-generic op (t1->t2 a1) a2))
                          (t2->t1
                           (apply-generic op a1 (t2->t1 a2)))
                          (else
                           (error "Нет метода для этих типов"
                                  (list op type-tags)))))))
                (error "Нет метода для этих типов"
                       (list op type-tags)))))))
#+END_SRC


~Упражнение 2.82.~
Покажите, как обобщить apply-generic так, чтобы она обрабатывала
приведение в общем случае с несколькими аргументами. Один из способов
состоит в том, чтобы попытаться сначала привести все аргументы к типу
первого, потом к типу второго, и так далее. Приведите пример,
когда эта стратегия (а также двухаргументная версия, описанная выше)
недостаточно обща. (Подсказка: рассмотрите случай, когда в таблице есть
какие-то подходящие операции со смешанными типами, но обращения к ним не произойдет.)

Нам нужны суб-процедуры:
1. ~change-types~ будет приводить все аргументы к указанному типу, усли это
   возможно. Если привести не удалось, возвращаем фолс, иначе возвращаем
   список
2. ~get-type~ получит тип из списка типов. У нас есть 2 списка: в одном
   аргуметы, в другом их типы. Между этими типами есть строгое
   соответствие: первый элемент из списка типов соответствует первому
   элементу из списка аргументов и т.д. Передавая индекс в ~get-type~ мы
   гвоорим, тип какого аргумента хотим получить. Чтоб затем передать его
   в ~change-types~ и привести остальные аргументы к нему.
3. Внутренняя процедур ~iter~ получает на вход индекс, операцию,
   аргументы и их типы.
   Сначала ~iter~ попытается найти операцию для текущих аргументов и
   типов. Если нашли, то операция применяется, в противном случае мы
   пытаемся привести все аргументы к типу первого аргумента, второго и
   т.д. пока либо не дойдем до конца списка аргументов, либо не найдем
   подходящую операцию.

К сожалению, если последовательно приводить все аргументы к указанному
типу, то мы никогда не найдем операции в таблице, которые работают со
смешанными типами, поскольку типы наших аргументов всегда будут
оказываться одинаковыми, если приведение к указанному типу возможно.

#+BEGIN_SRC scheme
  (define (numer x) (car x))

  (define (denom x) (cdr x))

  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))

  (define (attach-tag type-tag contents)
    (cons type-tag contents))

  (define (type-tag datum)
    (if (pair? datum)
        (car datum)
        (error "Некорректные помеченные данные -- TYPE-TAG" datum)))

  (define (contents datum)
    (if (pair? datum)
        (cdr datum)
        (error "Некорректные помеченные данные -- CONTENTS" datum)))

  ;; примитивная реализация get-coertion. В мане не дано ее определение,
  ;; используется для поиска операций с приведением типов, здесь эмулируется то же самое
  ;; поведение. Переводит обычные числа в рациональные и наоборот.
  (define (get-coercion t1 t2)
    (cond ((and (equal? t1 'rational) (equal? t2 'scheme-number))
           (lambda (n) (make-rat n 1)))
          ((and (equal? t1 'scheme-number) (equal? t2 'rational))
           (lambda (x)
             (/ (+ (numer x) 0.0) (+ (denom x) 0.0))))
          (else #f)))

  ;; принимает тип, к которому нужно привести все аргументы,
  ;; типы аргументов и сами аргументы
  ;; если удалось все аргументы привести к указанному типу, возвращает
  ;; список приведенных к типу аргументов
  (define (change-types type types args)
    (define (iter type types args results)
      ;;аргументы кончились?
      (if (null? args)
          ;; вернуть результаты
          (reverse results)
          ;; инече попытатся найти операцию по приведению типов
          (let ((t1->t2 (get-coercion type (car types))))
            ;; нашли операцию?
            (if t1->t2
                ;; да, приводим к типу аргумент и идем на след. круг
                (iter type (cdr types) (cdr args) (cons (attach-tag
                                                         type
                                                         (t1->t2 (car args))) results))
                ;; такой операции нет, приведение к типу невозможно
                #f))))
    (format #t "change-types: type ~A\n" type)
    (iter type types args '()))

  ;; тесты
  ;; (change-types 'rational (list 'scheme-number 'scheme-number 'scheme-number
  ;;                               'scheme-number)
  ;;               (list 18 34 878 6567))

  ;; (change-types 'scheme-number (list 'rational 'rational 'scheme-number)
  ;;               (list (make-rat 3 6) (make-rat 12 8) 18))

  ;; (define (get op types)
  ;;   (define (check-types type list)
  ;;     (cond ((null? list) #t)
  ;;           ((equal? type (car list)) (check-types type (cdr list)))
  ;;           (else #f)))
  ;;   (cond ((and (equal? 'add op) (check-types 'scheme-number types))
  ;;          +)
  ;;         ((and (equal? 'sub op) (check-types 'scheme-number types))
  ;;         -)
  ;;         (else #f)))


  ;; получает тип из списка типов по индексу
  ;; нужена, чтоб получить тип первого аргумента, второго и т.д.
  (define (get-type indx types-lst)
    (cond ((or (>= indx (length types-lst)) (< indx 0)) #f)
          ((= indx 0) (car types-lst))
          (else (get-type (- indx 1) (cdr types-lst)))))

  (get-type 3 (list 'a 'b 'c 'd))


  (define (apply-generic op . args)
    (define (iter op indx type-tags args)
      ;; если индекс больше длины списка, значит мы привели все аргменты к типу последнего,
      ;; но так ничего и не нашли
      (if (>= indx (length args))
          (error "Нет метода для этих типов"
                 (list op type-tags))
          ;; иначе получаем текущие типы аргументов
          (let* ((cur-types (map type-tag args))
                 ;; ищем операцию для них
                 (proc (get op cur-types)))
            ;; операция найдена?
            (if proc
                ;; да, применим ее
                (apply proc (map contents args))
                ;; иначе пытаемся привести типы к типу аргумента на текущем индексе в списке
                (let ((new-args (change-types (get-type indx type-tags) cur-types args)))
                  ;; приведение типов удалось?
                  (if new-args
                      ;; да, вызываем iter с обновленным состояним аргументов
                      (iter op (+ indx 1) type-tags new-args)
                      ;; нет, вызываем iter с текущим представлением аргументов
                      (iter op (+ indx 1) type-tags args)))))))
    (let ((type-tags (map type-tag args)))
      (iter op 0 type-tags args)))
#+END_SRC

~Упражнение 2.83.~
Предположим, что Вы разрабатываете обобщенную арифметическую систему для
работы с башней типов, показанной на рис. 2.25: целые, рациональные, действительные,
комплексные. Для каждого из типов (кроме комплексного), разработайте
процедуру, поднимающую объект на один уровень в башне. Покажите, как
ввести обобщенную операцию raise, которая будет работать для всех типов
(кроме комплексных чисел).

Итак, нам понадобятся операции для приведения типов, которые будут
лежать в таблице типов:
scheme-number->rational
rational->real
real->complex

Для создания ~raise~ я не воспользовалась ~apply-generic~ поскольку:
операция ~get~ не найден ничего в таблице операций, поскольку приведение
типов - это отдельная таблица. А ~get-coertion~, которая приводит типы в
apply-generic, нуждается в двух аргументах: тип, который приводим, и тип,
к которому приводим. Но поскольку процедуру ~raise~ я оформляю в виде
черного ящика, я не хочу, чтоб пльзователь думал, какой там тип
в иерархии типов стоит над текущим, и указывал его как второй аргумент
~get-coertion~. Идея в том, чтоб пользователь просто ввел аргумент, а на
выходе получил обновленное состояние аргумента, если это
возможно. Поэтому ~raise~ выглядит так громоздко.

#+BEGIN_SRC scheme
  (define (scheme-number->rational n)
    (attach-tag 'rational (make-rat (contents n) 1)))

  ;; поскольку мы знаем, что действительные числа - это все числа, которые можно записать
  ;; конечной или бесконечной дробью, то нам никак не надо менять рациональную дробь,
  ;; ведь она тоже действительное число. Просто присвоим ей тип
  (define (rational->real n)
    (attach-tag 'real (contents n)))

  (define (real->complex n)
    (make-complex-from-real-imag (contents n) 0))

  ;; положим все операции в воображаемую таблицу по приведению типов
  (put-coertion 'scheme-number 'rational scheme-number->rational)
  (put-coertion 'rational 'real rational->real)
  (put-coertion 'real 'complex real->complex)

  ;; предположим, что аргумент всего 1
  (define (raise arg)
    (let ((type-tag (type-tag arg)))
      (cond ((equal? (car type-tags) 'scheme-number)
             (get-coertion (car type-tags) 'rational))
            ((equal? (car type-tags) 'rational)
             (get-coertion (car type-tags) 'real))
            ((equal? (car type-tags) 'real)
             (get-coertion (car type-tags) 'complex))
            (else #f))))

  ;; есть более элегантный подсмотренный вариант
  ;; суть в том, чтоб получить недостающий аргумент - тип, к котоому надо привести -
  ;; из таблицы операций
  (define (raise obj)
    (let* ((type-tag (type-tag obj))
           (supertype (get 'raise type-tag)))
      (if supertype
          ((get-coercion type-tag supertype) obj)
          obj)))

  ;; чтоб использовать этот ваиант, нужноп оложить raise в таблицу операций
  ;; (косяк этого варианта в том, что таблица операций предполагает, что внутри ее ячеек
  ;; лежат операции, а не символы, так мы нарушаем логику таблицы операций)
  (put 'raise 'scheme-num 'rational)
  (put 'raise 'rational 'real)
  (put 'raise 'real 'complex)
#+END_SRC

~Упражнение 2.84.~
Используя операцию raise из упражнения 2.83, измените процедуру
apply-generic так, чтобы она приводила аргументы к одному типу путем
последовательного подъема, как описано в этом разделе.
Потребуется придумать способ проверки, какой из двух типов выше по башне. Сде-
лайте это способом, «совместимым» с остальной системой, так, чтобы не
возникало проблем при добавлении к башне новых типов.

Как я понимаю это задание:
Итак, есть башня типов. Есть список аргументов у apply-generic, который
может быть любой длины. Нам нужно узнать, какой у нас есть самый
"высокий" тип аргумента из представленных, а затем последовательно
поднять по башне типов все остальные аргументы до самого высокого.
При этом это нельзя сделать кустарным способом, вроде, "если самый
высокий тип такой-то, то делаем то-то".
Самое главное - это придумать, как определить какой тип выше по башне,
при это сделать это так, чтоб при добавлении нового типа ничего не
пришлось менять.

Вариант: присвоить типам числовые идентфикаторы. Чем идентификтор больше,
тот по иерархии выше.

Предположим, задать башню типов списком. Индексируем каждый элемент
списка он 0 до n. Берем тип первого аргумента, проходимся по башне
типов. При совпадении получаем индекс типа, сохраняем. Берем тип второго
аргумента, проходимся по башне. Находим его индекс. Если его индекс
больше предыдущего, обновляем индекс. Повторяем до тех пор, пока не
обойдем весь список аргументов.

Этим займется процедура ~get-highest-type~ которая вернет нам числовой
идентификатор самого "высокого" типа из представленных типов аргументов.

Будем вызывать ~raise~ для каждого аргумента до тех пор, пока
идентификаторы всех ргументов не сравняются с заданным. Т.е. пока все
типы не поднимутся до исходного.

- получаем идентификатор самого высокого типа в иерархии.
- проходимся по списку аргументов, если идентификаторы типов аргументов
  совпадают, не вызываем raise. Иначе вызываем raise до тех пор, пока
  идентификатор тип аргумента не сравняется с заданным.
- продолжаем до тех пор, пока не дойдем до конца списка аргументов
- после этого вызываем заданную операцию для аргументов

#+BEGIN_SRC scheme
  (define types-tower (list 'a 'b 'c 'd))

  (define types-args (list 'c 'c 'a 'd 'c))

  ;; возвращает числовой идентификатор типа, если тип есть в башне
  ;; иначе #f
  (define (get-ident-of-type type types-tower)
    (define (iter type types-tower indx)
    (cond ((null? types-tower) #f)
          ((equal? type (car types-tower)) indx)
          (else (iter type (cdr types-tower) (+ 1 indx)))))
    (iter type types-tower 0))
  ;; возвраает идентификатор самого высокого типа из представленных в списке аргументов
  (define (get-highest-type types-args types-tower)
    (define (iter types-args types-tower ident)
      (if (null? types-args)
          ident
          (let ((cur-ident (get-ident-of-type (car types-args) types-tower)))
            (if (not cur-ident)
                #f
                (if (> cur-ident ident)
                    (iter (cdr types-args) types-tower cur-ident)
                    (iter (cdr types-args) types-tower ident)))))
      (iter  types-args types-tower 0)))

  ;; (get-highest-type types-args types-tower)

  ;;применяет процедуру raise заданное кол-во раз
  (define (iter-raise arg n types-tower)
    (if (= 0 n)
        arg
        (iter-raise (raise arg) (- n 1) types-tower)))

  (define (apply-generic op . args)
    (define (raise-all-args args ident-type new-lst)
      ;; если аргументы кончились или у нас нет идентификатора самого высокого типа
      (if (or (not ident-type) (null? args))
          ;; возвращаем пустой список
          new-lst
          ;; иначе получаем идентификатор типа текущего аргумента
          (let ((cur-type-ident (get-ident-of-type (type-tag (car args)) types-tower)))
            ;; если он меньше идентификатора самого высокого в иерархии типа
            (if (< cur-type-ident ident-type)
                ;; повышаем аргумент в иерархии заданное кол-во раз и идем к след. аргументу
                (cons (iter-raise (car args) (- ident-type cur-type-ident) types-tower)
                      (raise-all-args (cdr args) ident-type new-lst))
                ;; иначе оставляем аргумент как есть и к след. аргументу
                (cons (car args) (raise-all-args (cdr args) ident-type new-lst))))))
    ;; получаем список типов исходных аргументов
    (let* ((types-args (map type-tag args))
           ;; получаем новые аргументы, поднятые до заданного типа в иерархии типов
           (new-args (raise-all-args args (get-highest-type types-args types-tower) '())))
      ;; если получили новые аргументы
      (if new-args
          ;; получаем их типы
          (let* ((new-types-args (map type-tag new-args))
                 ;; ищем для них операцию
                 (proc (get op new-types-args)))
            ;; если нашли операцию
            (if proc
                ;; применяем ее
                (apply proc (map contents new-args))
                ;; иначе сообение об ошибке
                (error "Нет метода для этих типов"
                       (list op new-types-args))))
          ;; если новые аргументы получены не были, выдаем сообщение об ошибке
          (error "Не удалось обработать данные аргументы:
                  возможно, аргументы имею не указанные в башне типы"
                 (list op types-args))
          )))
#+END_SRC
~Упражнение 2.85.~
В этом разделе упоминался метод «упрощения» объекта данных путем спуска
его по башне насколько возможно вниз. Разработайте процедуру drop, которая делает это
для башни, описанной в упражнении 2.83. Ключ к задаче состоит в том,
что надо решить некоторым общим способом, можно ли понизить объект в
типе. Например, комплексное число 1.5+0i можно опустить до real,
комплексное число 1 + 0i до integer, а комплексное число 2 + 3i никуда
понизить нельзя. Вот план того, как определить, можно ли понизить объект: для начала
определите обобщенную операцию project, которая «сталкивает» объект вниз
по башне.
Например, проекция комплексного числа будет состоять в отбрасывании его
мнимой части.
Тогда число можно сдвинуть вниз в том случае, если, спроецировав его, а
затем подняв  обратно до исходного типа, мы получаем нечто, равное
исходному числу.
Покажите как реализовать эту идею в деталях, написав процедуру drop,
которая опускает  объект как можно ниже. Потребуется разработать
различные операции проекции и установить project в системе в качестве
обобщенной операции. Вам также потребуется обобщенный предикат равенства,
подобный описанному в упражнении 2.79. Наконец, используя drop,
перепишите apply-generic из упражнения 2.84, чтобы она «упрощала» свои результаты.

Предположим, у нас есть пакеты, которые работают с целыми числами и
действительными (возможно, тип scheme-number - это и есть тип для
действительных чисел,в мане числа этого типа автор называет обычными
числами)

- прежде чем опустить число вниз по башне, сохранить исходное
- для комплексного числа: комплексное->действительное и
  комплексное->целое
- для действительных: действительное-> рациональное и
  действительное->целое
- для рациональных: рациональное->целое

план ~project~:
- принимает 1 аргумент
- опускает его ниже, запоминает нвоое значение
- сравнивает старое и новое значения
- если совпадает, возвращает новое значение
- если нет и нет альтернативы, возвращает исходный аргумент (так проще
  уберечься от ошибок)

#+BEGIN_SRC scheme
  ;; обобщенная операция проекции
  (define (project arg)
    (apply-generic 'project arg))

  ;; обобщенный предикат равенства
  (define (equ? n1 n2)
    (apply-generic 'equ n1 n2))

  ;; проверка комплексных чисел на равенство
  (define (equ-complex? n1 n2)
    (if (and (= (real-part n1) (real-part n1))
             (= (imag-part n1) (imag-part n2)))
        #t
        #f))
  ;; проверка действительных чисел на равенство
  ;; в данном задании мы нарочно будем считать, что действительные числа могут быть
  ;; представлены только в виде рациональной дроби или целого числа, т.к.
  ;; нет ни представления, для работы с десятичной дробью
  (define (equ-real? n1 n2)
    (if (and (integer? n1) (integer? n2))
        (equ-integer n1 n2)
        (equ-rational? n1 n2)))


  ;; проверка рациональных
  (define (equ-rational? n1 n2)
    (if (and (= (denom n1) (denom n1))
             (= (numer n1) (numer n2)))
        #t
        #f))

  ;; проверка целых
  (define (equ-integer n1 n2)
    (= n1 n2))

  (put 'equ? '(complex complex) equ-complex?)
  (put 'equ? '(rational rational) equ-rational?)
  (put 'equ? '(scheme-number scheme-number) equ-integer)
  (put 'equ? '(real real) equ-real?)

  ;; будем считать, что действительные числа могут быть рациональными дробями или целыми
  ;;  но поскольку целые числа переводить уже некуда, то у нас остается только представление
  ;; действительных чисел в виде рациональных дробей, а значит, менять предс тавление
  ;; аргумента не надо, достаточно только изменить его тип
  (define (project-real arg)
    (make-rational (numer arg) (denom arg)))

  (define (project-complex arg)
    ;; если действительная часть комплексного числа - целое число
    (if (integer? (real-part arg))
        ;; пробуем перевести комплексное число в целое
        (let* ((complex->integer (real-part arg))
               (check (equ? (make-complex-from-real-imag complex->integer 0) arg)))
          ;; если удалось перевести,
          (if check
              ;; возвращаем новое значение аргумента
              (attach-tag 'integer complex->integer)
              #f))
        ;; если действительная часть комплексного числа не целое,
        ;; пробуем в перевести его в действительное число
        (let* ((complex->real (real-part arg))
               (check (equ? (make-complex-from-real-imag complex->real 0) arg)))
          (if check
              ;; возвращаем новое значение аргумента
              (attach-tag 'real complex->real)
              #f))))

  (define (project-rational arg)
    ;; переводим из рациональной дроби в целое число
    (let* ((rational->integer (numer arg))
           (check (equ? (make-rat rational->integer 1) arg)))
      ;; если проверка удалась
      (if check
          ;; возвращаем новое значение аргумента
          (make-rational rational->integer 1)
          #f)))

  ;; чтоб не возникало ошибок при ппопытке спустить вниз integer, введем эту процедуру
  (define (project-integer arg)
    (attach-tag 'integer arg))

  ;;кладем все оперции проекции в таблицу операций
  (put 'project 'complex project-complex)
  (put 'project 'rational project-rational)
  (put 'project? 'real project-real)
  (put 'project? 'integer project-integer)

  (define (drop arg)
    ;;узнаем тип аргумента
    (let* ((type (type-tag arg))
           ;; если есть оперция проекции для этого аргумента
           (op (get 'project type)))
      (if op
          ;; применям
          (apply op (contents arg))
          #f)))

#+END_SRC

Теперь надо переписать ~apply-generic~ так, чтоб она спускала свои
аргументы по башне типов, а не поднимала.

#+BEGIN_SRC scheme
  (define (apply-generic op .args)
    ;; функция спустит все аргументы вниз и вернет новый список аргументов
    (define (drop-all-args args new-list)
      (if (null? args)
          new-list
          (cons (drop (car arg)) (drop-all-args (cdr args) new-list))))
    ;; получаем исхожные типы аргументов
    (let* ((types-args (map type-tag args))
           ;; ищем для них заданную операцию
           (fn (get op types-args)))
      (if fn
          ;; применяем операцию, если нашли
          (apply fn (map contents args))
          ;; иначе спускаем все аргументы вниз, насколько возможно
          (let* ((new-args (drop-all-args args '()))
                 (new-types-args (map type-tag new-args))
                 (new-fn (get op new-types-args))))
          (if new-fn
              ;; применяем заданную операцию для нового представления аргументов,
              ;; если она существует
              (apply new-fn (map contents new-args))
              ;; иначе сообщение об ошибке
              (error "Нет метода для этих типов"
                     (list op types-tags))))))

#+END_SRC

~Упражнение 2.86.~
Допустим, нам хочется работать с комплексными числами, чьи действительные
и мнимые части, модули и аргументы могут быть обыкновенными числами, рациональными
числами либо любыми другими, какие нам захочется добавить к системе.
Опишите и реализуйте изменения в системе, которые потребуются, чтобы
добавить такую возможность. Вам придется определить операции вроде sine
(синус) и cosine (косинус), обобщенные на обыкновенные и рациональные
числа.

Речь идет о тригонометрическом представлении комплексных
чисел. Предположим, у нас есть координатная плоскость, где комплексное
число z находится в точке а,b. То есть мы берем действительную часть ~a~
и мнимую часть ~b~ находим точку по этим координатам и эта точка -
комплексное число ~z~. Но можно найти комплексное число ~z~ с помощью
угла, который получится, если проведем линию от ~z~ до начала координат
0,0. Согласно этой идее, ~a~ ~ будет выражаться как ~r*cosФ~,  ~b~ будет
выражаться как  ~r * sinФ~. r = это корень из а^2 + b^2, а фи - это угол
от радиус-вектора (линии, соединяющей начало координат и комплексное
число) и горизонтальной оси на комплексной плоскости.

Значит нам нужно понять, как получить синус и косинус угла фи, если у нас
числа ~a~ и  ~b~ могут быть абсолютно любыми.

К счастью, у нас в пакете коплексных чисел процедуры, которые работают с
тригонометрическим представлением комплексных чисел. Поэтому фи нам
считать не надо. Мы просто немного переопределим некоторые операции.

#+BEGIN_SRC scheme
  ;; обобщенные операции
  (define (sine n)
    (apply-generic 'sine n))

  (define (cosine n)
    (apply-generic 'cosine n))

  ;; кладем обобщенные операции в таблицу (можно потом добавить любые типы)
  (put 'sine '(scheme-number) (lambda (x) (tag (sin x))))
  (put 'cosine '(scheme-number) (lambda (x) (tag (cos x))))

  ;; для вычислений нам нужно уметь считать квадраты чисел и их квадратные корни
  (define (square x)
    (mul x x))

  (define (average x y)
    (div (add x y) 2.0))

  (define (sqrt x)
    (fixed-point (average-damp (lambda (y) (div x y)))
                 1.0))

  ;;добавлям к пакету комплексных чисел!
  ;; с учетом того, что теперь компоненты комплексного числа могут быть любыми числами,
  ;; то операции сложения, вычитания и т.д. внутри процедур, работаюих с комплексными
  ;; числами, должны быть обобщенными.
  (define (add-complex z1 z2)
    (make-from-real-imag (add (real-part z1) (real-part z2))
                         (add (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (sub (real-part z1) (real-part z2))
                         (sub (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (mul (magnitude z1) (magnitude z2))
                       (add (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (div (magnitude z1) (magnitude z2))
                       (sub (angle z1) (angle z2))))

  ;; добавляем к пакету для поляорного представления чисел!
  ;; соответственно, процедуры magnitude и angle используются из этого же пакета
  ;; не путать с одноименными операциями из другого пакета
  (define (real-part z)
    (mul (magnitude z) (cosine (angle z))))

  (define (imag-part z)
    (mul (magnitude z) (sine (angle z))))

  ;; добавляем к пакету для тригонометрического представления комплексных чисел
  ;; (фактически считаем magnitude и angle, только те работают уже с комплексным числом,
  ;; вытаскивая и него r и фи, а мы проводим обратную операцию, составляя из r и фи
  ;; комплексное число)
  (define (make-from-real-imag x y)
    (cons (sqrt (add (square x) (square y)))
          (atan y x)))

#+END_SRC

~шпаргалка для операций над многочленами~
#+BEGIN_SRC scheme
  (define (install-polynomial-package)
    ;; ВНУТРЕННИЕ ПРОЦЕДУРЫ
    ;; представление poly

    ;; создает полином (многочлен) как список из переменной и списка термов
    (define (make-poly variable term-list)
      (cons variable term-list))

    ;; проверяет, является ли аргумент переменной
    (define (variable? x) (symbol? x))

    ;; проверяет, являются ли 2 переменные одинаковыми
    (define (same-variable? v1 v2)
      (and (variable? v1) (variable? v2) (eq? v1 v2)))

    ;; получает переменную из полинома
    (define (variable p) (car p))
    ;;получает список термов из полинома
    (define (term-list p) (cdr p))


    ;; ПРЕДСТАВЛЕНИЯ ТЕРМОВ И СПИСКОВ ТЕРМОВ
    ;; создает терм как список из порядка и коэфициента
    ;; порядок трема - это то, в какой степени его переменная

    (define (make-term order coeff) (list order coeff))

    ;;возвращает порядок терма
    (define (order term) (car term))

    ;; возвращает коэфициент терма
    (define (coeff term) (cadr term))

    ;; добавляет терм к списку термов
    (define (adjoin-term term term-list)
      ;; коэфициент трема нулевой?
      (if (=zero? (coeff term))
          ;; да, не добавляем терм
          term-list
          ;; нет, добавляем терм
          (cons term term-list)))

    (define (the-empty-termlist) '())

    ;; получаем самый терм самого высокого порядка из списка термов
    ;; термы всегда отсортированны по их порядкам от бОльшего к меньшему
    (define (first-term term-list) (car term-list))

    ;; возвращает все термы, кроме терма в самым высоким порядком
    (define (rest-terms term-list) (cdr term-list))

    ;; проверяет список термов на наличие в нем термов
    (define (empty-termlist? term-list) (null? term-list))

    ;; складывает многочлены
    ;; наша система умеет работать только с многочленами, где только 1 переменная
    (define (add-poly p1 p2)
      ;; если переменная одна и таже в обоих полиномах
      (if (same-variable? (variable p1) (variable p2))
          ;; то создаем новый полином, куда копируем переменную
          ;; и складываем термы ддвух полиномов
          (make-poly (variable p1)
                     (add-terms (term-list p1)
                                (term-list p2)))
          ;; иначе сообщение об ошибке
          (error "Многочлены от разных переменных -- ADD-POLY"
                 (list p1 p2))))

    ;; умножает многочлены
    ;; механизм аналогичен процедуре выше, но только с умножением
    (define (mul-poly p1 p2)
      (if (same-variable? (variable p1) (variable p2))
          (make-poly (variable p1)
                     (mul-terms (term-list p1)
                                (term-list p2)))
          (error "Многочлены от разных переменных -- MUL-POLY"
                 (list p1 p2))))

    ;; процедура сложения термов
    ;; суть в том, чтоб сложить термы одинакового порядка, а если для текущего терма нет
    ;; терма с таким же порядком, просто добавляем его в новому списку термов
    (define (add-terms L1 L2)
      ;; если какой-то из списка термов пуст, возвращаем другой список термов
      (cond ((empty-termlist? L1) L2)
            ((empty-termlist? L2) L1)
            ;;иначе
            (else
             ;; получаем первые термы из спика ( они будут с самым высоким порядком)
             (let ((t1 (first-term L1)) (t2 (first-term L2)))
               ;; если порядок первого терма больше порядка второго терма
               (cond ((> (order t1) (order t2))
                      ;; добавляем первый терм к списку термов, который породит рекурсия
                      (adjoin-term
                       t1 (add-terms (rest-terms L1) L2)))
                     ;; аналогично, но только для второго терма
                     ((< (order t1) (order t2))
                      (adjoin-term
                       t2 (add-terms L1 (rest-terms L2))))
                     ;; если порядки термов равны
                     (else
                      ;; создаем новый терм с тем же порядком, что у исходных, но с суммой их
                      ;; коэфициентов, и добавляем его в список, порожденный рекурсией
                      (adjoin-term
                       (make-term (order t1)
                                  (add (coeff t1) (coeff t2)))
                       (add-terms (rest-terms L1)
                                  (rest-terms L2)))))))))

    ;; умножение термов
    ;; суть умножения термов в том, чтоб перемножить все термы первого списка
    ;; на все термы второго
    (define (mul-terms L1 L2)
      (if (empty-termlist? L1)
          (the-empty-termlist)
          ;; затем здесь исользовано сложение?
          (add-terms (mul-term-by-all-terms (first-term L1) L2)
                     (mul-terms (rest-terms L1) L2))))

    ;; эта процедура умножит текущий терм на все термы из предложенного списка
    (define (mul-term-by-all-terms t1 L)
      (if (empty-termlist? L)
          (the-empty-termlist)
          ;; получаем первый терм второго списка
          (let ((t2 (first-term L)))
            ;; добавляем новые термы
            (adjoin-term
             ;; складываем порядки, умножаем коэфициенты
             (make-term (add (order t1) (order t2))
                        (mul (coeff t1) (coeff t2)))
             ;; рекурсивно вызываем функцию с состатком списка термов пока список не кончится
             (mul-term-by-all-terms t1 (rest-terms L))))))

    ;; интерфейс к остальной системе
    (define (tag p) (attach-tag 'polynomial p))
    (put 'add '(polynomial polynomial)
          (lambda (p1 p2) (tag (add-poly p1 p2))))
    (put 'mul '(polynomial polynomial)
          (lambda (p1 p2) (tag (mul-poly p1 p2))))
    (put 'make 'polynomial
          (lambda (var terms) (tag (make-poly var terms))))
    'done)
#+END_SRC

~Упражнение 2.87.~
Установите ~=zero?~ для многочленов в обобщенный арифметический пакет. Это
позволит ~adjoin-term~ работать с многочленами, чьи коэффициенты сами по
себе многочлены.


Воспользуемся предикатом ~=zero?~ из упражнения 2.80, т.к. он прекрасно
отвечает нашим целям. Более того, позволяет нам иметь в качестве
коэфициентов не только целые числа и при добавлении любого другого
коэфициента, можно будет просто добавить еще один вариант предиката и
внести его в систему.

#+BEGIN_SRC scheme
  (define (=zero? n)
    (apply-generic '=zero? n))

  (define (zero-complex? n)
    (if (and (= 0 (real-part n))
             (= 0 (imag-part n)))
        #t
        #f))

  (define (zero-rational? n)
    (if (and (= 0 (denom n) (= 0 (numer n))))
        #t
        #f))

  (put '=zero? '(complex) zero-complex?)
  (put '=zero? '(rational) zero-rational?)
  (put '=zero? '(scheme-number) (lambda (n) (= 0 n)))
#+END_SRC


~Упражнение 2.88.~
Расширьте систему многочленов так, чтобы она включала вычитание
многочленов.
(Подсказка: может оказаться полезным определить обобщенную операцию смены
знака.)

процедура смены знака нужна, чтоб поменять все знаки у термов второго
полинома, т.к. если записать разность двух полиномов
(6x + 3y) - (7x + 9y) и опустить скобки, то согласно правилам, если перед
скобкой стоит минус, то при отбрасывании скобок все термы скобки поменяют
свой знак на противоположный.

Нужно вычесть термы одинакового порядка друг из друга. Если порядок терма
единственный в своем роде в данном выражении, то мы добавим его в новый
список термов с его текущим знаком.

#+BEGIN_SRC scheme
  ;; процедуры, меняющие знак у коэфициентов термов

  ;; для плотного представления термов
  (define (change-sign-dense terms-list)
    (define (iter terms-list new-lst)
      (cond ((null? terms-list) new-lst)
            ((= (car terms-list) 0)
             (cons (car terms-list) (iter (cdr terms-list) new-lst)))
            (else
             (cons (/ (car terms-list) -1.0) (iter (cdr terms-list) new-lst)))))
    (iter terms-list '()))

  ;; для разреженного
  (define (change-sign-sparse terms-list)
    (define (iter terms-list new-lst)
      (cond ((null? terms-list) new-lst)
            ((= (coeff (car terms-list)) 0)
             (cons (car terms-list) (iter (cdr terms-list) new-lst)))
            (else
             (cons (make-term (order (car terms-list))
                              (/ (coeff (car terms-list)) -1.0))
                   (iter (cdr terms-list) new-lst)))))
    (iter terms-list '()))

  (put 'change-sign 'dense change-sign-dense)
  (put 'change-sign 'sparse change-sign-sparse)

  (define (change-sign terms-lst)
    (apply-generic 'change-sign terms-lst))


  (define change-sign-dense-test '(1 2 0 3 -2 -5))

  ;; для корректного тестирования change-sign-sparse в интерпретатор должно быть залито:
  (define (coeff term) (cadr term))

  (define change-sign-sparse-test '((5 2) (4 3) (2 2) (0 -5)))

  ;; Для корректной работы процедур adjoin-terms и adjoin-terms-dense,используемых
  ;; в процедурах вычитания, нужно залить это в интерпритатор:

  (define (=zero? n)
    (= n 0))


#+END_SRC

Вариант для разреженного представления полиномов:
#+BEGIN_SRC scheme
  (define (sub-terms-sparse L1 L2)
    (define (iter L1 L2)
      (cond ((empty-termlist? L1) L2)
            ((empty-termlist? L2) L1)
            (else
             (let ((t1 (first-term L1)) (t2 (first-term L2)))
               (cond ((> (order t1) (order t2))
                      (adjoin-term
                       t1 (iter (rest-terms L1) L2)))
                     ((< (order t1) (order t2))
                      (adjoin-term
                       t2 (iter L1 (rest-terms L2))))
                     (else
                      (adjoin-term
                       (make-term (order t1)
                                  (- (coeff t1) (coeff t2)))
                       (iter (rest-terms L1)
                             (rest-terms L2)))))))))
    (iter L1 (change-sign-sparse L2)))

  (define L1-sparse '((3 1) (2 2) (0 -5)))
  (define L2-sparse '((4 4) (2 5) (0 -6)))

  (sub-terms L1-sparse L2-sparse)
#+END_SRC

Вариант для плотного представления полиномов.

#+BEGIN_SRC scheme
  ;; необходима для корректного добавления термов к списку термов плотного полинома
  (define (adjoin-term-dense term term-list)
    (if (=zero? (car term))
        term-list
        (append term term-list)))

  (define (sub-terms-dense L1 L2)
    (define (iter L1 L2)
      (cond ((empty-termlist? L1) L2)
            ((empty-termlist? L2) L1)
            (else
             (cond ((> (order (car L1) L1) (order (car L2) L2))
                    (adjoin-term-dense
                     (car L1) (iter (rest-terms L1) L2)))
                   ((< (order (car L1) L1) (order (car L2) L2))
                    (adjoin-term-dense
                     (car L2) (iter L1 (rest-terms L2))))
                   (else
                    (adjoin-term-dense
                     (make-term-dense (- (car L1) (car L2)))
                     (iter (rest-terms L1)
                           (rest-terms L2))))))))
    (iter L1 (change-sign-dense L2)))

#+END_SRC

Обобщенная процедура:

#+BEGIN_SRC scheme
  ;; кладем написанные процедуры в таблицу
  (put 'sub-terms '(dense dense) sub-terms-dense)
  (put 'sub-terms '(sparse sparse) sub-terms=sparse)

  (define (sub-terms .args )
    (apply-generic 'sub-terms args))
#+END_SRC

~Упражнение 2.89.~
Определите процедуры, которые реализуют представление в виде списка
термов, описанное выше как подходящее для плотных многочленов.

В мане нам сказано, что плотные полиномы - т.е. полиномы, в которых
большинство термов имеют НЕ нулевой коэфициент - удобно представлять в
виде списка коэфициентов вида '( 5 3 1 -2 -5). А порядок терма - это длин
списка, начинающегося с коэфициента этого терма, уменььшенная на 1.

Значит, все селекторы и конструкторы, определенные для разреженных
полиномов, надо определить и для плотных.

#+BEGIN_SRC scheme

  (define (make-term coeff) (list coeff))

  ;; вариант №1
  ;; плох тем, что нужно знать индекс терма в списке коэфициентов. А индекс - это уже почти
  ;; порядок терма
  (define (order idx-of-term term-list)
    (- (length term-list) idx-of-term))

  ;; вариант №2
  ;; плох тем, что если у двух термов окажутся одинаковые коэфиициенты, то
  ;; процедура венет порядок первого встретившегося терма с такми коэфициентом
  (define (order coeff term-list)
    (define (iter coeff term-list order)
      (cond ((null? term-list) #f)
            ((= (car term-list) coeff) order)
            (else (iter coeff (cdr term-list) (+ order 1)))))
    (iter coeff (reverse term-list) 0))

  ;; возвращает коэфициент терма
  (define (coeff term-order term-list)
    (if (>= term-order (length term-list))
        #f
    (list-ref (reverse term-list) term-order)))

  (define coeff-test '( 1 2 0 3 -2 -5))

  ;; (coeff 3 coeff-test)
  w;; (order -5 coeff-test)

  ;; эти процедуры годятся и для протного представления многочленов

  ;; получаем самый терм самого высокого порядка из списка термов
  ;; термы всегда отсортированны по их порядкам от бОльшего к меньшему
  (define (first-term term-list) (car term-list))

  ;; возвращает все термы, кроме терма в самым высоким порядком
  (define (rest-terms term-list) (cdr term-list))

  ;; проверяет список термов на наличие в нем термов
  (define (empty-termlist? term-list) (null? term-list))

#+END_SRC

~Упражнение 2.90.~
Допустим, что мы хотим реализовать систему многочленов, которая
эффективна как для плотных, так и для разреженных многочленов.
Один из способов это сделать заключается в том, чтобы разрешить в системе
оба типа представления. Ситуация аналогична примеру с комплексными
числами из раздела 2.4, где мы позволили сосуществовать декартову и полярному
представлению. Чтобы добиться этого, нам придется различать виды списков
термов и сделать операции над списками термов
обобщенными. Перепроектируйте систему с многочленами так, чтобы
это обобщение было реализовано.
Это потребует большого труда, а не только локальных изменений.

Возможно, одинаковые процедуры для 2х пакетов не стоило дублировать и
класть дважды в таблицу операций под разными типами, но с другой
стороны,вдруг появятся еще какие-то представления полиномов и для них
понадобятся другие операции?

#+BEGIN_SRC scheme
  ;; создаем пакет для плотного представления полиномов
  (define (install-dense-package)

    (define (make-term-dense coeff) (list coeff))

    (define (order-dense coeff term-list)
      (define (iter coeff term-list order)
        (cond ((null? term-list) #f)
              ((= (car term-list) coeff) order)
              (else (iter coeff (cdr term-list) (+ order 1)))))
      (iter coeff (reverse term-list) 0))

    (define (coeff-dense term-order term-list)
      (if (>= term-order (length term-list))
          #f
          (list-ref (reverse term-list) term-order)))

    (define (first-term-dense term-list) (car term-list))

    (define (rest-terms-dense term-list) (cdr term-list))

    (define (empty-termlist?-dense term-list) (null? term-list))

    (define (make-poly-dense variable term-list)
      (cons variable term-list))

    (define (variable?-dense x) (symbol? x))

    (define (same-variable?-dense v1 v2)
      (and (variable? v1) (variable? v2) (eq? v1 v2)))

    (define (variable-dense p) (car p))

    (define (term-list-dense p) (cdr p))

    (define (tag p) (attach-tag 'dense p))

    (put 'make-term tag make-term-dense)
    (put 'order tag order-dense)
    (put 'coeff tag coeff-dense)
    (put 'rest-terms tag rest-terms-dense)
    (put 'first-term tag first-term-dense)
    (put 'empty-termlist? tag empty-termlist?-dense)
    (put 'make-poly tag make-poly-dense)
    (put 'variable? tag variable?-dense)
    (put 'same-variable? tag same-variable?-dense)
    (put 'variable tag variable-dense)
    (put 'term-list tag term-list-dense)

    'done
    )

  ;; создаем пакет для разреженного представления полиномов

  (define (install-sparse-package)

    (define (make-term-sparse order coeff) (list order coeff))

    (define (order-sparse term) (car term))

    (define (coeff-sparse term) (cadr term))

    (define (first-term-sparse term-list) (car term-list))

    (define (rest-terms-sparse term-list) (cdr term-list))

    (define (empty-termlist?-sparse term-list) (null? term-list))

    (define (make-poly-sparse variable term-list)
      (cons variable term-list))

    (define (variable?-sparse x) (symbol? x))

    (define (same-variable?-sparse v1 v2)
      (and (variable? v1) (variable? v2) (eq? v1 v2)))

    (define (variable-sparse p) (car p))

    (define (term-list-sparse p) (cdr p))

    (define (tag p) (attach-tag 'sparse p))

    (put 'make-term tag make-term-sparse)
    (put 'order tag order-sparse)
    (put 'coeff tag coeff-sparse)
    (put 'rest-terms tag rest-terms-sparse)
    (put 'first-term tag first-term-sparse)
    (put 'empty-termlist? tag empty-termlist?-sparse)
    (put 'make-poly tag make-poly-sparse
    (put 'variable? tag variable?-sparse)
    (put 'same-variable? tag same-variable?-sparse)
    (put 'variable tag variable-sparse)
    (put 'term-list tag term-list-sparse)

    'done
    )

  ;; добавляем процедуры к уже существующим в пакете
  (define (install-polynomial-package)

    (define (make-poly  variable term-list)
      (apply-generic 'make-poly variable term-list))

    (define (variable?  x)
      ((apply-generic 'variable? type) x))

    (define (same-variable?  v1 v2)
      (apply-generic 'same-variable? v1 v2))

    (define (variable p)
      (apply-generic 'same-variable? p))

    (define (term-list p)
      (apply-generic 'term-list p))

    (define (coeff .args)
      (apply-generic 'coeff args))

    (define (order .args)
      (apply-generic 'order args))

    (define (first-term term-list)
      (apply-generic 'first-term term-list))

    (define (rest-terms term-list)
      (apply-generic 'rest-terms term-list))

    (define (empty-termlist? term-list)
      (apply-generic 'empty-termlist? term-list))

    ;; здесь идут определения не изменившихся процедур
    ;; <...>

    (put 'coeff 'polynomial coeff)
    (put 'order 'polynomial order)
    ;; кладем дальше прочие операции по лекалу
    ;; <...>

    'done)

#+END_SRC

~Упражнение 2.91~

Доопределить процедуру, которая делит два полинома один на другой.

Деление можно производить в столбик. А именно, разделим старший член
делимого на старший член делителя. В результате получится первый терм частного. Затем
умножим результат на делитель, вычтем получившийся многочлен из делимого
и, рекурсивно деля разность на делитель, получим оставшуюся часть
частного.
Останавливаемся, когда порядок делителя превысит порядок делимого, и
объявляем остатком то, что тогда будет называться делимым. Кроме того, если
когда-нибудь делимое окажется нулем, возвращаем ноль в качестве и
частного, и остатка.
Процедуру ~div-poly~ можно разработать, следуя образцу ~add-poly~ и
mul-poly. Процедура проверяет, одна ли и та же у многочленов переменная. Если это так,
div-poly откусывает переменную и передает задачу в div-terms, которая
производит операцию деления над списками термов. Наконец, div-poly
прикрепляет переменную к результату, который выдает div-terms.
Удобно сделать так, чтобы div-terms выдавала и частное, и остаток при
делении. Она может брать в качестве аргументов два терма и выдавать список, состоящий из
списка термов частного и списка термов остатка.

Итак, алгоритм деления:
- берем старший терм делимого и делим его на старший терм делителя,
  результат = первый терм частного. Умножаем результат на
  делитель. Получившееся произведение вычитаем из исходного
  полинома-делимого. Получившуюся разность снова делим на делитель и
  повторяем весь алгоритм. Итак до тех пор, пока порядок делителя не
  привысит порядок делимого и тогда возвращаем текущее делимое как
  остаток и получившийся список частных. Если же на какой-то итерации
  делимое стало нулем, возвращаем ноль и как частное, и как остаток.

Тестирования нет, посольку функция универсальна для обоих представлений
полиномов, т.е. нам нужны обобенные функции, которые мы не можем
использовать из-за отсутствия таблиц операций.
#+BEGIN_SRC scheme
  (define (div-terms L1 L2)
    ;; если делимое - пустой список
    (if (empty-termlist? L1)
        ;; возвращаем пустые списки как частное и как остаток
        (list (the-empty-termlist) (the-empty-termlist))
        ;; иначе получаем первые термы делимого и делителя
        (let ((t1 (first-term L1))
              (t2 (first-term L2)))
          ;; если порядок делителя превышает порядок делимого
          (if (> (order t2) (order t1))
              ;; тогда возвращаем пустой список в качетсве частного и делимое в качестве
              ;; остатка
              (list (the-empty-termlist) L1)
              ;; иначе делим старший терм делимого на старший терм делителя
              (let ((new-c (div (coeff t1) (coeff t2)))
                    (new-o (- (order t1) (order t2))))
                (let ((rest-of-result
                       ;; рекурсивно вычисяем оставшуюся часть результата
                       ;; если коэфициент нулевой, значит, делимое превратится в 0
                       (if (=zero? new-c)
                           ;; возвращаем 0 как остаток и частное
                           (list 0 0)
                           ;; иначе
                           ;; умножаем текущее частное на делитель, вычитаем из делимого
                           ;; разность передаем в рекурсивный вызов как новое делимое
                           (div-terms (sub-terms L1 (mul-term-by-all-terms (make-term new-o new-c) L2))
                                      L2))))
                  ;; сформировать окончательный результат
                  ;; после выполнения рекурсии откатимся по стеку назад, так в переменных
                  ;; new-c и new-o окажутся самые первые значения частного, соединим их
                  ;; с оставшейся частью частного, так получим все частное целиком
                  (list (adjoin-term (make-term new-c new-o) (car rest-of-result))
                        ;; объединим частное и остаток в список
                        (cadr rest-of-result))
                  ))))))

  (define (div-poly poly1 poly2)
    (let ((var1 (variable poly1))
          (var2 (variable poly2)))
      ;; проверяем переменные на одинаковость
      (if (same-variable? var1 var2)
          ;; делим список термов один на другой
          (div-terms (term-list poly1) (term-list poly2))
          ;; иначе сообщение об ошибке
          (error "Переменные не одинаковые" var1 var2))))

#+END_SRC

~Упражнение 2.93.~
Модифицируйте пакет арифметики рациональных чисел, заставив его
пользоваться обобщенными операциями, но при этом измените make-rat,
чтобы она не пыталась сокращать дроби. Проверьте систему, применив
make-rational к двум многочленам, и получив рациональную функцию, сложите
ее с собой же, используя add.

#+BEGIN_SRC scheme
  (define (install-rational-package)
    ;; внутренние процедуры
    (define (numer x) (car x))
    (define (denom x) (cadr x))
    ;; просто создаем пару из числителя и знаменателя, раз теперь не надо сокраать дроби
    (define (make-rat n d)
      (list n d))
    ;; в качестве арифметических предикатов будем использовать обобщенные операции
    (define (add-rat x y)
      (make-rat (add (mul (numer x) (denom y))
                   (mul (numer y) (denom x)))
                (mul (denom x) (denom y))))
    (define (sub-rat x y)
      (make-rat (sub (mul (numer x) (denom y))
                   (mul (numer y) (denom x)))
                (mul (denom x) (denom y))))
    (define (mul-rat x y)
      (make-rat (mul (numer x) (numer y))
                (mul (denom x) (denom y))))
    (define (div-rat x y)
      (make-rat (mul (numer x) (denom y))
                (mul (denom x) (numer y))))
    ;; интерфейс к остальной системе
    (define (tag x) (attach-tag ’rational x))
    (put 'add '(rational rational)
          (lambda (x y) (tag (add-rat x y))))
    (put 'sub '(rational rational)
          (lambda (x y) (tag (sub-rat x y))))
    (put 'mul '(rational rational)
          (lambda (x y) (tag (mul-rat x y))))
    (put 'div '(rational rational)
          (lambda (x y) (tag (div-rat x y))))
    (put 'make 'rational
          (lambda (n d) (tag (make-rat n d))))
    ’done)

  (define (make-rational n d)
    ((get 'make 'rational) n d))


  ;; ради теста эмулируем необхдимые процедуры, чтоб не пользоваться таблицами операций
  ;; настоятельно рекомендуется залить в интерпретатор все функции из раздела
  ;; "шпаргалкадля операций над многочленам"
  (define (make-rational n d)
    (make-rat n d))

  (define (make-polynomial var terns)
    (make-poly var terns))

  ;; определим тестовые примеры
  (define p1 (make-polynomial 'x '((2 1)(0 1))))
  (define p2 (make-polynomial 'x '((3 1)(0 1))))
  (define rf (make-rational p2 p1))
#+END_SRC

Предположим, нам удалось сложить rf с самой собой, и мы увидели, что
процедура сложения не сократила дробь. Чтоб это сделать, надо
модифицировать ~make-rat~, чтоб онв делила числитель и знаменатель на их
наиобльший общий делитель (НОД). Алгоритм Евклида сработает и для
многочленов.

#+BEGIN_SRC scheme
  ;; версия для целых чисел
  (define (gcd-integer a b)
    (if (= b 0)
        a
        (gcd-integer b (remainder a b))))

  ;; версия для термов
  (define (gcd-terms a b)
    (if (empty-termlist? b)
        a
        (gcd-terms b (remainder-terms a b))))

  ;; модицифицированная версия make-rat
  (define (make-rat n d)
    (let ((g (gcd-terms n d)))
      (cons (/ n g) (/ d g))))
#+END_SRC

~Упражнение 2.94.~
Используя ~div-terms~, напишите процедуру ~remainder-terms~, и с ее помощью
определите ~gcd-terms~, как показано выше. Напишите теперь процедуру ~gcd-polys~,
которая вычисляет НОД двух многочленов.
(Процедура должна сообщать об ошибке, если входные объекты являются
многочленами от разных переменных.) Установите в систему обобщенную
операцию greatest-common-divisor, которая для многочленов сводится к gcd-poly, а для
обыкновенных чисел к обыкновенному gcd.

Процедура ~div-terms~ определена в упр. 2.91 и возвращает список, ~car~
которого - частное от деления термов, а ~cdr~ - остаток от деления.

Нас просят протестировать пример, но без функционирующей таблицы операций
это не сделать.

#+BEGIN_SRC scheme
  ;; возвращает остаток от деления термов друг на друга
  (define (remainder-terms L1 L2)
    (cadr (div-terms L1 L2)))

  (define (gcd-terms a b)
    (if (empty-termlist? b)
        a
        (gcd-terms b (remainder-terms a b))))

  (define (gcd-polys poly1 poly2)
    (let ((var1 (variable poly1))
          (var2 (variable poly2)))
      ;; проверяем переменные на одинаковость
      (if (same-variable? var1 var2)
          ;; делим список термов один на другой
          (gcd-terms (term-list poly1) (term-list poly2))
          ;; иначе сообщение об ошибке
          (error "Переменные не одинаковые" var1 var2))))

  (define (gcd-integer a b)
    (if (= b 0)
        a
        (gcd-integer b (remainder a b))))

  ;; положим обе функции в таблицу операций
  (put 'gcd '(integer integer) gcd-integer)
  (put 'gcd '(polynomial polynomial) gcd-polys)

  (define (greatest-common-divisor args)
    (apply-generic 'gcd args))

#+END_SRC

~Упражнение 2.95~

Пусть P1 , P2 и P3 – многочлены.
P1: x^2 − 2x + 1
P 2 : 11x^2 + 1
P 3 : 13x + 5

Процедуры по нахождению НОД не будут работать, если числа станут дробными
(или коэфициенты многочленов станут дробями).

Теперь пусть Q 1 будет произведение P 1 и P 2 , а Q 2 произведение P 1 и
P 3 . При помощи ~greatest-common-divisor~ (упражнение 2.94) вычислите
НОД Q1 и Q2 .
Обратите внимание, что ответ не совпадает с P1 . Этот пример вводит в
вычисление операции с нецелыми числами, и это создает сложности для
алгоритма вычисления НОД. Чтобы понять, что здесь происходит, попробуйте
включить трассировку в ~gcd-terms~ при вычислении НОД либо проведите
деление вручную.

Попробуем проследить процесс вручную. У нас есть многочлены Q1 и Q2.
Q1: 11x^4 - 22x^3 + 12x^2 -2x + 1
Q2: 13^3 - 21x^2 + 3x +5

При попытке поделить коэфициенты первого полинома, на коэфициенты
второго, мы будем полчать дробные числа в виде рациональных дробей или же
десятичных. Ни с тем, ни с другим представлением дробей ~gcd~ работать не
умеют. Хотя автор утверждает, что это будет приводить всего лишь к
неверному представлению НОД, целочисленный вариант gcd просто выдает
ошибку и отказывается работать, если ему передать две дроби в качестве аргументов.

~Упражнение 2.96.~
а). Напишите процедуру ~pseudoremainder-terms~, которая работает в точности
как ~remainder-terms~, но только прежде, чем позвать ~div-terms~, домножает делимое на
множитель целости, описанный выше. Модифицируйте ~gcd-terms~ так, чтобы она использовала
~pseudoremainder-terms~, и убедитесь, что теперь в примере из упражнения 2.95
~greatest-common-divisor~ выдает ответ с целыми коэффициентами.
б. Теперь у НОД целые коэффициенты, но они больше, чем коэффициенты P1.
Измените ~gcd-terms~, чтобы она убирала общий множитель из коэффициентов ответа путем
деления всех коэффициентов на их (целочисленный) НОД.

Возьмем порядок старшего терма Q1, назовем его O. Возьмем порядок
старшего терма Q2 и назовем его О2. Возьмем коэффициент старшего терма Q2
и назвем его К. ~Множитель целостности - это K в степени 1 + О1 - О2~.
Если домножить Q1 на множитель целостности, а потом разделить Q1 на Q2,
мы полчим результат, в котором у коэффициентов нет никаких дробей.

#+BEGIN_SRC scheme
  ;; подгоним необходимые процедуры под ситуацию, когда таблиц операций у нас нет
  (define (sub-terms-sparse L1 L2)
    (define (iter L1 L2)
      (cond ((empty-termlist? L1) L2)
            ((empty-termlist? L2) L1)
            (else
             (let ((t1 (first-term L1)) (t2 (first-term L2)))
               (cond ((> (order t1) (order t2))
                      (adjoin-term
                       t1 (iter (rest-terms L1) L2)))
                     ((< (order t1) (order t2))
                      (adjoin-term
                       t2 (iter L1 (rest-terms L2))))
                     (else
                      (adjoin-term
                       (make-term (order t1)
                                  (- (coeff t1) (coeff t2)))
                       (iter (rest-terms L1)
                             (rest-terms L2)))))))))
    (iter L1 (change-sign-sparse L2)))

  (define (div-terms L1 L2)
    (if (empty-termlist? L1)
        (list (the-empty-termlist) (the-empty-termlist))
        (let ((t1 (first-term L1))
              (t2 (first-term L2)))
          (format #t "div-terms: L1 ~A L2 ~A\n" L1 L2)
          (format #t "div-terms: t1 ~A t2 ~A\n" t1 t2)
          (if (> (order t2) (order t1))
              (list (the-empty-termlist) L1)
              (let* ((new-c (/ (coeff t1) (coeff t2)))
                    (new-o (- (order t1) (order t2)))
                    (new-term (make-term new-o new-c)))
                (format #t "div-terms: new-term ~A\n" new-term)
                (if (or (=zero? new-c) (< new-c 0.000001))
                    (list 0 0)
                (let ((rest-of-result
                       (div-terms (sub-terms-sparse
                                   L1
                                   (mul-term-by-all-terms new-term L2))
                                  L2)))
                  (list (adjoin-term (make-term new-c new-o) (car rest-of-result))
                        (cadr rest-of-result))
                  )))))))


  (define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else
           (let ((t1 (first-term L1)) (t2 (first-term L2)))
             (cond ((> (order t1) (order t2))
                    (adjoin-term
                     t1 (add-terms (rest-terms L1) L2)))
                   ((< (order t1) (order t2))
                    (adjoin-term
                     t2 (add-terms L1 (rest-terms L2))))
                   (else
                    (adjoin-term
                     (make-term (order t1)
                                (+ (coeff t1) (coeff t2)))
                     (add-terms (rest-terms L1)
                                (rest-terms L2)))))))))

  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist)
        (let ((t2 (first-term L)))
          (adjoin-term
           (make-term (+ (order t1) (order t2))
                      (* (coeff t1) (coeff t2)))
           (mul-term-by-all-terms t1 (rest-terms L))))))

  ;; (процедуры, данные в мане, которые мы слегка переработали выше, работают именно с ним,
  ;; поэтому несмотря на то, что полиномы плотные, будем использовать это представление)
  (define P1 (make-poly 'x '((2 1) (1 -2) (0 1))))
  (define P2 (make-poly 'x '((2 11) (0 1))))
  (define P3 (make-poly 'x '((1 13) (0 5))))

  (define Q2 (mul-poly P1 P3))
  (define Q1 (mul-poly P1 P2))
#+END_SRC

Определим процедуру, которая возвращает множитель целостности, если
передать ей 2 списка термов.

#+BEGIN_SRC scheme
  (define (integerizing-factor L1 L2)
    (let* ((t1 (first-term L1))
           (t2 (first-term L2)))
      (expt (coeff t2) (- (+ 1 (order t1)) (order t2))))))

  (define test (integerizing-factor (term-list Q1) (term-list Q2)))

#+END_SRC

а).
#+BEGIN_SRC scheme
  (define (pseudoremainder-terms L1 L2)
    (cadr (div-terms (mull-by-all-terms
                      (make-term 0 (integerizing-factor L1 L2)) L1)
                     L2)))

  (define (gcd-terms a b)
    (if (empty-termlist? b)
        a
        (gcd-terms b (pseudoremainder-terms a b))))
#+END_SRC

б).Теперь у НОД целые коэффициенты, но они больше, чем коэффициенты P1.
Измените ~gcd-terms~, чтобы она убирала общий множитель из коэффициентов ответа путем
деления всех коэффициентов на их (целочисленный) НОД.

Если мы все числа умножали на множитель целостности, значит, можем на
него же и разделить, получив исходные коээффициенты таким образом.
#+BEGIN_SRC scheme
  (define (reduce-coeff terms-list factor)
    (if (null? terms-list)
        '()
        (adjoin-term (make-term (order (first-term terms-list))
                                (/ (coeff (first-term terms-list)) factor))
                     (reduce-coeff (cdr terms-list) factor))))

  (define (gcd-terms a b)
    ;; получили НОД термов
    (let ((g (if (empty-termlist? b)
                 a
                 (gcd-terms b (pseudoremainder-terms a b))))
          ;; получим множитель целостности для исходных списком термов
          (factor (integerizing-factor a b)))
          ;; сократили коэффициенты на множитель целостности
          (reduce-coeff g factor)))

#+END_SRC

~Упражнение 2.97~
а. Реализуйте этот алгоритм приведения рациональную функцию к наименьшему
знаменателю как процедуру ~reduce-terms~, которая принимает
в качестве аргументов два списка термов n и d и возвращает список из nn и dd,
которые представляют собой n и d, приведенные к наименьшему знаменателю.
Напишите, кроме того, процедуру ~reduce-poly~, подобную ~add-poly~,
которая проверяет, чтобы два poly имели одну и ту же переменную. Если это
так, ~reduce-poly~ откусывает эту переменную и передает оставшуюся часть
задачи в reduce-terms, а затем прикрепляет переменную обратно к двум
спискам термов, которые получены из reduce-terms.

б. Определите процедуру, аналогичную ~reduce-terms~, которая делает то, что
делала для целых чисел исходная ~make-rat~. и определите reduce как
обобщенную операцию, которая вызывает apply-generic и диспет-
чирует либо к ~reduce-poly~ (если аргументы — многочлены), либо к ~reduce-integers~ (для
аргументов типа scheme-number). Теперь Вы легко можете заставить пакет
рациональной арифметики приводить дроби к наименьшему знаменателю,
потребовав от make-rat звать ~reduce~ прежде, чем сочетать данные
числитель и знаменатель в процессе порождению рационального числа.

а.
- запустить ~gcd-terms~ для нахождения НОД числителя и знаменателя
- найти множитель целостности: старший коэфициент НОД, возведенный в
  степень 1 + О1 - О2, где O2 – порядок НОД, а O1 — максимум из порядков
  числителя и знаменателя.
- умножить числитель и знаменатель на множитель целостности
- поедлить числитель и наменатль на нод
- редуцировать коэфициенты числителя и знаменателя

#+BEGIN_SRC scheme
  (define (reduce-terms n d)
    ;; получили НОД
    (let* ((g (gcd-terms n d))
           ;; получили старший коэффциент НОД-а
           (k (coeff (first-term g)))
           ;; получаем старший из порядков числителя или знаменателя
           (O1 (if (>= (order (first-term n)) (order (first-term n)))
                   (order (first-term n))
                   (order (first-term n))))
           ;; получаем старший порядок НОД-а
           (O2 (order (first-term g)))
           ;; получаем множитель целостности
           (factor (expt K ( - (+ 1 O1) O2)))
           ;; создаем из него новый терм
           (new-term (make-term 0 factor)))
      ;; умножаем числитель и заменатель на множитель целостности,
      ;; делим на НОД, редуцируем коэффициенты, оборачиваем результат в список
      (list (reduce-coeff (/ (mul-term-by-all-terms new-term n) g) factor)
            (reduce-coeff (/ (mul-term-by-all-terms new-term d) g) factor))))

  (define (reduce-poly poly1 poly2)
    (let ((var1 (variable poly1))
          (var2 (variable poly2)))
      ;; проверяем переменные на одинаковость
      (if (same-variable? var1 var2)
           ;; вызываем основную функцию
          (reduce-terms (term-list poly1) (term-list poly2))
          ;; иначе сообщение об ошибке
          (error "Переменные не одинаковые" var1 var2))))

#+END_SRC

б.
Определите процедуру, аналогичную ~reduce-terms~, которая делает то, что
делала для целых чисел исходная ~make-rat~. и определите reduce как
обобщенную операцию, которая вызывает apply-generic и диспет-
чирует либо к ~reduce-poly~ (если аргументы — многочлены), либо к ~reduce-integers~ (для
аргументов типа scheme-number). Теперь Вы легко можете заставить пакет
рациональной арифметики приводить дроби к наименьшему знаменателю,
потребовав от make-rat звать ~reduce~ прежде, чем сочетать данные
числитель и знаменатель в процессе порождению рационального числа.

#+BEGIN_SRC scheme
  (define (reduce-integers n d)
    (let ((g (gcd-integers n d)))
      (list (/ n g) (/ d g))))

  (put 'reduce '(scheme-number scheme-number) reduce-integers)
  (put 'reduce '(polynomial polynomial) reduce-poly)

  (define (reduce args)
    (apply-generic 'reduce args))
#+END_SRC
