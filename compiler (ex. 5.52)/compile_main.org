#+STARTUP: showall indent hidestars

Пример компилятора из сикпа, который компилируют код из схемы в
псевдо-ассемблер (язык вычислителя с явным управлением из того же сикпа)

  #+BEGIN_SRC scheme
    (define (compile exp target linkage)
      (cond ((self-evaluating? exp)
             (compile-self-evaluating exp target linkage))
            ((quoted? exp) (compile-quoted exp target linkage))
            ((variable? exp)
             (compile-variable exp target linkage))
            ((assignment? exp)
             (compile-assignment exp target linkage))
            ((definition? exp)
             (compile-definition exp target linkage))
            ((if? exp) (compile-if exp target linkage))
            ((lambda? exp) (compile-lambda exp target linkage))
            ((begin? exp)
             (compile-sequence (begin-actions exp)
                               target
                               linkage))
            ((cond? exp) (compile (cond->if exp) target linkage))
            ((application? exp)
             (compile-application exp target linkage))
            (else
             (error "Неизвестный тип выражения -- COMPILE" exp))))

    (define (compile-linkage linkage)
      (cond ((eq? linkage ’return)
             (make-instruction-sequence '(continue) '()
                                         '((goto (reg continue)))))
            ((eq? linkage 'next)
             (empty-instruction-sequence))
            (else
             (make-instruction-sequence '() '()
                                         `((goto (label ,linkage)))))))

    (define (end-with-linkage linkage instruction-sequence)
      (preserving '(continue)
                   instruction-sequence
                   (compile-linkage linkage)))

    (define (compile-self-evaluating exp target linkage)
      (end-with-linkage linkage
                        (make-instruction-sequence '() (list target)
                                                    `((assign ,target (const ,exp))))))
    (define (compile-quoted exp target linkage)
      (end-with-linkage linkage
                        (make-instruction-sequence
                         '() (list target)
                         `((assign ,target
                                   (const ,(text-of-quotation exp)))))))

    (define (compile-variable exp target linkage)
      (end-with-linkage linkage
                        (make-instruction-sequence '(env) (list target)
                                                    `((assign ,target
                                                              (op lookup-variable-value)
                                                              (const ,exp)
                                                              (reg env))))))

    (define (compile-assignment exp target linkage)
      (let ((var (assignment-variable exp))
            (get-value-code
             (compile (assignment-value exp) 'val 'next)))
        (end-with-linkage linkage
                          (preserving '(env)
                                       get-value-code
                                       (make-instruction-sequence
                                        '(env val) (list target)
                                        `((perform (op set-variable-value!)
                                                   (const ,var)
                                                   (reg val)
                                                   (reg env))
                                          (assign ,target (const ok))))))))

    (define (compile-definition exp target linkage)
      (let ((var (definition-variable exp))
            (get-value-code
             (compile (definition-value exp) 'val 'next)))
        (end-with-linkage linkage
                          (preserving '(env)
                                       get-value-code
                                       (make-instruction-sequence
                                        '(env val) (list target)
                                        `((perform (op define-variable!)
                                                   (const ,var)
                                                   (reg val)
                                                   (reg env))
                                          (assign ,target (const ok))))))))


    (define (compile-if exp target linkage)
      (let ((t-branch (make-label 'true-branch))
            (f-branch (make-label 'false-branch))
            (after-if (make-label 'after-if)))
        (let ((consequent-linkage
               (if (eq? linkage 'next) after-if linkage)))
          (let ((p-code (compile (if-predicate exp) ’val ’next))
                (c-code
                 (compile
                  (if-consequent exp) target consequent-linkage))
                (a-code
                 (compile (if-alternative exp) target linkage)))
            (preserving '(env continue)
                         p-code
                         (append-instruction-sequences
                          (make-instruction-sequence '(val) '()
                                                      `((test (op false?) (reg val))
                                                        (branch (label ,f-branch))))
                          (parallel-instruction-sequences
                           (append-instruction-sequences t-branch c-code)
                           (append-instruction-sequences f-branch a-code))
                          after-if))))))

    (define (compile-sequence seq target linkage)
      (if (last-exp? seq)
          (compile (first-exp seq) target linkage)
          (preserving '(env continue)
                       (compile (first-exp seq) target 'next)
                       (compile-sequence (rest-exps seq) target linkage))))

    (define (compile-lambda exp target linkage)
      (let ((proc-entry (make-label 'entry))
            (after-lambda (make-label 'after-lambda)))
        (let ((lambda-linkage
               (if (eq? linkage 'next) after-lambda linkage)))
          (append-instruction-sequences
           (tack-on-instruction-sequence
            (end-with-linkage lambda-linkage
                              (make-instruction-sequence
                               '(env) (list target)
                               `((assign ,target
                                         (op make-compiled-procedure)
                                         (label ,proc-entry)
                                         (reg env)))))
            (compile-lambda-body exp proc-entry))
           after-lambda))))


    (define (make-compiled-procedure entry env)
      (list 'compiled-procedure entry env))

    (define (compiled-procedure? proc)
      (tagged-list? proc 'compiled-procedure))

    (define (compiled-procedure-entry c-proc) (cadr c-proc))

    (define (compiled-procedure-env c-proc) (caddr c-proc))

    (define (compile-lambda-body exp proc-entry)
      (let ((formals (lambda-parameters exp)))
        (append-instruction-sequences
         (make-instruction-sequence '(env proc argl) '(env)
                                     `(,proc-entry
                                       (assign env (op compiled-procedure-env) (reg proc))
                                       (assign env
                                               (op extend-environment)
                                               (const ,formals)
                                               (reg argl)
                                               (reg env))))
         (compile-sequence (lambda-body exp) 'val 'return))))

    (define (compile-application exp target linkage)
      (let ((proc-code (compile (operator exp) 'proc 'next))
            (operand-codes
             (map (lambda (operand) (compile operand 'val 'next))
                  (operands exp))))
        (preserving '(env continue)
                     proc-code
                     (preserving '(proc continue)
                                  (construct-arglist operand-codes)
                                  (compile-procedure-call target linkage)))))

    (define (construct-arglist operand-codes)
      (let ((operand-codes (reverse operand-codes)))
        (if (null? operand-codes)
            (make-instruction-sequence '() '(argl)
                                        '((assign argl (const ()))))
            (let ((code-to-get-last-arg
                   (append-instruction-sequences
                    (car operand-codes)
                    (make-instruction-sequence '(val) '(argl)
                                                '((assign argl (op list) (reg val)))))))
              (if (null? (cdr operand-codes))
                  code-to-get-last-arg
                  (preserving '(env)
                               code-to-get-last-arg
                               (code-to-get-rest-args
                                (cdr operand-codes))))))))

    (define (code-to-get-rest-args operand-codes)
      (let ((code-for-next-arg
             (preserving ’(argl)
                          (car operand-codes)
                          (make-instruction-sequence
                           '(val argl) '(argl)
                           '((assign argl
                                     (op cons) (reg val) (reg argl)))))))
        (if (null? (cdr operand-codes))
            code-for-next-arg
            (preserving '(env)
                         code-for-next-arg
                         (code-to-get-rest-args (cdr operand-codes))))))

    (define (compile-procedure-call target linkage)
      (let ((primitive-branch (make-label 'primitive-branch))
            (compiled-branch (make-label 'compiled-branch))
            (after-call (make-label 'after-call)))
        (let ((compiled-linkage
               (if (eq? linkage 'next) after-call linkage)))
          (append-instruction-sequences
           (make-instruction-sequence '(proc) '()
                                       `((test (op primitive-procedure?) (reg proc))
                                         (branch (label ,primitive-branch))))
           (parallel-instruction-sequences
            (append-instruction-sequences
             compiled-branch
             (compile-proc-appl target compiled-linkage))
            (append-instruction-sequences
             primitive-branch
             (end-with-linkage linkage
                               (make-instruction-sequence
                                '(proc argl)
                                (list target)
                                '((assign ,target
                                          (op apply-primitive-procedure)
                                          (reg proc)
                                          (reg argl)))))))
           after-call))))


    (define (compile-proc-appl target linkage)
      (cond ((and (eq? target 'val) (not (eq? linkage 'return)))
             (make-instruction-sequence '(proc) all-regs
                                         `((assign continue (label ,linkage))
                                           (assign val (op compiled-procedure-entry)
                                                   (reg proc))
                                           (goto (reg val)))))
            ((and (not (eq? target 'val))
                  (not (eq? linkage 'return)))
             (let ((proc-return (make-label 'proc-return)))
               (make-instruction-sequence '(proc) all-regs
                                          `((assign continue (label ,proc-return))

                                            (assign val (op compiled-procedure-entry)
                                                    (reg proc))
                                            (goto (reg val))
                                            ,proc-return
                                            (assign ,target (reg val))
                                            (goto (label ,linkage))))))
            ((and (eq? target 'val) (eq? linkage 'return))
             (make-instruction-sequence '(proc continue) all-regs
                                         '((assign val (op compiled-procedure-entry)
                                                   (reg proc))
                                           (goto (reg val)))))
            ((and (not (eq? target 'val)) (eq? linkage 'return))
             (error "Тип связи return, цель не val -- COMPILE"
                    target))))

    (define (append-instruction-sequences . seqs)
      (define (append-2-sequences seq1 seq2)
        (make-instruction-sequence
         (list-union (registers-needed seq1)
                     (list-difference (registers-needed seq2)
                                      (registers-modified seq1)))
         (list-union (registers-modified seq1)
                     (registers-modified seq2))
         (append (statements seq1) (statements seq2))))

      (define (append-seq-list seqs)
        (if (null? seqs)
            (empty-instruction-sequence)
            (append-2-sequences (car seqs)
                                (append-seq-list (cdr seqs)))))
      (append-seq-list seqs))

    (define (list-union s1 s2)
      (cond ((null? s1) s2)
            ((memq (car s1) s2) (list-union (cdr s1) s2))
            (else (cons (car s1) (list-union (cdr s1) s2)))))
    (define (list-difference s1 s2)
      (cond ((null? s1) ’())
            ((memq (car s1) s2) (list-difference (cdr s1) s2))
            (else (cons (car s1)
                        (list-difference (cdr s1) s2)))))

    (define (preserving regs seq1 seq2)
      (if (null? regs)
          (append-instruction-sequences seq1 seq2)
          (let ((first-reg (car regs)))
            (if (and (needs-register? seq2 first-reg)
                     (modifies-register? seq1 first-reg))
                (preserving (cdr regs)
                            (make-instruction-sequence
                             (list-union (list first-reg)
                                         (registers-needed seq1))
                             (list-difference (registers-modified seq1)
                                              (list first-reg))
                             (append `((save ,first-reg))
                                      (statements seq1)
                                      `((restore ,first-reg))))
                            seq2)
                (preserving (cdr regs) seq1 seq2)))))

    (define (tack-on-instruction-sequence seq body-seq)
      (make-instruction-sequence
       (registers-needed seq)
       (registers-modified seq)
       (append (statements seq) (statements body-seq))))

    (define (parallel-instruction-sequences seq1 seq2)
      (make-instruction-sequence
       (list-union (registers-needed seq1)
                   (registers-needed seq2))
       (list-union (registers-modified seq1)
                   (registers-modified seq2))
       (append (statements seq1) (statements seq2))))

    (define (registers-needed s)
      (if (symbol? s) '() (car s)))
    (define (registers-modified s)
      (if (symbol? s) '() (cadr s)))
    (define (statements s)
      (if (symbol? s) (list s) (caddr s)))

    (define (needs-register? seq reg)
      (memq reg (registers-needed seq)))

    (define (modifies-register? seq reg)
      (memq reg (registers-modified seq)))

  #+END_SRC


~Компиляция main~

Идея очень простая. Каждой сишной программе нужна входная точка - ~main~,
следовательно, любая скомпилированная программа должна иметь ~main~.

Я думаю, что при компиляции каждое выражение будет компилироваться внутри
отдельной процедуры, исполняться там, а затем его результат будет
возвращен в ~main~.

Таким образм выражение ~(define n 6)~ превратится в что-то вроде этого:

#+BEGIN_SRC c
  val* proc1() {
      int* number = (int*)malloc(sizeof(int));
      ,*number = 6;
      val* n = int_val_constructor(number);
      return n;
  }

  int main () {
      proc1();
  }
  #+END_SRC

Тем не менее нужно понять, вызывается ли определение из глобального
окружения или нет. От этого зависит каким образом будет компилироваться
код, ведь представленный выше вариант определит переменную локально.

Но начнем с простого - напишем фукцию, которая скомпилирует сишный main.

#+NAME: main
#+BEGIN_SRC scheme :noweb yes
  ;; преставление { и } в компилируемом коде
  ;; (define OPENING_BRACE 'OPENING_BRACE)
  ;; (define CLOSING_BRACE 'CLOSING_BRACE)

  (define OPENING_BRACE #\{)
  (define CLOSING_BRACE #\})

  ;; преставление ( и ) в компилируемом коде
  ;; (define OPENING_PARENTHESIS 'OPENING_PARENTHESIS)
  ;; (define CLOSING_PARENTHESIS 'CLOSING_PARENTHESIS)

  (define OPENING_PARENTHESIS #\()
  (define CLOSING_PARENTHESIS #\))

  ;; преставление [ и ] в компилируемом коде
  ;; (define OPENING_BRACKET 'OPENING_BRACKET)
  ;; (define CLOSING_BRACKET 'CLOSING_BRACKET)

  (define OPENING_BRACKET #\[)
  (define CLOSING_BRACKET #\])

  ;; преставление : и , в компилируемом коде
  (define СOLON #\:)
  (define COMMA #\,)

  ;; преставление * в компилируемом коде
  (define ASTERISK #\*)

  ;; преставление ; в компилируемом коде
  ;; (define SEMICOLON 'SEMICOLON)

  (define SEMICOLON #\;)

  ;; представление ... в компилируемом коде
  (define ELLIPSIS 'ELLIPSIS)

  ;; констуркторы, присоединяющие символы, эмулирующие синтакис, к скомпилированному коду
  (define(compile-braces code)
    (if (or (pair? code) (null? code))
        (append (list OPENING_BRACE)
                code
                (list CLOSING_BRACE))
        (append (list OPENING_BRACE)
                (list code)
                (list CLOSING_BRACE))))

  (define(compile-parenthesis code)
    (if (or (pair? code) (null? code))
        (append (list OPENING_PARENTHESIS)
                code
                (list CLOSING_PARENTHESIS))
        (append (list OPENING_PARENTHESIS)
                (list code)
                (list CLOSING_PARENTHESIS))))

  (define(compile-brackets code)
    (if (or (pair? code) (null? code))
        (append (list OPENING_BRACKET)
                code
                (list CLOSING_BRACKET))
        (append (list OPENING_BRACKET)
                (list code)
                (list CLOSING_BRACKET))))

  (define(compile-colon code)
    (append code
            (list COLON)))

  (define(compile-semicolon code)
    (append code
            (list SEMICOLON)))

  (define(compile-ellipsis code)
    (append code
            (list ELLIPSIS)))


  (define (compile-main fn-calls)
    (let ((code-into-braces (compile-braces fn-calls)))
      (append (list 'int 'main)
              (compile-parenthesis())
              code-into-braces)))


  ;; (list COMMA)

  (compile-main (append '(proc) (compile-parenthesis())))
  #+END_SRC

Надо решить несколько проблем:
- определять из какого окружения что будет вызываться
- генерировать уникальные имена для лямбд и служебных функций, которых в
  исходном коде нет, но они будут вызываться из main, и в них будет
  исполняться введенный код
- создать парсер, который будет переводить полученный список в строку

Генерация новых имен:
- получаем выражение
- переводим его в строку
- хешируем его, хэш = новое имя.
- сохраняем где-то этот хеш (возможно, присоединяем к выражению)

Данный функционал пригодится для сишного представления лямбд и вызова
прочих выражений, чтоб это не делать из мэйна.

#+NAME: list_string
#+BEGIN_SRC scheme :noweb yes
  ;; превращает выражение в строку
  (define (list->string lst)
    (define (rec-list->string lst retval-string)
      (if (null? lst)
          (string-append retval-string ")")
          (if (pair? (car lst))
              (begin
                (let (( result (string-append (rec-list->string (car lst) "(")
                                              (rec-list->string (cdr lst) ""))))
                  (string-append retval-string result)))
              (cond ((symbol? (car lst)) (rec-list->string (cdr lst)
                                                           (string-append retval-string
                                                                          (symbol->string
                                                                           (car lst)))))
                    ((number? (car lst)) (rec-list->string (cdr lst)
                                                           (string-append retval-string
                                                                          (number->string
                                                                           (car lst)))))
                    (else (rec-list->string (cdr lst)
                                            (string-append retval-string
                                                           "string" (car lst))))))))

    (rec-list->string lst "("))


  ;; тесты
  ;; (list->string '(1 2 3))

  ;; (list->string '(lambda (x) (+ x 1)))

  ;; (list->string '(define (factorial n)
  ;;                  (if (= n 0)
  ;;                      1
  ;;                      (* n (factorial (= n 1))))))

  ;; (list->string '(let ((a 3)
  ;;                      (b 4))
  ;;                  (+ 1 a b)))

  ;; (list->string '(1 2 "2"))

  ;; (list->string '(1 2 "(+ 1 2 )"))

  (define (exp->string exp)
    (list->string exp))

  ;; хэширует строку
  (define (hash-exp exp)
    (let ((string (exp->string exp)))
      (string-hash string)))

  ;; тесты
  ;; (hash-exp '(1 2 "(+ 1 2 )"))

  ;; (hash-exp '(let ((a 3)
  ;;                  (b 4))
  ;;              (+ 1 a b)))

  ;; (hash-exp '(let ((a 3)
  ;;                  (b 4))
  ;;              (+ 1 a b)))

  ;; (hash-exp '(define (factorial n)
  ;;              (if (= n 0)
  ;;                  1
  ;;                  (* n (factorial (= n 1))))))

  ;; создает "имя" для выражения
  (define (generate-name-string exp)
    (format #t "generate-name-string: ~A ~%" exp)
    (let* ((hash (hash-exp exp))
           (hash-string (number->string hash)))
      ;; добавляем букву, чтоб си в будущем счел хэш именем, а не числом
      (string-append "a" hash-string)))


  ;; (generate-name-string
  ;;  '(define (factorial n)
  ;;     (if (= n 0)
  ;;         1
  ;;         (* n (factorial (= n 1))))))

  ;; (generate-name-string
  ;;  '(1 2 2))

  ;; (generate-name-string
  ;;  '(1 2 "2"))
 #+END_SRC

Данный код будет генерировать код для служебных функций. Таких
функций нет в изначальном коде, но они будут компилироваться, чтоб не
пришлось все выражения компилировать в мэйн.

Служебная функция вызывается без аргументов.
#+NAME: service_procedure
#+BEGIN_SRC scheme :noweb yes
  (define (compile-service-fn name body)
    (let ((code-into-braces (compile-braces body)))
      (append (list 'val ASTERISK name)
              (compile-parenthesis '())
              code-into-braces)))
#+END_SRC


#+NAME: syntax_procs
#+BEGIN_SRC scheme :noweb yes
  (define (variable? exp) (symbol? exp))

  (define (quoted? exp)
    (tagged-list? exp 'quote))

  (define (text-of-quotation exp) (cadr exp))

  (define (tagged-list? exp tag)
    (if (pair? exp)
        (eq? (car exp) tag)
        false))

  (define (assignment? exp)
    (tagged-list? exp 'set!))

  (define (assignment-variable exp) (cadr exp))

  (define (assignment-value exp) (caddr exp))

  (define (definition? exp)
    (tagged-list? exp 'define))

  (define (definition-variable exp)
    (if (symbol? (cadr exp))
        (cadr exp)
        (caadr exp)))

  (define (definition-value exp)
    (if (symbol? (cadr exp))
        (caddr exp)
        (make-lambda (cdadr exp)
                     (cddr exp))))

  (define (lambda? exp) (tagged-list? exp 'lambda))

  (define (lambda-parameters exp) (cadr exp))

  (define (lambda-body exp) (cddr exp))

  (define (make-lambda parameters body)
    (cons 'lambda (cons parameters body)))

  (define (if? exp) (tagged-list? exp 'if))

  (define (if-predicate exp) (cadr exp))

  (define (if-consequent exp) (caddr exp))

  (define (if-alternative exp)
    (if (not (null? (cdddr exp)))
        (cadddr exp)
        'false))

  (define (make-if predicate consequent alternative)
    (list 'if predicate consequent alternative))

  (define (begin? exp) (tagged-list? exp 'begin))

  (define (begin-actions exp) (cdr exp))

  (define (last-exp? seq) (null? (cdr seq)))

  (define (first-exp seq) (car seq))

  (define (rest-exps seq) (cdr seq))

  (define (sequence->exp seq)
    (cond ((null? seq) seq)
          ((last-exp? seq) (first-exp seq))
          (else (make-begin seq))))

  (define (make-begin seq) (cons 'begin seq))

  (define (application? exp) (pair? exp))

  (define (operator exp) (car exp))

  (define (operands exp) (cdr exp))

  (define (no-operands? ops) (null? ops))

  (define (first-operand ops) (car ops))

  (define (rest-operands ops) (cdr ops))
#+END_SRC

~Построение окружений~

Они нужны только для того, чтоб компилятор мог отслеживать, в каком месте
появляется переменная и определена ли она была вообще. Получается, что
данные "окружения" будут состоять только из имен переменных без их
значений, поскольку на этапе компиляции значения не играют никакой роли.
Максимум можно указывать какого именно типа переменная - функция, число и
т.д., поскольку мы компилим код для си. Но это необязательно.

Окружения будут иметь списковую структуру как в сикпе, только если в
сикпе кадр состояит из двух списков, где первый список - это имена
переменных, а второй - это их значения, то мои псевдоокружения будут
состоять из кадров, которые будут содержать только имена переменных. Чем
ближе кадр к концу списка кадров, тем ближе он к глобальной области видимости.

То есть в окружении ((d f g h) (n test-fn factorial) (primitives-proc-names))
последий кадр является глобальным окружением.
При запуске компилятора будет устанавливаться начальное окружение,
состоящего только из кадра с примитивами.

При компиляции функции окружение будет расширяться кадром, который будет
наследовать все переменные глобального окружения + формальные параметры
функции, а затем будет дополняться новыми переменными, если в этом
возникнет необходимость. По завершению компиляции этот кадр будет
удаляться, поскольку никакие другие процедуры кроме текущей не должны
иметь доступ к переменным, объявленным внутри этой функции.

Связываем имена лисповых примитивов и сишных, чтоб знать, какие именно
имена компилировать, если использованы данные примитивы, поскольку имена
сишных примитивов и примитивов схемы не всегда совпадают из-за
синтаксических правил си банального неудобства.

#+NAME: primitives
#+BEGIN_SRC scheme :noweb yes
  (define (primitive-proc-bindings)
    (list (list 'car 'car)
          (list 'cdr 'cdr)
          (list 'cons 'cons)
          (list 'list 'make-list)
          (list  '+ 'add)
          (list  '- 'sub)
          (list  '* 'mul)
          (list  '/ 'division)
          (list  '= 'equal_numbers_predicate)
          (list  '> 'bigger_predicate)
          (list  '< 'smaller_predicate)
          (list  'reverse 'reverse)
          (list  'append 'append)
          (list  'assoc 'assoc)
          (list  'length 'length_compile)
          (list  'last-pair 'last_pair)
          (list  'true? 'true_predicate_compile)
          (list  'false? 'false_predicate_compile)
          (list  'null? 'null_predicate_compile)
          (list  'pair? 'pair_predicate_compile)
          (list  'symbol? 'symbol_predicate_compile)
          (list  'atom? 'atom_predicate_compile)
          (list  'string? 'string_predicate_compile)
          (list  'dotpair? 'dotpair_predicate_compile)))

  (define (primitive-procedure-objects)
    (map (lambda (proc)
           (list (car proc)
                 (list 'primitive (cadr proc))))
         (primitive-proc-bindings)))
#+END_SRC

Конструируем аналоги сикповых процедур для окружений, только с тем
расчетом, что у нас кадр состоит только из имен переменных.
#+NAME: environment
#+BEGIN_SRC scheme :noweb yes
  (define (atom? arg)
    (or (string? arg) (number? arg)
        (symbol? arg)))

  (define (enclosing-environment env) (cdr env))

  (define (first-frame env) (car env))

  (define the-empty-environment '())

  (define (add-binding-to-frame! var frame)
    (let* ((first-elt (car frame))
           (rest (cdr frame)))
      (set-car! frame var)
      (set-cdr! frame (list first-elt))
      (let ((last-elt (last-pair frame)))
        (set-cdr! last-elt rest)
        frame)))

  (define (extend-environment vars base-env)
    (cons vars base-env))

  (define (lookup-variable var env)
    (define (env-loop env)
      (define (scan vars)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((and (pair? var) (pair? (car vars)))
               (if (eq? (car var) (caar vars))
                   (car vars)
                   (scan (cdr vars))))
              ((and (not (pair? var)) (pair? (car vars)))
               (if (eq? var (caar vars))
                   (car vars)
                   (scan (cdr vars))))
              ((eq? var (car vars)) 'ok)
              (else (scan (cdr vars)))))
      (if (eq? env the-empty-environment)
          (error "Compile: Несвязанная переменная" var)
          (let ((frame (first-frame env)))
            (scan frame))))
    (env-loop env))

  (define (define-variable! var env)
    (let ((frame (first-frame env)))
      (define (scan vars)
        (cond ((null? vars)
               (begin
                 (format #t "define-variable!: переменная новая ~%" )
                 (add-binding-to-frame! var frame)
                 'ok))
              ((and (pair? var) (pair? (car vars)))
               (if (eq? (car var) (caar vars))
                   (car vars)
                   (scan (cdr vars))))
              ((and (atom? var) (pair? (car vars)))
               (if (eq? var (caar vars))
                   (car vars)
                   (scan (cdr vars))))
              ((eq? var (car vars)) (car vars))
              (else (scan (cdr vars)))))
      (scan frame)))

  (define (delete-frame env)
    (set! env (cdr env)))

  (define (setup-environment)
    (let ((initial-env
           (extend-environment (primitive-procedure-objects)
                               the-empty-environment)))
      initial-env))

  (define global-environment (setup-environment))

  ;; тесты

  ;; (define test-env (setup-environment))

  ;; (set! test-env (extend-environment '( f s n l) test-env))

  ;; (add-binding-to-frame! 'd (first-frame test-env))

  ;; (add-binding-to-frame! '(test_fn compound) (first-frame test-env))

  ;; (lookup-variable '(test_fn compound) test-env)

  ;; (lookup-variable 's test-env)

  ;; (lookup-variable '(s n) test-env)

  ;; (lookup-variable '(car car) test-env)

#+END_SRC

~Печать сгенерированного кода в файл си.~

Алгоритм, который переведет скомпилированный текстом код, в его тектовый
аналог.

Зачем это делать?
Си имеет разнообразный синтаксис, который нужно вкомпиливать в код. В
схеме это приходится делать путем экранирования симвлов или заменой их на
другие.
Следовательно, если мы хотим корректно исполнить скомпилированный си код,
мы должны иметь коректное представление синтаксиса.
Поэтому мы будем обходить скомпилированный код, заменять символы на
нужный синтаксис и записывать все в си-файл.

Этапы преобразования:
- есть общий список скомпилированного кода
- обойти все его подсписки, превратить все символы в строку, кроме тех,
  которые стоит заменить
- сформировать общую строку
- записать строку в файл

Данная часть трасформирует скомпилированный код в строки
#+NAME: trasform_code
#+BEGIN_SRC scheme :noweb yes
  (define (transform-exp exp)
    (define (transform-exp-rec exp list-of-strings)
      ;; (format #t "transform-exp-rec: exp ~A ~%" exp)
      (if (null? exp)
          list-of-strings
          (let ((first-elt (car exp )))
            (cond ((number? first-elt) (transform-exp-rec (cdr exp)
                                                          (append list-of-strings
                                                                  (list
                                                                   (string-append
                                                                    " "
                                                                    (number->string
                                                                     first-elt))))))
                  ((string? first-elt) (transform-exp-rec (cdr exp)
                                                          (append list-of-strings
                                                                  '( " ")
                                                                  (list first-elt))))
                  ((pair? first-elt) (transform-exp-rec (cdr exp)
                                                        (transform-exp-rec
                                                         first-elt
                                                         list-of-strings)))
                  (else
                   (cond ((eq? OPENING_BRACE first-elt)
                          (transform-exp-rec (cdr exp)
                                             (append list-of-strings (list " {"))))
                         ((eq? CLOSING_BRACE first-elt)
                          (transform-exp-rec (cdr exp)
                                             (append list-of-strings (list " }"))))
                         ((eq? OPENING_PARENTHESIS first-elt)
                              (transform-exp-rec (cdr exp)
                                                 (append list-of-strings (list "(")))
                              )
                         ((eq? CLOSING_PARENTHESIS first-elt)
                          (transform-exp-rec (cdr exp)
                                             (append list-of-strings (list " )"))))
                         ((eq? OPENING_BRACKET first-elt)
                          (transform-exp-rec (cdr exp)
                                             (append list-of-strings (list "[ "))))
                         ((eq? CLOSING_BRACKET first-elt)
                          (transform-exp-rec (cdr exp)
                                             (append list-of-strings (list " ] "))))
                         ((eq? СOLON first-elt)
                          (transform-exp-rec (cdr exp)
                                             (append list-of-strings (list ":"))))
                         ((eq? SEMICOLON first-elt)
                          (transform-exp-rec (cdr exp)
                                             (append list-of-strings (list ";"))))
                         ((eq? COMMA first-elt)
                          (transform-exp-rec (cdr exp)
                                             (append list-of-strings (list ", "))))
                         ((eq? ASTERISK first-elt)
                          (transform-exp-rec (cdr exp)
                                             (append list-of-strings (list "*"))))
                         ((eq? ELLIPSIS first-elt)
                          (transform-exp-rec (cdr exp)
                                             (append list-of-strings (list " ..."))))
                         (else (transform-exp-rec (cdr exp)
                                                  (append list-of-strings
                                                          (list
                                                           (string-append
                                                            " "
                                                            (symbol->string
                                                             first-elt))))) )))))))
    ;; (format #t "transform-exp-rec: exp ~A ~% ~%" exp)
    (transform-exp-rec exp (list)))

  (define (compiled-code->string code)
    (define (rec-compiled-code->string code list-of-strings)
      ;; (format #t "code ~A ~%" code)
      (if ( null? code )
          (begin
            ;; (format #t "null~%")
            list-of-strings)
          (begin
            (append list-of-strings (transform-exp (car code))
                    (rec-compiled-code->string (cdr code) list-of-strings)))))
    (rec-compiled-code->string (list code) '()))

  (define test-exp
    (compile-main
     (append (list 'proc1) (compile-parenthesis '()) (list SEMICOLON)
             (list 'proc2) (compile-parenthesis '()) (list SEMICOLON)
             (list 'proc3) (compile-parenthesis '()) (list SEMICOLON))))

  (define test-exp2
    (append (list 'val) (list ASTERISK) (list 'init_syntax_errors)
            (compile-parenthesis '())
            (compile-braces (append (list 'char) (list ASTERISK) (list 'string)
                                    (list ASTERISK) (list '=)
                                    (list 'malloc)
                                    (compile-parenthesis
                                     (append (list 'sizeof)
                                             (compile-parenthesis
                                              (append
                                               (list 'char)
                                               (compile-brackets
                                                (list
                                                 'max_symbol_name_length))))))))))
  ;; (transform-exp test-exp)

  ;; (transform-exp test-exp2)

  ;; (print-code (compiled-code->string (list test-exp
  ;;                                          test-exp2)))

#+END_SRC

Данный алгоритм впечатывает преобразованный в строку код в файл, попутно
снабжая код пробелами и переводами строки

Во-первых, мы знаем, что правилам синтаксиса си с новой строки нужно
писать после:
- точки с запятой
- фигурных скобок.
#+NAME: print_code
#+BEGIN_SRC scheme :noweb yes
  (load-option 'format)
  (define *c-file* "test-file.txt")

  (define (print-code code-string)
    (define (rec-print-code code-string output-port)
      (if (null? code-string)
          'ok
          (let ((first-string (car code-string)))
            (if (or (equal? first-string "{" )
                    (equal? first-string " {" )
                    (equal? first-string " { " )
                    (equal? first-string " }" )
                    (equal? first-string " } " )
                    (equal? first-string " } " )
                    (equal? first-string ";" )
                    (equal? first-string "; " )
                    (equal? first-string ":" )
                    (equal? first-string ": " ))
                (begin
                  (format output-port "~A ~% "first-string)
                  (rec-print-code (cdr code-string) output-port))
                (begin
                  ;; (format #t "string ~A ~%" first-string)
                  ;; (if (equal? first-string " \"" )
                  (format output-port "~A" first-string)
                  (rec-print-code (cdr code-string) output-port))))))
    (let ((output-port (open-output-file  *c-file*)))
      (rec-print-code code-string output-port)
      (close-output-port output-port)
      'ok))

    ;; (format #t "\"~A\" ~%" 'a)

  (define test-exp
    (compile-main
     (append (list 'proc1) (compile-parenthesis '()) (list SEMICOLON)
             (list 'proc2) (compile-parenthesis '()) (list SEMICOLON)
             (list 'proc3) (compile-parenthesis '()) (list SEMICOLON))))

  (define test-exp2
    (append (list 'val) (list ASTERISK) (list 'init_syntax_errors)
            (compile-parenthesis '())
            (compile-braces (append (list 'char) (list ASTERISK) (list 'string)
                                    (list '=)
                                    (list 'malloc)
                                    (compile-parenthesis
                                     (append (list 'sizeof)
                                             (compile-parenthesis
                                              (append
                                               (list 'char)
                                               (compile-brackets
                                                (list
                                                 'max_symbol_name_length))))))
                                    (list SEMICOLON)))))

  (define tokens (compiled-code->string (list test-exp
                                              test-exp2)))

  (print-code tokens)
#+END_SRC

~Компиляция примитивов~

Предположим, компилятору на вход поступило выражение:
#+NAME: compile_primitives_lisp_example
#+BEGIN_SRC scheme :noweb yes
  (list 1 2 3 4 5)
#+END_SRC

Оно должно превратиться в это:
#+NAME: compile_primitives_c_example
#+BEGIN_SRC c :noweb yes
  val* some_fn() {
      int* ptr_a = malloc(sizeof(int));
      ,*ptr_a = 1;
      val* a_val = int_val_constructor( ptr_a );


      int* ptr_b = malloc(sizeof(int));
      ,*ptr_b = 2;
      val* b_val = int_val_constructor( ptr_b );


      int* ptr_c = malloc(sizeof(int));
      ,*ptr_c = 3;
      val* c_val = int_val_constructor( ptr_c );


      int* ptr_d = malloc(sizeof(int));
      ,*ptr_d = 4;
      val* d_val = int_val_constructor( ptr_d );


      int* ptr_f = malloc(sizeof(int));
      ,*ptr_f = 5;
      val* f_val = int_val_constructor( ptr_f );

      return make_list(a, b, c, d, f);
  }
#+END_SRC

Для нужно:

- получить оператор выражения
- определяем, что это примитив
- вызываем ~compile-primitive~.

~compile-primitive~
Для компиляции примитивов нам необходимо следующее:
- обязательно подключить заголовочный файл primitives.h - он подключит
  написанные на си примитивы, которые мы создали для интерпретатора
- для каждого вызыова примитива будет сгенерирована служебная функция,
  внутри которой он будет исполняться

~compile-numbers~
Самое простое - это скомпилировать код для представления чисел.
Получив на вход число 3, к примеру, компилятор должен вернуть следующее:
#+NAME: compile-numbers-example
#+BEGIN_SRC c :noweb yes
  int* ptr_a = malloc(sizeof(int));
  ,*ptr_a = 3;
  val* a_val = int_val_constructor( ptr_a );
#+END_SRC

К тому же, нам нужно сгенерировать имя для переменной, потому что иначе
мы не сможем использовать это число.

#+NAME: compile_int_constructors
#+BEGIN_SRC scheme :noweb yes
  (define (compile-malloc-int var-name)
    (let* ((malloc-int (append '(malloc)
                               (compile-parenthesis (append '(sizeof)
                                                            (compile-parenthesis 'int)))))
           (int-pointer (append '(int) (list ASTERISK)
                                (list (string-append "ptr_" var-name) '=))))
      (append int-pointer malloc-int (list SEMICOLON))))

  ;; (compile-malloc-int "dzen")
  ;; (print-code (transform-exp (compile-malloc-int "dzen")))

  (define (compile-set-value-to-pointer p-name value)
    (append (list ASTERISK) (list (string-append "ptr_"  p-name) '= value)
            (list SEMICOLON)))

  (define (compile-int-val-constructor var-name var-value)
    ;; (display "compile-int-val-constructor")
    ;; (newline)
    (let ((allocated-memory (compile-malloc-int var-name))
          (new-var-name (string-append "val_" var-name))
          (set-value-to-pointer (compile-set-value-to-pointer var-name var-value)))
      (append allocated-memory
              set-value-to-pointer
              '(val) (list ASTERISK) (list new-var-name '= 'int_val_constructor)
                    (compile-parenthesis (string-append "ptr_" var-name))
                    (list SEMICOLON))))

  ;; (compile-int-val-constructor "some_name" 2)
  ;; (print-code (transform-exp (compile-int-val-constructor "some_name" 2)))
#+END_SRC

#+NAME: compile_symbol_constructors
#+BEGIN_SRC scheme :noweb yes
  (define (compile-malloc-char var-name)
    (let* ((malloc-char (append '(malloc)
                                (compile-parenthesis (append '(sizeof)
                                                             (compile-parenthesis
                                                              (append '(char)
                                                                      (compile-brackets
                                                                       100)))))))
           (char-pointer (append '(char) (list ASTERISK)
                                 (list (string-append "ptr_" var-name) '=))))
      (append char-pointer malloc-char (list SEMICOLON))))


  ;; (compile-malloc-char "dzen")
  ;; (print-code (transform-exp (compile-malloc-char "dzen")))

  (define (compile-strcpy var-name string)
    (append
     '(strncpy) (compile-parenthesis
                 (append (list (string-append "ptr_" var-name))
                         (list COMMA)
                         (list string)
                         (list COMMA)
                         (list 100)))
     (list SEMICOLON)))

  (define (compile-symbol-val-constructor var-name string)
    (let ((allocated-memory (compile-malloc-char var-name))
          (new-var-name (string-append "val_" var-name))
          (strcpy (compile-strcpy var-name string)))
       (append
        allocated-memory strcpy
        (append
         '(val) (list ASTERISK) (list new-var-name '= 'symbol_val_constructor)
         (compile-parenthesis (string-append "ptr_" var-name))
         (list SEMICOLON)))))

  ;; (compile-symbol-val-constructor "some_name" "some string")
  ;; (print-code (transform-exp (compile-symbol-val-constructor "some-name" "some string")))
#+END_SRC

#+NAME: compile_numbers
#+BEGIN_SRC scheme :noweb yes
  (define (compile-numbers numbers-list)
    (define (rec-compile-numbers numbers-list compiled-code nums-names)
      (if (null? numbers-list)
          (list compiled-code nums-names)
          (let* ((var-name (generate-name-string numbers-list))
                 (cur-number (car numbers-list)))
            (rec-compile-numbers (cdr numbers-list)
                                 (append
                                  compiled-code
                                  (compile-int-val-constructor var-name cur-number))
                                 (append
                                  nums-names
                                  (list (string-append "val_" var-name)))))))
    (if (pair? numbers-list)
        (rec-compile-numbers numbers-list '() '())
        (rec-compile-numbers (list numbers-list) '() '())))

  (define test (compile-numbers '(1 2 3 4 5)))
  (print-code (transform-exp (car test)))

  (cadr test)

  (define test (compile-numbers 1))
  (print-code (transform-exp (car test)))

  (cadr test)
#+END_SRC

Компилирование символов и строк.
Разница между ними небольшая: просто для символов имена уже известны, а
для строк имен нет, поэтому их приходится генерировать.

#+NAME: compile_symbols
#+BEGIN_SRC scheme :noweb yes
  (define (compile-strings strings-list)
    (define (rec-compile-string strings-list compiled-code string-names)
      (if (null? strings-list)
          (list compiled-code string-names)
          (let* ((var-name (generate-name-string strings-list))
                 (cur-string (car strings-list)))
            (rec-compile-string (cdr strings-list)
                                (append
                                 compiled-code
                                 (compile-symbol-val-constructor var-name cur-string))
                                (append
                                 string-names
                                 (list (string-append "val_" var-name)))))))
    (if (pair? strings-list)
        (rec-compile-string strings-list '() '())
        (rec-compile-string (list strings-list) '() '())))


  (define (compile-symbols symbols-list strings)
    (define (rec-compile-symbols symbols-list strings compiled-code)
      (if (null? symbols-list)
          compiled-code
          (let* ((var-name (car symbols-list))
                 (cur-msg (car strings)))
            (rec-compile-symbols (cdr symbols-list)
                                 (cdr strings)
                                 (append
                                  compiled-code
                                  (compile-symbol-val-constructor var-name cur-msg))))))
    (if (pair? symbols-list)
        (list (rec-compile-symbols symbols-list strings '())
              symbols-list)
        (list (rec-compile-symbols symbols-list strings '())
              (list symbols-list))))

  ;; (define test (compile-symbols '("a" "b" "c") '("\"a-string\""
  ;;                                                "\"b-string\""
  ;;                                                "\"c-string\"")))
  ;; (print-code (transform-exp (car test)))
  ;; (cadr test)

  ;; (define test2 (compile-strings  '("\"a-string\""
  ;;                                   "\"b-string\""
  ;;                                   "\"c-string\"")))

  ;; (print-code (transform-exp (car test2)))
  ;; (cadr test2)
#+END_SRC

Теперь можно попробовать скомпилировать примитивы.

#+NAME: compile_primitives_constructors
#+BEGIN_SRC scheme :noweb yes
  (define (compile-list args)
    (define (compile-list-rec args compiled-code)
      (if (null? args)
          compiled-code
          (compile-list-rec (cdr args) (append compiled-code
                                               (list COMMA)
                                               (list (car args))))))
    (let ((amount-of-args (length args)))
      (append '(make_list)
              (compile-parenthesis
               (append (compile-list-rec args (list amount-of-args)))))))


  ;; (print-code( transform-exp (compile-list '("\" 3 \"" 1 2 d))))

  (define (compile-cons args)
    (let ((first-arg (car args))
          (second-arg (cadr args)))
      (append '(cons)
              (compile-parenthesis
               (append (list first-arg)
                       (list COMMA)
                       (list second-arg))))))

  ;; (print-code( transform-exp (compile-cons '(1 2))))


  (define (compile-car args)
    (append '(car)
            (compile-parenthesis args)))

  ;; (print-code( transform-exp (compile-car '(some-list))))

  (define (compile-cdr args)
    (append '(cdr)
            (compile-parenthesis args)))

  ;; (print-code( transform-exp (compile-cdr '(some-list))))

  (define (compile-set-car args)
    (append '(set_car)
            (compile-parenthesis args)))

  ;; (print-code( transform-exp (compile-set-car '(some-list))))

  (define (compile-set-cdr args)
    (append '(set_cdr)
            (compile-parenthesis args)))

  ;; (print-code( transform-exp (compile-set-cdr '(some-list))))

  (define (compile-append args)
    (let ((first-arg (car args))
          (second-arg (cadr args)))
      (append '(append)
              (compile-parenthesis
               (append (list first-arg)
                       (list COMMA)
                       (list second-arg))))))

  ;; (print-code( transform-exp (compile-append '(some-list1 some-list2))))


  (define (compile-assoc args)
    (let ((first-arg (car args))
          (second-arg (cadr args)))
      (append '(assoc)
              (compile-parenthesis
               (append (list first-arg)
                       (list COMMA)
                       (list second-arg))))))

  ;; (print-code( transform-exp (compile-assoc '( some-key some-list))))

  (define (compile-length args)
    (append '(length_compile)
            (compile-parenthesis args)))

  ;; (print-code( transform-exp (compile-length '(some-list))))

  (define (compile-last-pair args)
    (append '(last-pair)
            (compile-parenthesis args)))

  (define (compile-smaller-predicate-compile args)
    (append '(smaller_predicate_compile)
            (compile-parenthesis args)))

  (define (compile-bigger-predicate-compile args)
    (append '(bigger_predicate_compile)
            (compile-parenthesis args)))

  (define (compile-equal-numbers args)
    (let ((first-arg (car args))
          (second-arg (cadr args)))
      (append '(equal_numbers_predicate_compile)
              (compile-parenthesis
               (append (list first-arg)
                       (list COMMA)
                       (list second-arg))))))

  (define (compile-add args)
    (append '(add)
            (compile-parenthesis args)))

  (define (compile-sub args)
    (append '(sub)
            (compile-parenthesis args)))

  (define (compile-mul args)
    (append '(mul)
            (compile-parenthesis args)))

  (define (compile-division args)
    (append '(division)
            (compile-parenthesis args)))

  (define (compile-reverse args)
    (append '(reverse)
            (compile-parenthesis args)))

  (define (compile-true? args)
    (append '(true_predicate_compile)
            (compile-parenthesis args)))

  (define (compile-false? args)
    (append '(false_predicate_compile)
            (compile-parenthesis args)))

  (define (compile-null? args)
    (append '(null_predicate_compile)
            (compile-parenthesis args)))

  (define (compile-pair? args)
    (append '(pair_predicate_compile)
            (compile-parenthesis args)))

  (define (compile-atom? args)
    (append '(atom_predicate_compile)
            (compile-parenthesis args)))

  ;; (print-code (compiled-code->string
  ;;              (list (compile-list '("\" 3 \"" 1 2 d))
  ;;                    (compile-cons '(1 2))
  ;;                    (compile-car '(some-list))
  ;;                    (compile-cdr '(some-list))
  ;;                    (compile-set-car '(some-list))
  ;;                    (compile-set-cdr '(some-list))
  ;;                    (compile-append '(some-list1 some-list2))
  ;;                    (compile-assoc '( some-key some-list))
  ;;                    (compile-length '(some-list))
  ;;                    (compile-last-pair '(some-list))
  ;;                    (compile-add '(some-args-list))
  ;;                    (compile-sub '(some-args-list))
  ;;                    (compile-mul '(some-args-list))
  ;;                    (compile-division '(some-args-list))
  ;;                    (compile-reverse '(some-list))
  ;;                    (compile-reverse '(some-list))
  ;;                    (compile-true? 'some-arg)
  ;;                    (compile-false? 'some-arg)
  ;;                    (compile-pair? 'some-arg)
  ;;                    (compile-null? 'some-arg)
  ;;                    (compile-atom? 'some-arg))))

#+END_SRC

Итак, прежде чем вызывать компиляцию примитивов, надо сначала вызвать
компиляцию аргументов.
Аргументы могут быть:
- вызвами процедур
- переменными
- строками
- числами

#+NAME: compile_args
#+BEGIN_SRC scheme :noweb yes
  (define (self-evaluating? exp)
    (cond ((number? exp) true)
          ((string? exp) true)
          (else false)))

  (define (true? exp)
    (not (false? exp)))

  (define (compile-self-evaluating exp)
    (if (number? exp)
        (compile-numbers exp)
        (compile-strings exp)))

  ;; (primitive-proc? '(list 1 2 3 4) global-environment)
  ;; (primitive-proc? '(cons 1 2 3 4) global-environment)
  ;; (primitive-proc? '(map 1 2 3 4) global-environment)

  (define (compile exp env)
    (format #t "compile: exp ~A ~%" exp)
    (cond ((self-evaluating? exp)
           (compile-self-evaluating exp))
          ((variable? exp)
           (compile-variable exp env)) ;; проверить, сработает ли
          ((definition? exp)
           (compile-definition exp env))
          ((begin? exp)
           (compile-sequences (begin-actions exp)
                              env))
          ((if? exp)
           (compile-if exp env))
          (else (compile-application exp env))))

  (define (compile-variable exp env)
    (format #t "compile-variable: exp ~A ~%" exp)
    (if (lookup-variable exp env)
        (list (list 'existing_var exp)
              (list exp))))

  ;; (compile 1 '())

  (define (compile-args args env)
    (define (compile-args-rec args compiled-code)
      (if (null? args)
          (begin
            ;; (format #t "compile-args-rec: compiled-code ~A ~%" compiled-code)
            compiled-code)
          (let* ((compiled-arg-code (compile (car args) env)))
            ;; (format #t "compile-args-rec: compiled-arg-code ~A ~%" compiled-arg-code)
            (compile-args-rec (cdr args) (append compiled-code (list
                                                                compiled-arg-code))))))

    ;; (format #t "compile-args: args ~A ~%" args)
    (compile-args-rec (cdr args) (list (compile (car args) env))))

#+END_SRC

#+NAME: compile_primitives
#+BEGIN_SRC scheme :noweb yes
  (define (primitive-proc? exp env)
    ;; (format #t "primitive proc exp ~A ~%" exp)
    (let* ((op (operator exp))
           (value (lookup-variable op env)))
      (if (pair? value)
          (let ((proc-binding (cadr value)))
            (if (eq? 'primitive (car proc-binding))
                true
                false))
          false)))

  (define (connect-compiled-exps compiled-exps-with-names)
    (define (connect-all-exps-rec lst new-lst)
      ;; (format #t "connect-all-exps-rec: new-lst ~A ~% " new-lst)
      ;; (format #t "connect-all-exps-rec: lst ~A ~% " lst)
      (if (null? lst)
          (begin
            (format #t "exit from connect-all-exps-rec ~%")
            new-lst)
          (let ((compiled-exp (caar lst)))
            ;; (format #t "connect-all-exps-rec: compiled-exp ~A ~% " compiled-exp)
            (if (and (pair? compiled-exp)
                     (eq? (car compiled-exp) 'existing_var))
                (begin
                  (format #t " existing_var true ~%")
                (connect-all-exps-rec (cdr lst) new-lst))
                (connect-all-exps-rec (cdr lst) (append new-lst compiled-exp))))))
    ;; (format #t "connect-all-exps: lst ~A ~% ~% " compiled-exps-with-names)
    (connect-all-exps-rec compiled-exps-with-names '()))


  (define (compile-primitive exp env)
    (define (compile-cur-primitive compiled-args-names)
      ;; (format #t "compile-cur-primitive: compiled-args-names ~A ~%"
      ;;         compiled-args-names)
      (cond ((eq? (operator exp) 'list)
             (compile-list compiled-args-names))
            ((eq? (operator exp) 'cons)
             (compile-cons compiled-args-names))
            ((eq? (operator exp) 'car)
             (compile-car compiled-args-names))
            ((eq? (operator exp) 'cdr)
             (compile-cdr compiled-args-names))
            ((eq? (operator exp) 'set-car!)
             (compile-set-car compiled-args-names))
            ((eq? (operator exp) 'set-cdr!)
             (compile-set-cdr compiled-args-names))
            ((eq? (operator exp) 'append)
             (compile-append compiled-args-names))
            ((eq? (operator exp) 'assoc)
             (compile-assoc compiled-args-names))
            ((eq? (operator exp) 'length)
             (compile-length compiled-args-names))
            ((eq? (operator exp) 'last-pair)
             (compile-last-pair compiled-args-names))
            ((eq? (operator exp) '=)
             (compile-equal-numbers compiled-args-names))
            ((eq? (operator exp) '+)
             (compile-add (compile-list compiled-args-names)))
            ((eq? (operator exp) '>)
             (compile-bigger-predicate-compile (compile-list compiled-args-names)))
            ((eq? (operator exp) '<)
             (compile-smaller-predicate-compile (compile-list compiled-args-names)))
            ((eq? (operator exp) '-)
             (compile-sub (compile-list compiled-args-names)))
            ((eq? (operator exp) '*)
             (compile-mul (compile-list compiled-args-names)))
            ((eq? (operator exp) '/)
             (compile-division (compile-list compiled-args-names)))
            ((eq? (operator exp) 'reverse)
             (compile-reverse compiled-args-names))
            ((eq? (operator exp) 'true?)
             (compile-true? compiled-args-names))
            ((eq? (operator exp) 'false?)
             (compile-false? compiled-args-names))
            ((eq? (operator exp) 'null?)
             (compile-null? compiled-args-names))
            ((eq? (operator exp) 'pair?)
             (compile-pair? compiled-args-names))
            ((eq? (operator exp) 'atom?)
             (atom? compiled-args-names))
            (else (error "Неизвестный примитив -- compile-primitive" (operator exp)))))
    (format #t "compile-cur-primitive: exp ~A ~%" exp)
    (if (null? (operands exp))
        (let* ((compiled-args '())
               (pre-result (append '(return)
                                   (compile-cur-primitive compiled-args)
                                   (list SEMICOLON)))
               (service-fn-name (generate-name-string exp))
               (call-service-fn (append (list service-fn-name) (compile-parenthesis '()))))
          (list (compile-service-fn service-fn-name pre-result)
                (list  call-service-fn)))
        (let* ((compiled-args
                (compile-args (operands exp) env))
               (compiled-args-names (map (lambda (code)
                                           (caadr code))
                                         compiled-args))
               (pre-result (append (connect-compiled-exps compiled-args)
                                   '(return)
                                   (compile-cur-primitive compiled-args-names) (list
                                                                                SEMICOLON )))
               (service-fn-name (generate-name-string exp))
               (call-service-fn (append (list service-fn-name) (compile-parenthesis '()))))
          (format #t "compile-cur-primitive: compiled-args ~A ~%"
                  (connect-compiled-exps compiled-args))
          ;; (format #t "compile-cur-primitive: call-service-fn ~A ~%"
          ;;         call-service-fn)
          ;; (format #t "compile-cur-primitive: return val ~A ~%"
          ;;         (list (compile-service-fn service-fn-name pre-result)
          ;;               call-service-fn))
          (list (compile-service-fn service-fn-name pre-result)
                (list call-service-fn)))))
#+END_SRC

#+NAME: compile_primitive_tests
#+BEGIN_SRC scheme :noweb yes
  (print-code (compiled-code->string (compile '(list 1 2) global-environment)))

  (print-code (compiled-code->string (compile '(cons 1 2) global-environment)))

  (print-code (compiled-code->string (compile '(car (car (list (list 1 2) 3)))
                                              global-environment)))

  (print-code (compiled-code->string (compile '(car (cons 1 2)) global-environment)))

  (print-code (compiled-code->string (compile '(assoc 3 (list
                                                         (cons 1 2) (cons 3 4)))
                                              global-environment)))

  (print-code (compiled-code->string (compile '(+ 1 2 3) global-environment)))

  (print-code (compiled-code->string (compile '(+ 1 ( * 2 3)) global-environment)))

  (print-code (compiled-code->string (compile '(true? 2) global-environment)))
#+END_SRC

~Компиляция определений~

Итак, мы считаем, что у нас определения могут быть только с помощью
define, так для начала проще реализовывать. К тому же, let - это
синтаксический сахар для лямбды, так что если писать поддержку let, то
нужно сначала добавить компиляцию лямбд.

Определения могут быть глобальными или локальными.
Так же определения могут определять переменные или функции. В этом случае
компиляция должна быть разной.

Начнем с компиляции глобальный и локальных переменных. Локальные
переменные компилировать проще - мы просто возвращаем скомпилированный
код в то место, откуда была вызвана компиляция определения. Глобальное
определение сложнее - мы должны глобально определить некую переменную, а
затем присвоить ей значение.

В си это различие будет выглядеть следующим образом:
Компиляция определения глобальной переменной.
На вход получено выражение ~(define n 10)~
На выходе полчаем:
#+NAME: definition_example
#+BEGIN_SRC c :noweb yes
  val* n;

  val* some_servise_fn_name() {
      int* some_ptr_name = malloc(sizeof(int));
      ,*some_ptr_name = 10;
      n = int_val_constructor(some_ptr_name);
  }

  int main () {

      some_servise_fn_name();
  }
#+END_SRC

Теперь компилируем то же выражение локально, к примеру, оно определено
внутри функции ~fn1~:

#+NAME: definition_example
#+BEGIN_SRC c :noweb yes
  val* fn1() {
      /* some code before definition*/

      int* some_ptr_name = malloc(sizeof(int));
      ,*some_ptr_name = 10;
      val* n = int_val_constructor(some_ptr_name);

      /* some code after definition*/

  }

  int main () {

      fn1();
  }
#+END_SRC

Итак, снаала нужно понять, поступило нам на вход определение функции
или определение переменной.

#+NAME: define_definition
#+BEGIN_SRC scheme :noweb yes
  (define (tagged-list? exp tag)
    (if (pair? exp)
        (eq? (car exp) tag)
        false))

  (define (definition? exp)
    (tagged-list? exp 'define))


  (define (definition-fn? exp)
    (pair? (cadr exp)))

  (define (compile-definition exp env)
    (format #t "compile-definition ~A ~%" exp)
    (if (definition-fn? exp)
        (compile-named-function exp env)
        (compile-definition-var exp env)))
#+END_SRC

Итак, мы определили, что определение переменной.
Теперь нужо понять, глобальная она или локальная. Сделать это довольно
легко: если мы не находимся внутри какой-то функции, то у нас в окружении
будет всего один кадр - т.е. то самое глобальное окружение. Если же мы
вызываем определение, находясь внутри какой-либо функции, то у нас
добавится дополнительый кадр с ее формальными параметрами, который
исчезнет после того, как компиляция фнукции будет закончена.

#+NAME: compile_service_assignments
#+BEGIN_SRC scheme :noweb yes
  (define (global-env? env)
    ( = ( length env) 1))

  ;; (global-env? global-environment)

  ;; (global-env? (cons '(some var names) global-environment))

  ;; вызывает компиляцию локальной или глобальной переменной
  (define (compile-definition-var exp env)
    (if (global-env? env)
        (compile-definition-var-global exp env)
        (compile-definition-var-local exp env)))

  ;; компиляция переменной, содержащей в себе число
  ;; подходит для локальных переменных
  (define (compile-create-variable-with-num-value var-name value)
    (let* ((name-string (symbol->string var-name))
          (allocated-memory (compile-malloc-int name-string))
          (set-value-to-pointer (compile-set-value-to-pointer name-string value)))
      (append allocated-memory
              set-value-to-pointer
              '(val) (list ASTERISK) (list name-string '= 'int_val_constructor)
              (compile-parenthesis (string-append "ptr_" name-string))
              (list SEMICOLON))))

  ;; компиляция переменной, содержащей в себе строку
  (define (compile-create-variable-with-string-value var-name string)
    (let* ((name-string (symbol->string var-name))
          (allocated-memory (compile-malloc-char name-string))
          (strcpy (compile-strcpy name-string string)))
      (append allocated-memory
              strcpy
              '(val) (list ASTERISK) (list name-string '= 'symbol_val_constructor)
              (compile-parenthesis (string-append "ptr_" name-string))
              (list SEMICOLON))))

  ;; компиляция неинициализированной переменной
  (define (compile-unassigned-variable var-name)
    (list 'val ASTERISK (symbol->string var-name) SEMICOLON))

  ;; присваивание числового значения переменной
  (define (make-int-assignment var value)
    (format #t "make-int-assignment ~%")
    (let ((int-val-pointer (string-append(symbol->string var) "->uni_val.int_val"))
          (type-num-pointer (string-append(symbol->string var) "->type_num")))
      (append
       (list ASTERISK int-val-pointer '= value SEMICOLON)
       (list type-num-pointer '= "TYPE_INT" SEMICOLON))))

  ;; присваивание значния-строки переменной
  (define (make-char-assignment var string)
    (let ((char-val-pointer (string-append(symbol->string var) "->uni_val.char_val"))
          (type-num-pointer (string-append(symbol->string var) "->type_num")))
      (append
       (compile-malloc-char (symbol->string var))
       (compile-strcpy (symbol->string var) string)
       (list char-val-pointer '= (string-append
                                   "ptr_" (symbol->string var))
              SEMICOLON)
       (list type-num-pointer '= "TYPE_STRING" SEMICOLON))))

  ;; присваивание числового значения уже существующей переменной
  (define (make-global-created-var-int-assignment var-name value)
    (let* ((name-string (symbol->string var-name))
          (allocated-memory (compile-malloc-int name-string))
          (set-value-to-pointer (compile-set-value-to-pointer name-string value)))
      (append allocated-memory
              set-value-to-pointer
              (list name-string '= 'int_val_constructor)
              (compile-parenthesis (string-append "ptr_" name-string))
              (list SEMICOLON))))

  ;; присваивани значения-строки уже существующей переменной
  (define (make-global-created-var-string-assignment var-name string)
    (let* ((name-string (symbol->string var-name))
          (allocated-memory (compile-malloc-char name-string))
          (strcpy (compile-strcpy name-string string)))
      (append allocated-memory
              strcpy
              (list name-string '= 'symbol_val_constructor)
              (compile-parenthesis (string-append "ptr_" name-string))
              (list SEMICOLON))))

  ;; присваивание значения-символа уже существующей переменной
  (define (make-global-created-var-symbol-assignment var-name symbol)
    (list var-name '= symbol SEMICOLON))

  ;; (compile-unassigned-variable 'try)


  ;; (define (compile-definition-var-local exp env)

  ;;   )
#+END_SRC

#+NAME: compile_definition_global_var
#+BEGIN_SRC scheme :noweb yes
  ;; компиляция глобальной переменной (пока что не поддерживает компиляцию функций)
  (define (compile-definition-var-global exp env)
    (let ((return-value (define-variable! (definition-variable exp) env)))
      (if (eq? return-value 'ok)
          ;; переменная новая
          (let* ((service-fn-name (generate-name-string exp))
                 (call-service-fn (append (list service-fn-name)
                                          (compile-parenthesis '()))))

            (cond ((number? (definition-value exp))
                   (begin
                     ;; (format #t "новая глобальная переменная - число ~%")

                     ;; значение переменной - число
                     (let* ((unassigned-var (compile-unassigned-variable
                                             (definition-variable exp)))
                            (assign-var (make-global-created-var-int-assignment
                                         (definition-variable exp)
                                         (definition-value exp))))
                       (list (append unassigned-var
                                     (compile-service-fn service-fn-name assign-var))
                             (list  call-service-fn)))))
                  ((string? (definition-value exp))
                   (begin
                     ;; (format #t "новая глобальная переменная - строка ~%")
                     ;; значение переменной - строка
                     (let* ((unassigned-var (compile-unassigned-variable
                                             (definition-variable exp)))
                            (assign-var (make-global-created-var-string-assignment
                                         (definition-variable exp)
                                         (definition-value exp))))
                       (list (append unassigned-var
                                     (compile-service-fn service-fn-name assign-var))
                             (list  call-service-fn)))))
                  ;; значение переменной - символ (т.е. другая переменная)
                  ((symbol? (definition-value exp))
                   (if (lookup-variable (definition-value exp) env)
                       (let* ((unassigned-var (compile-unassigned-variable
                                               (definition-variable exp)))
                              (assign-var (make-global-created-var-symbol-assignment
                                           (definition-variable exp)
                                           (definition-value exp))))
                         (list (append unassigned-var
                                       (compile-service-fn service-fn-name assign-var))
                               (list  call-service-fn)))))
                  ;; значение переменной - вызов функции
                  (else
                   (let* ((compile-definition-value
                           (compile (definition-value exp) env))
                          (definition-value-call (cadr compile-definition-value))
                          (unassigned-var (compile-unassigned-variable
                                           (definition-variable exp)))
                          (service-fn-name (generate-name-string exp))
                          (assign-var (list (definition-variable exp) '=
                                            definition-value-call SEMICOLON))
                          (call-service-fn (append (list service-fn-name)
                                                   (compile-parenthesis '()))))
                     (list (append unassigned-var
                                   (car compile-definition-value)
                                   (compile-service-fn service-fn-name assign-var))
                           (list  call-service-fn))))))
          ;; переопределение переменной
            (let* ((service-fn-name (generate-name-string exp))
                   (call-service-fn (append (list service-fn-name)
                                            (compile-parenthesis '()))))

              ;; (format #t "глобальная переменная уже была определена ~%")
              (cond ((number? (definition-value exp))
                     (let* ((assignment (make-int-assignment (definition-variable exp)
                                                             (definition-value exp))))
                       (list (compile-service-fn service-fn-name assignment)
                             (list call-service-fn))))
                    ;; новое значение - строка
                    ((string? (definition-value exp))
                     (let* ((assignment (make-char-assignment(definition-variable exp)
                                                             (definition-value exp))))
                       (list (compile-service-fn service-fn-name assignment)
                             (list call-service-fn))))
                    ;; новое значение - символ
                    ((symbol? (definition-value exp))
                     (if (lookup-variable (definition-value exp) env)
                         (let* ((assignment (make-global-created-var-symbol-assignment
                                             (definition-variable exp)
                                             (definition-value exp))))
                           (list (compile-service-fn service-fn-name assignment)
                                 (list call-service-fn)))))
                    ;; новое значение - вызов функции
                    (else
                     (let* ((compile-definition-value
                             (compile (definition-value exp) env))
                            (definition-value-call (cadr compile-definition-value))
                            (assignment (list (definition-variable exp) '=
                                              definition-value-call SEMICOLON)))
                       (list (append (car compile-definition-value)
                                     (compile-service-fn service-fn-name assignment))
                             (list  call-service-fn))))))))))
#+END_SRC

#+NAME: compile_definition_var_global_tests
#+BEGIN_SRC scheme :noweb yes
  (print-code
   (compiled-code->string(compile-definition-var '(define n 10) global-environment)))

  (print-code
   (compiled-code->string(compile-definition-var '(define n 11) global-environment)))

  (print-code
   (compiled-code->string(compile-definition-var '(define n "\"some-string\"")
                                                 global-environment)))

  (print-code
   (compiled-code->string(compile-definition-var '(define test_define (list 1 2 3))
                                                 global-environment)))

  (print-code
   (compiled-code->string(compile-definition-var '(define test_define (list 1 2 3 4 5))
                                                 global-environment)))

  (print-code
   (compiled-code->string(compile-definition-var '(define test_define n)
                                                 global-environment)))
#+END_SRC
Компиляция локальных переменных несколько проще, чем компиляция
глобальных - переменную не надо объявлять заранее, - так что это очень
похоже на компиляцию чисел или строк - просто нам не нужно будет
генерировать имя для для них, оно у нас уже есть.

#+NAME: compile_definition_local_var
#+BEGIN_SRC scheme :noweb yes
  (define (compile-definition-var-local exp env)
    (let ((return-value (define-variable! (definition-variable exp) env)))
      (if (eq? return-value 'ok)
          ;; переменная новая
          (if (number? (definition-value exp))
              (begin
                (format #t "новая локальная переменная - число ~%")
                (let* ((variable-code
                        (compile-create-variable-with-num-value (definition-variable exp)
                                                                (definition-value exp))))
                  ;; (append variable-code (list (list (definition-variable exp))))
                  (format #t "variable-code ~A ~%" variable-code)
                  (list variable-code (list (list (definition-variable exp))))))
              (begin
                (format #t "новая локальная переменная - строка  ~%")
                (let* ((variable-code
                        (compile-create-variable-with-string-value
                         (definition-variable exp)
                         (definition-value exp))))
                  ;; (append variable-code (list (list (definition-variable exp))))
                  (format #t "variable-code ~A ~%" variable-code)
                  (list variable-code (list (list
                                             (definition-variable exp))))))))
          ;; переопределение переменной
          (begin
            (format #t "локальная переменная уже была определена ~%")
            (if (number? (definition-value exp))
                (let* ((assignment (make-int-assignment (definition-variable exp)
                                                        (definition-value exp))))
                  ;; (append assignment (list (definition-variable exp)))
                  (format #t "variable-code ~A ~%" assignment)
                  (list assignment (list (list (definition-variable exp)))))

                (let* ((assignment (make-char-assignment(definition-variable exp)
                                                        (definition-value exp))))
                  ;; (append assignment (list (list (definition-variable exp))))
                  (format #t "variable-code ~A ~%" assignment)
                  (list assignment (list (list (definition-variable exp))))))))))
#+END_SRC

#+NAME: compile_definition_var_global_tests
#+BEGIN_SRC scheme :noweb yes
  ;; должен вернуть код для присваивания переменной нового значения
  (print-code
   (transform-exp( compile-definition-var '(define n 10) (cons '(s l n)
                                                              global-environment))))
  ;; должен вернуть код для создания локальной переменной
  (print-code
   (transform-exp( compile-definition-var '(define d 10) (cons '(s l n)
                                                               global-environment))))
  ;; должен вернуть код для присваивания переменной нового значения
  (print-code
   (transform-exp( compile-definition-var '(define s "\"some-string\"")
                                          (cons '(s l n)
                                                global-environment))))
  ;; должен вернуть код для создания локальной переменной
  (print-code
   (transform-exp( compile-definition-var '(define f "\"some-string\"")
                                          (cons '(s l n)
                                                global-environment))))
#+END_SRC

~Копиляция функций~
Основная сложность состоит в том, чтоб правильно скомпилировать тело функции.
Тело функции представляет собой последовательность выражений. Так что нам
просто нужно скомпилировать выражение одно за другим.

Функция ~compile-sequences~ компилирует выражение одно за другим и
возвращает список, где сar списка - это скомпилированный код выражений, а
cdr - это имена скомпилированных блоков: имена переменных, служебных
функци и т.д. Это обеспечит легкий доступ - вызов - скомпилированных
блоков.

#+NAME: compile_sequences
#+BEGIN_SRC scheme :noweb yes
  (define (compile-sequences sequenses env)
    (define (compile-sequences-rec sequenses compiled-code)
      ;; (format #t "compile-sequences-rec: compiled-code ~A ~% ~%" compiled-code)
      (if (null? sequenses)
          compiled-code
          (let ((first-compiled-seq (compile (car sequenses) env)))
            (format #t "compile-sequences-rec: first-compiled-seq ~A ~%" first-compiled-seq)
            (compile-sequences-rec (cdr sequenses)
                                   (cons first-compiled-seq compiled-code)))))
    ;; (format #t "sequenses ~A ~%" sequenses)
    ;; (format #t "sequenses env ~A ~%" env)
    ;; (format #t "compile-sequences: sequences ~A ~%" sequenses)
    (let* ((compiled-code-with-names (reverse (compile-sequences-rec sequenses '()))))
      (format #t "compiled-code-with-names ~A ~%" compiled-code-with-names)
      (let*  ((compiled-code (connect-compiled-exps compiled-code-with-names))
              (compiled-code-names (map (lambda (code)
                                          (format #t "(caadr code) ~A ~%" (caadr code))
                                          (caadr code))
                                        compiled-code-with-names)))
        (format #t "compiled-code-names ~A ~%" compiled-code-names)
        ;; (format #t "compile-sequences compiled-code ~A ~% ~%" compiled-code)
        (list compiled-code compiled-code-names))))



  ;; (print-code (compiled-code->string (compile '(begin
  ;;                                                (define n 10)
  ;;                                                (list 1 2 3)
  ;;                                                6) global-environment)))


  ;; (print-code (compiled-code->string (compile '(begin (+ x 1) (+ x 2))
  ;;                                             (cons '(x)
  ;;                                                   global-environment))))

#+END_SRC

Теперь нужно скомпилировать само определение функции. Для этого нужно
вытащить формальные параметры, имя функции и правильно установить
возвращаемое значение - это будет вызов или имя (если после выражение -
это самовычисляющееся выражение, например) последнего выражения.

В лиспе все функции - это по сути лямбды, даже если они
именовынные. Просто в случае если они именованные, то значением
переменной становится лямбда. Но у си несколько другая логика
языка. Во-первых, в си отсутствют лямбды в принципе - чтоб их
эмулировать, нам придесят генерировать служебное имя для функции, чтоб к
ней можно было обратиться.
Во-вторых, в си нельзя присвоить глобальной переменной в качестве
значения неконстанту или же определение чего-либо. Следовательно, подход
лиспа - когда мы при определении функции сначала превращали ее в лямбду,
компилировали ее, а затем присваивали скомпиленное переменной - в си
может сработать, но будет куда менее удобным.

Так что мы создадим функцию для компиляции функции (простите за
тавтологию), которая будет принимать: имя функции, формальные параметры,
тело и окружение.
Таким образом с помощью одного и того же инструмента мы свожем
компилировать как лямбды, так и именованные функции. Просто для лямбд
будем генерировать имя функции, а для именованных передавать как есть.

#+NAME: compile_function
#+BEGIN_SRC scheme :noweb yes
  (define (compile-fn-params-in-c-syntax params)
    (define (compile-fn-params-in-c-syntax-rec params-lisp params-c)
      (if (null? params-lisp)
          params-c
          (let ((cur-param (if (null? (cdr params-lisp))
                               (list 'val ASTERISK (car params-lisp))
                               (list 'val ASTERISK (car params-lisp) COMMA))))
            (compile-fn-params-in-c-syntax-rec (cdr params-lisp)
                                               (append params-c cur-param)))))
    ;; (format #t "~A ~%" params)
    (compile-fn-params-in-c-syntax-rec params '()))

  (define (compile-function fn-name params body env)
    ;; (format #t "compile-function: fn-name ~A params ~A body ~A ~%"
    ;;         fn-name params body)
    (let* ((new-env (extend-environment params env))
           (compiled-body-with-names (compile-sequences body new-env))
           (compiled-body (car compiled-body-with-names))
           (names-and-calls (cadr compiled-body-with-names))
           (return-value (append '(return) (last-pair names-and-calls) (list SEMICOLON)))
           (param-in-c-syntax (compile-fn-params-in-c-syntax params)))
      (format #t "compile-function: last-pair ~A ~% ~% "(last-pair names-and-calls))
      (format #t "compile-function: names-and-calls ~A ~% ~% "names-and-calls)
      (append (list 'val ASTERISK fn-name)
              (compile-parenthesis param-in-c-syntax)
              (compile-braces
               (append compiled-body
                       return-value)))))

  ;;пробуем скомпилить данный пример
  ;; (define (test x)
  ;;   (+ x 1)
  ;;   (+ x 2))

  ;; (print-code (compiled-code->string
  ;;              (compile-function 'test '(x) '((+ x 1) (+ x 2)) global-environment)))
#+END_SRC

На основе этого инструмента очень легко скомпилировать лямбду. Достаточно
только "вытащить" из выражения формальные параметры и тело.
#+NAME: compile_lambda
#+BEGIN_SRC scheme :noweb yes
  (define (compile-lambda exp env)
    (list (compile-function (generate-name-string exp) (lambda-parameters exp)
                            (lambda-body exp) env)
          (list (definition-variable exp))))

  ;; (print-code (compiled-code->string
  ;;              (compile-lambda
  ;;               '(lambda (x) (+ x 1) (* 3 4))
  ;;               global-environment)))
#+END_SRC

И еще легче скомпилировать именованную функцию:
#+NAME: compile_named-function
#+BEGIN_SRC scheme :noweb yes
  (define (named-fn-params exp)
    (cdr (cadr exp)))

  ;; (named-fn-params '(define (test x) (+ x 1)))

  (define (named-fn-body exp)
    (cdr (cdr exp)))

  ;; (named-fn-body '(define (test x) (+ x 1)))

  (define (compile-named-function exp env)
    (define-variable! (definition-variable exp) env)
    (list (compile-function (definition-variable exp)
                            (named-fn-params exp) (named-fn-body exp) env)
          (list (definition-variable exp))))

  ;; (print-code (compiled-code->string
  ;;              (compile-named-function
  ;;               '(define (test x) (+ x 1) (* 3 4))
  ;;               global-environment)))

  ;; (print-code (compiled-code->string
  ;;              (compile-named-function
  ;;               '(define (test x y) (+ x y) (* 3 4))
  ;;               global-environment)))

  ;; (print-code (compiled-code->string
  ;;              (compile
  ;;               '(define (test x y) (+ x y) (* 3 4))
  ;;               global-environment)))
#+END_SRC

Теперь можно скомиплировать вызовы примитивов и скомпонованных процедур.
#+NAME: compile_application
#+BEGIN_SRC scheme :noweb yes
  (define (compile-application exp env)
    (format #t "compile-application: exp ~A ~%" exp)
    (cond ((primitive-proc? exp env)
           (compile-primitive exp env))
          (else (compile-compound exp env))))

  ;; (compile-application '(list 1 2 3 4) global-environment)

  (define (compile-call-params-in-c-syntax params)
    (define (compile-call-params-in-c-syntax-rec params-in-lisp params-in-c)
      (if (null? params-in-lisp)
          params-in-c
          (let ((cur-param (if (null? (cdr params-in-lisp))
                               (list  (car params-in-lisp))
                               (list  (car params-in-lisp) COMMA))))
            (compile-call-params-in-c-syntax-rec (cdr params-in-lisp)
                                               (append params-in-c cur-param)))))
    ;; (format #t "~A ~%" params)
    (compile-call-params-in-c-syntax-rec params '()))


  (define (compile-compound-proc-call exp env)
    (let* ((compiled-args-with-names (compile-args (operands exp) env))
           (compiled-code (connect-compiled-exps compiled-args-with-names))
           (compiled-code-names (map (lambda (code)
                                       (caadr code))
                                     compiled-args-with-names))
           (service-fn-name (generate-name-string exp))
           (call-service-fn (append (list service-fn-name) (compile-parenthesis '())))
           (call-params-in-c-syntax (compile-call-params-in-c-syntax compiled-code-names))
           (return-value (append (list 'return (operator exp))
                                 (compile-parenthesis call-params-in-c-syntax)
                                 (list SEMICOLON))))
      (format #t "compile-compound-proc-call: compiled-code ~A ~% ~%" compiled-code)

      (list (append (list 'val ASTERISK service-fn-name)
              (compile-parenthesis '())
              (compile-braces (append
                               compiled-code
                               return-value)))
            (list call-service-fn))))

  (define (compile-compound exp env)
    (if (lookup-variable (operator exp) env)
        (compile-compound-proc-call exp env)))

#+END_SRC

#+NAME: compile_compound-procs-tests
#+BEGIN_SRC scheme :noweb yes
  (print-code (compiled-code->string
               (compile
                '(define (test x y) (+ x y) (* 3 4))
                global-environment)))

  (print-code (compiled-code->string
               (compile '(test 1 2) global-environment)))

  (print-code (compiled-code->string
               (compile '(define test (list 1 2 3)) global-environment)))
#+END_SRC

~Реализация if~

Нам необходимы ветвления.
В лиспе ~true~ все, что не пустой список. В си ~true~ все, что не
NULL. Так что нам придется приспособить логику двух языков друг к другу
так, чтобы код, написанный на лиспе, адекватно работал на си.

Во-первых, нам необходимо скомпилировать условие, консеквент и
антецедент. А затем уже скопилировать иф таким обрзом, чтоб в зависимости
от истинности условия выполнялась та или иная ветка.
У нас получится что-то вроде этого:

#+NAME: compile_if_example
#+BEGIN_SRC c :noweb yes
  val* condition() {
      /* some compiled code  */
  }

  val*  consequent() {
      /* some compiled code  */
  }

  val* antecedent() {
      /* some compiled code  */
  }

  val* current_if() {
      val* condition_res = consequent();

      if ( symbol_predicate( condition_res ) ) {

          /* printf("eval_if symbol\n"); */
          if ( eq_names_predicate("true",
                                  condition_res->uni_val.char_val ) ) {

                  return consequent();
          }   else {
              return antecedent();
          }
      } else if (true_predicate ( condition_res ) ) {
          return consequent();

      } else {
          return antecedent();

      }
  }
#+END_SRC

~Компиляция ифа~.
#+NAME: compile_if
#+BEGIN_SRC scheme :noweb yes
  (define (compile-if exp env)
    ;; компилируем код для условия, консеквента и антецедента
    (let* ((condition-code (compile (if-predicate exp) env))
           (consequent (compile (if-consequent exp) env))
           (consequent-code  (if (and (pair? consequent)
                                      (eq? (caar consequent) 'existing_var))
                                 (return-value-constructor (get-names-and-calls consequent))
                                 consequent)))
      (format #t "consequent-code ~A ~%" consequent-code)

      (let*(
           (alternative-code (compile (if-alternative exp) env))
           ;; компилируем переменную, в которую бдем записывать результат выполния условия
           (conpidion-result-var (generate-name-string exp))
           (assign-condition-result (list 'val ASTERISK
                                          conpidion-result-var '= (cadr condition-code)
                                          SEMICOLON))
           ;; компилируем возвращаемое значение консеквента и антецедента
           (return_consequent (list 'return
                                    (cadr consequent-code)
                                    SEMICOLON))
           (return_alternative (list 'return
                                     (cadr alternative-code)
                                     SEMICOLON))
           ;; компилируем имя и вызов служебной функции, внутри которой
           ;; будет исполняться иф
           (service-fn-name (string-append
                             conpidion-result-var "_if_fn"))
           (call-service-fn (append (list service-fn-name) (compile-parenthesis '()))))
      (format #t "consequent-code ~A ~%" consequent)
      ;; компилируем служебную функцию
      (list (append  (list 'val ASTERISK service-fn-name)
                     (compile-parenthesis '())
                     (compile-braces
                      ;; соединяем код условия, консеквента и антецедента
                      (append (connect-compiled-exps condition-code)
                              (connect-compiled-exps consequent-code)
                              (connect-compiled-exps alternative-code)
                              ;; присоединяем к нему присваивание переменной результата выполнения
                              ;; условия
                              assign-condition-result
                              ;; компиляция проверки условия
                              (list 'if (compile-parenthesis (list 'symbol_predicate
                                                                   (compile-parenthesis
                                                                    conpidion-result-var)))
                                    (compile-braces
                                     (list 'if
                                           (compile-parenthesis
                                            (list 'eq_names_predicate
                                                  (compile-parenthesis
                                                   (list "\"true\"" COMMA
                                                         (string-append
                                                          conpidion-result-var
                                                          "->uni_val.char_val")))))
                                           (compile-braces return_consequent)
                                           'else
                                           (compile-braces return_alternative))))
                              (list 'else 'if
                                    (compile-parenthesis
                                     (list 'true_predicate
                                           (compile-parenthesis conpidion-result-var)))
                                    (compile-braces return_consequent)
                                    'else
                                    (compile-braces return_alternative)))))
            ;; если не обернуть в список дополнительно, то ничего не заработает
            ;; хорошо бы узнать, почему
            (list call-service-fn)))))

#+END_SRC

#+NAME: compile_if_tests
#+BEGIN_SRC scheme :noweb yes
  (print-code (compiled-code->string (compile '(if (+ 1 2)
                                                   2
                                                   3) global-environment)))

  (print-code (compiled-code->string (compile '(if (true? 1)
                                                      2
                                                      3) global-environment)))

  (print-code (compiled-code->string (compile '(if (= 1 2)
                                                      4
                                                      3) global-environment)))

  (print-code (compiled-code->string (compile '(if (= n 2)
                                                   (* n (test (- 3 1)))
                                                   "\"false\"")
                                              global-environment)))

  (print-code (compiled-code->string (compile
                                      '(define (factorial n)
                                        (if (= n 0)
                                            1
                                            (* n (factorial (- n 1)))))
                                      global-environment)))

  (print-code (compiled-code->string (compile '(define n 10) global-environment)))

  (print-code (compiled-code->string (compile '(define (test x)
                                                 (+ x 1)) global-environment)))

  (print-code (compiled-code->string (compile '(if (= n 2)
                                                   (* n (test (- 3 1)))
                                                   "\"false\"")
                                              global-environment)))

  ;; (print-code (compiled-code->string (compile '(list 1 2 3 4) global-environment)))

  (print-code (compiled-code->string
               (compile '(define (my-reverse-rec lst new-lst)
                          (if (null? lst)
                              new-lst
                              (my-reverse-rec (cdr lst) (cons (car lst) new-lst))))
                        global-environment)))

  (print-code (compiled-code->string
               (compile
                '(list) global-environment)))

  (print-code (compiled-code->string
               (compile '(define (my-reverse lst)
                           (define (my-reverse-rec lst new-lst)
                             (if (null? lst)
                                 new-lst
                                 (my-reverse-rec (cdr lst)  (cons (car lst) new-lst))))
                           (my-reverse-rec lst (list))) global-environment)))

  (print-code (compiled-code->string
               (compile
                '(define (test x)
                   (define n 10)
                   (* x n))
                global-environment)))
#+END_SRC
~компиляция заковыченных выражений~

Заковыченное - заквотированное выражение - это выражение, которое не
вычисляется.
Следовательно, все, что нужно, - это скомпилировать выражение "как
есть". Если заковыченна цифра, то компилируем само число, если заковычен
символ, вроде ~'d~, то компилируем символ d.
Но есть некоторая деталь. Предположим, мы получили на вход заковыченное
выражение вида ~'(define n 10)~. Перед тем, как скомпилировать список,
нам нужно правильно скомплировать его аргументы. Если мы просто передадим
все аргументы списка в компилятор, то она начнет "спотыкаться" сначала об
define - после этго символа компилятор будет ожидать определение, затем
не смодет "переварить" переменную n, ну и т.д.

Поэтому перед тем, как вызвать компиляцию списка и его аргументов,
обойдем список и превратим все его аргументы в список строк. И только
затем начнем компилировать.

#+NAME: code
#+BEGIN_SRC forth :tangle code.scheme :noweb tangle :exports code :padline no :comments none
  <<main>>
  <<list_string>>
  <<service_procedure>>
  <<syntax_procs>>
  <<primitives>>
  <<environment>>
  <<trasform_code>>
  <<print_code>>
  <<compile_int_constructors>>
  <<compile_symbol_constructors>>
  <<compile_numbers>>
  <<compile_symbols>>
  <<compile_primitives_constructors>>
  <<compile_args>>
  <<compile_primitives>>
  <<define_definitiotn>>
  <<compile_service_assignments>>
  <<compile_definition_global_var>>
  <<compile_definition_local_var>>
  <<compile_sequences>>
  <<compile_function>>
  <<compile_lambda>>
  <<compile_named-function>>
  <<compile_application>>
  <<compile_if>>
#+END_SRC
