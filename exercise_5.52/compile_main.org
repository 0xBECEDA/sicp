#+STARTUP: showall indent hidestars

Пример компилятора из сикпа, который компилируют код из схемы в
псевдо-ассемблер (язык вычислителя с явным управлением из того же сикпа)

  #+BEGIN_SRC scheme
    (define (compile exp target linkage)
      (cond ((self-evaluating? exp)
             (compile-self-evaluating exp target linkage))
            ((quoted? exp) (compile-quoted exp target linkage))
            ((variable? exp)
             (compile-variable exp target linkage))
            ((assignment? exp)
             (compile-assignment exp target linkage))
            ((definition? exp)
             (compile-definition exp target linkage))
            ((if? exp) (compile-if exp target linkage))
            ((lambda? exp) (compile-lambda exp target linkage))
            ((begin? exp)
             (compile-sequence (begin-actions exp)
                               target
                               linkage))
            ((cond? exp) (compile (cond->if exp) target linkage))
            ((application? exp)
             (compile-application exp target linkage))
            (else
             (error "Неизвестный тип выражения -- COMPILE" exp))))

    (define (compile-linkage linkage)
      (cond ((eq? linkage ’return)
             (make-instruction-sequence '(continue) '()
                                         '((goto (reg continue)))))
            ((eq? linkage 'next)
             (empty-instruction-sequence))
            (else
             (make-instruction-sequence '() '()
                                         `((goto (label ,linkage)))))))

    (define (end-with-linkage linkage instruction-sequence)
      (preserving '(continue)
                   instruction-sequence
                   (compile-linkage linkage)))

    (define (compile-self-evaluating exp target linkage)
      (end-with-linkage linkage
                        (make-instruction-sequence '() (list target)
                                                    `((assign ,target (const ,exp))))))
    (define (compile-quoted exp target linkage)
      (end-with-linkage linkage
                        (make-instruction-sequence
                         '() (list target)
                         `((assign ,target
                                   (const ,(text-of-quotation exp)))))))

    (define (compile-variable exp target linkage)
      (end-with-linkage linkage
                        (make-instruction-sequence '(env) (list target)
                                                    `((assign ,target
                                                              (op lookup-variable-value)
                                                              (const ,exp)
                                                              (reg env))))))

    (define (compile-assignment exp target linkage)
      (let ((var (assignment-variable exp))
            (get-value-code
             (compile (assignment-value exp) 'val 'next)))
        (end-with-linkage linkage
                          (preserving '(env)
                                       get-value-code
                                       (make-instruction-sequence
                                        '(env val) (list target)
                                        `((perform (op set-variable-value!)
                                                   (const ,var)
                                                   (reg val)
                                                   (reg env))
                                          (assign ,target (const ok))))))))

    (define (compile-definition exp target linkage)
      (let ((var (definition-variable exp))
            (get-value-code
             (compile (definition-value exp) 'val 'next)))
        (end-with-linkage linkage
                          (preserving '(env)
                                       get-value-code
                                       (make-instruction-sequence
                                        '(env val) (list target)
                                        `((perform (op define-variable!)
                                                   (const ,var)
                                                   (reg val)
                                                   (reg env))
                                          (assign ,target (const ok))))))))


    (define (compile-if exp target linkage)
      (let ((t-branch (make-label 'true-branch))
            (f-branch (make-label 'false-branch))
            (after-if (make-label 'after-if)))
        (let ((consequent-linkage
               (if (eq? linkage 'next) after-if linkage)))
          (let ((p-code (compile (if-predicate exp) ’val ’next))
                (c-code
                 (compile
                  (if-consequent exp) target consequent-linkage))
                (a-code
                 (compile (if-alternative exp) target linkage)))
            (preserving '(env continue)
                         p-code
                         (append-instruction-sequences
                          (make-instruction-sequence '(val) '()
                                                      `((test (op false?) (reg val))
                                                        (branch (label ,f-branch))))
                          (parallel-instruction-sequences
                           (append-instruction-sequences t-branch c-code)
                           (append-instruction-sequences f-branch a-code))
                          after-if))))))

    (define (compile-sequence seq target linkage)
      (if (last-exp? seq)
          (compile (first-exp seq) target linkage)
          (preserving '(env continue)
                       (compile (first-exp seq) target 'next)
                       (compile-sequence (rest-exps seq) target linkage))))

    (define (compile-lambda exp target linkage)
      (let ((proc-entry (make-label 'entry))
            (after-lambda (make-label 'after-lambda)))
        (let ((lambda-linkage
               (if (eq? linkage 'next) after-lambda linkage)))
          (append-instruction-sequences
           (tack-on-instruction-sequence
            (end-with-linkage lambda-linkage
                              (make-instruction-sequence
                               '(env) (list target)
                               `((assign ,target
                                         (op make-compiled-procedure)
                                         (label ,proc-entry)
                                         (reg env)))))
            (compile-lambda-body exp proc-entry))
           after-lambda))))


    (define (make-compiled-procedure entry env)
      (list 'compiled-procedure entry env))

    (define (compiled-procedure? proc)
      (tagged-list? proc 'compiled-procedure))

    (define (compiled-procedure-entry c-proc) (cadr c-proc))

    (define (compiled-procedure-env c-proc) (caddr c-proc))

    (define (compile-lambda-body exp proc-entry)
      (let ((formals (lambda-parameters exp)))
        (append-instruction-sequences
         (make-instruction-sequence '(env proc argl) '(env)
                                     `(,proc-entry
                                       (assign env (op compiled-procedure-env) (reg proc))
                                       (assign env
                                               (op extend-environment)
                                               (const ,formals)
                                               (reg argl)
                                               (reg env))))
         (compile-sequence (lambda-body exp) 'val 'return))))

    (define (compile-application exp target linkage)
      (let ((proc-code (compile (operator exp) 'proc 'next))
            (operand-codes
             (map (lambda (operand) (compile operand 'val 'next))
                  (operands exp))))
        (preserving '(env continue)
                     proc-code
                     (preserving '(proc continue)
                                  (construct-arglist operand-codes)
                                  (compile-procedure-call target linkage)))))

    (define (construct-arglist operand-codes)
      (let ((operand-codes (reverse operand-codes)))
        (if (null? operand-codes)
            (make-instruction-sequence '() '(argl)
                                        '((assign argl (const ()))))
            (let ((code-to-get-last-arg
                   (append-instruction-sequences
                    (car operand-codes)
                    (make-instruction-sequence '(val) '(argl)
                                                '((assign argl (op list) (reg val)))))))
              (if (null? (cdr operand-codes))
                  code-to-get-last-arg
                  (preserving '(env)
                               code-to-get-last-arg
                               (code-to-get-rest-args
                                (cdr operand-codes))))))))

    (define (code-to-get-rest-args operand-codes)
      (let ((code-for-next-arg
             (preserving ’(argl)
                          (car operand-codes)
                          (make-instruction-sequence
                           '(val argl) '(argl)
                           '((assign argl
                                     (op cons) (reg val) (reg argl)))))))
        (if (null? (cdr operand-codes))
            code-for-next-arg
            (preserving '(env)
                         code-for-next-arg
                         (code-to-get-rest-args (cdr operand-codes))))))

    (define (compile-procedure-call target linkage)
      (let ((primitive-branch (make-label 'primitive-branch))
            (compiled-branch (make-label 'compiled-branch))
            (after-call (make-label 'after-call)))
        (let ((compiled-linkage
               (if (eq? linkage 'next) after-call linkage)))
          (append-instruction-sequences
           (make-instruction-sequence '(proc) '()
                                       `((test (op primitive-procedure?) (reg proc))
                                         (branch (label ,primitive-branch))))
           (parallel-instruction-sequences
            (append-instruction-sequences
             compiled-branch
             (compile-proc-appl target compiled-linkage))
            (append-instruction-sequences
             primitive-branch
             (end-with-linkage linkage
                               (make-instruction-sequence
                                '(proc argl)
                                (list target)
                                '((assign ,target
                                          (op apply-primitive-procedure)
                                          (reg proc)
                                          (reg argl)))))))
           after-call))))


    (define (compile-proc-appl target linkage)
      (cond ((and (eq? target 'val) (not (eq? linkage 'return)))
             (make-instruction-sequence '(proc) all-regs
                                         `((assign continue (label ,linkage))
                                           (assign val (op compiled-procedure-entry)
                                                   (reg proc))
                                           (goto (reg val)))))
            ((and (not (eq? target 'val))
                  (not (eq? linkage 'return)))
             (let ((proc-return (make-label 'proc-return)))
               (make-instruction-sequence '(proc) all-regs
                                          `((assign continue (label ,proc-return))

                                            (assign val (op compiled-procedure-entry)
                                                    (reg proc))
                                            (goto (reg val))
                                            ,proc-return
                                            (assign ,target (reg val))
                                            (goto (label ,linkage))))))
            ((and (eq? target 'val) (eq? linkage 'return))
             (make-instruction-sequence '(proc continue) all-regs
                                         '((assign val (op compiled-procedure-entry)
                                                   (reg proc))
                                           (goto (reg val)))))
            ((and (not (eq? target 'val)) (eq? linkage 'return))
             (error "Тип связи return, цель не val -- COMPILE"
                    target))))

    (define (append-instruction-sequences . seqs)
      (define (append-2-sequences seq1 seq2)
        (make-instruction-sequence
         (list-union (registers-needed seq1)
                     (list-difference (registers-needed seq2)
                                      (registers-modified seq1)))
         (list-union (registers-modified seq1)
                     (registers-modified seq2))
         (append (statements seq1) (statements seq2))))

      (define (append-seq-list seqs)
        (if (null? seqs)
            (empty-instruction-sequence)
            (append-2-sequences (car seqs)
                                (append-seq-list (cdr seqs)))))
      (append-seq-list seqs))

    (define (list-union s1 s2)
      (cond ((null? s1) s2)
            ((memq (car s1) s2) (list-union (cdr s1) s2))
            (else (cons (car s1) (list-union (cdr s1) s2)))))
    (define (list-difference s1 s2)
      (cond ((null? s1) ’())
            ((memq (car s1) s2) (list-difference (cdr s1) s2))
            (else (cons (car s1)
                        (list-difference (cdr s1) s2)))))

    (define (preserving regs seq1 seq2)
      (if (null? regs)
          (append-instruction-sequences seq1 seq2)
          (let ((first-reg (car regs)))
            (if (and (needs-register? seq2 first-reg)
                     (modifies-register? seq1 first-reg))
                (preserving (cdr regs)
                            (make-instruction-sequence
                             (list-union (list first-reg)
                                         (registers-needed seq1))
                             (list-difference (registers-modified seq1)
                                              (list first-reg))
                             (append `((save ,first-reg))
                                      (statements seq1)
                                      `((restore ,first-reg))))
                            seq2)
                (preserving (cdr regs) seq1 seq2)))))

    (define (tack-on-instruction-sequence seq body-seq)
      (make-instruction-sequence
       (registers-needed seq)
       (registers-modified seq)
       (append (statements seq) (statements body-seq))))

    (define (parallel-instruction-sequences seq1 seq2)
      (make-instruction-sequence
       (list-union (registers-needed seq1)
                   (registers-needed seq2))
       (list-union (registers-modified seq1)
                   (registers-modified seq2))
       (append (statements seq1) (statements seq2))))

    (define (registers-needed s)
      (if (symbol? s) '() (car s)))
    (define (registers-modified s)
      (if (symbol? s) '() (cadr s)))
    (define (statements s)
      (if (symbol? s) (list s) (caddr s)))

    (define (needs-register? seq reg)
      (memq reg (registers-needed seq)))

    (define (modifies-register? seq reg)
      (memq reg (registers-modified seq)))

  #+END_SRC


~Компиляция main~

Идея очень простая. Каждой сишной программе нужна входная точка - ~main~,
следовательно, любая скомпилированная программа должна иметь ~main~.

Я думаю, что при компиляции каждое выражение будет компилироваться внутри
отдельной процедуры, исполняться там, а затем его результат будет
возвращен в ~main~.

Таким образм выражение ~(define n 6)~ превратится в что-то вроде этого:

#+BEGIN_SRC c
  val* proc1() {
      int* number = (int*)malloc(sizeof(int));
      ,*number = 6;
      val* n = int_val_constructor(number);
      return n;
  }

  int main () {
      proc1();
  }
  #+END_SRC

Тем не менее нужно понять, вызывается ли определение из глобального
окружения или нет. От этого зависит каким образом будет компилироваться
код, ведь представленный выше вариант определит переменную локально.

Но начнем с простого - напишем фукцию, которая скомпилирует сишный main.

#+NAME: main
#+BEGIN_SRC scheme
  ;; преставление { и } в компилируемом коде
  ;; (define OPENING_BRACE 'OPENING_BRACE)
  ;; (define CLOSING_BRACE 'CLOSING_BRACE)

  (define OPENING_BRACE #\{)
  (define CLOSING_BRACE #\})

  ;; преставление ( и ) в компилируемом коде
  ;; (define OPENING_PARENTHESIS 'OPENING_PARENTHESIS)
  ;; (define CLOSING_PARENTHESIS 'CLOSING_PARENTHESIS)

  (define OPENING_PARENTHESIS #\()
  (define CLOSING_PARENTHESIS #\))

  ;; преставление [ и ] в компилируемом коде
  ;; (define OPENING_BRACKET 'OPENING_BRACKET)
  ;; (define CLOSING_BRACKET 'CLOSING_BRACKET)

  (define OPENING_BRACKET #\[)
  (define CLOSING_BRACKET #\])

  ;; преставление : и , в компилируемом коде
  (define СOLON 'COLON)
  (define СOMMA 'СOMMA)

  ;; преставление * в компилируемом коде
  (define ASTERISK 'ASTERISK)

  ;; преставление ; в компилируемом коде
  ;; (define SEMICOLON 'SEMICOLON)

  (define SEMICOLON #\;)

  ;; представление ... в компилируемом коде
  (define ELLIPSIS 'ELLIPSIS)

  ;; счетчик, чтоб иметь возможность с помощью него создавать уникальные имена для
  ;; лямбд и проч.
  (define counter 0)


  ;; констуркторы, присоединяющие символы, эмулирующие синтакис, к скомпилированному коду
  (define(compile-braces code)
    (if (pair? code)
        (append (list OPENING_BRACE)
                code
                (list CLOSING_BRACE))
        (append (list OPENING_BRACE)
                (list code)
                (list CLOSING_BRACE))))


  (define(compile-parenthesis code)
    (append (list OPENING_PARENTHESIS)
            code
            (list CLOSING_PARENTHESIS)))

  (define(compile-brackets code)
    (append (list OPENING_BRACKET)
            code
            (list CLOSING_BRACKET)))

  (define(compile-colon code)
    (append code
            (list COLON)))

  (define(compile-semicolon code)
    (append code
            (list SEMICOLON)))

  (define(compile-ellipsis code)
    (append code
            (list ELLIPSIS)))


  (define (compile-main fn-calls)
    (let ((code-into-braces (compile-braces fn-calls)))
      (append (list 'int 'main)
              (compile-parenthesis())
              code-into-braces)))


  ;; (list COMMA)

  (compile-main (append '(proc) (compile-parenthesis())))
  #+END_SRC

Надо решить несколько проблем:
- определять из какого окружения что будет вызываться
- генерировать уникальные имена для лямбд и служебных функций, которых в
  исходном коде нет, но они будут вызываться из main, и в них будет
  исполняться введенный код
- создать парсер, который будет переводить полученный список в строку
