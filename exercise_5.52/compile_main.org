#+STARTUP: showall indent hidestars

Пример компилятора из сикпа, который компилируют код из схемы в
псевдо-ассемблер (язык вычислителя с явным управлением из того же сикпа)

  #+BEGIN_SRC scheme
    (define (compile exp target linkage)
      (cond ((self-evaluating? exp)
             (compile-self-evaluating exp target linkage))
            ((quoted? exp) (compile-quoted exp target linkage))
            ((variable? exp)
             (compile-variable exp target linkage))
            ((assignment? exp)
             (compile-assignment exp target linkage))
            ((definition? exp)
             (compile-definition exp target linkage))
            ((if? exp) (compile-if exp target linkage))
            ((lambda? exp) (compile-lambda exp target linkage))
            ((begin? exp)
             (compile-sequence (begin-actions exp)
                               target
                               linkage))
            ((cond? exp) (compile (cond->if exp) target linkage))
            ((application? exp)
             (compile-application exp target linkage))
            (else
             (error "Неизвестный тип выражения -- COMPILE" exp))))

    (define (compile-linkage linkage)
      (cond ((eq? linkage ’return)
             (make-instruction-sequence '(continue) '()
                                         '((goto (reg continue)))))
            ((eq? linkage 'next)
             (empty-instruction-sequence))
            (else
             (make-instruction-sequence '() '()
                                         `((goto (label ,linkage)))))))

    (define (end-with-linkage linkage instruction-sequence)
      (preserving '(continue)
                   instruction-sequence
                   (compile-linkage linkage)))

    (define (compile-self-evaluating exp target linkage)
      (end-with-linkage linkage
                        (make-instruction-sequence '() (list target)
                                                    `((assign ,target (const ,exp))))))
    (define (compile-quoted exp target linkage)
      (end-with-linkage linkage
                        (make-instruction-sequence
                         '() (list target)
                         `((assign ,target
                                   (const ,(text-of-quotation exp)))))))

    (define (compile-variable exp target linkage)
      (end-with-linkage linkage
                        (make-instruction-sequence '(env) (list target)
                                                    `((assign ,target
                                                              (op lookup-variable-value)
                                                              (const ,exp)
                                                              (reg env))))))

    (define (compile-assignment exp target linkage)
      (let ((var (assignment-variable exp))
            (get-value-code
             (compile (assignment-value exp) 'val 'next)))
        (end-with-linkage linkage
                          (preserving '(env)
                                       get-value-code
                                       (make-instruction-sequence
                                        '(env val) (list target)
                                        `((perform (op set-variable-value!)
                                                   (const ,var)
                                                   (reg val)
                                                   (reg env))
                                          (assign ,target (const ok))))))))

    (define (compile-definition exp target linkage)
      (let ((var (definition-variable exp))
            (get-value-code
             (compile (definition-value exp) 'val 'next)))
        (end-with-linkage linkage
                          (preserving '(env)
                                       get-value-code
                                       (make-instruction-sequence
                                        '(env val) (list target)
                                        `((perform (op define-variable!)
                                                   (const ,var)
                                                   (reg val)
                                                   (reg env))
                                          (assign ,target (const ok))))))))


    (define (compile-if exp target linkage)
      (let ((t-branch (make-label 'true-branch))
            (f-branch (make-label 'false-branch))
            (after-if (make-label 'after-if)))
        (let ((consequent-linkage
               (if (eq? linkage 'next) after-if linkage)))
          (let ((p-code (compile (if-predicate exp) ’val ’next))
                (c-code
                 (compile
                  (if-consequent exp) target consequent-linkage))
                (a-code
                 (compile (if-alternative exp) target linkage)))
            (preserving '(env continue)
                         p-code
                         (append-instruction-sequences
                          (make-instruction-sequence '(val) '()
                                                      `((test (op false?) (reg val))
                                                        (branch (label ,f-branch))))
                          (parallel-instruction-sequences
                           (append-instruction-sequences t-branch c-code)
                           (append-instruction-sequences f-branch a-code))
                          after-if))))))

    (define (compile-sequence seq target linkage)
      (if (last-exp? seq)
          (compile (first-exp seq) target linkage)
          (preserving '(env continue)
                       (compile (first-exp seq) target 'next)
                       (compile-sequence (rest-exps seq) target linkage))))

    (define (compile-lambda exp target linkage)
      (let ((proc-entry (make-label 'entry))
            (after-lambda (make-label 'after-lambda)))
        (let ((lambda-linkage
               (if (eq? linkage 'next) after-lambda linkage)))
          (append-instruction-sequences
           (tack-on-instruction-sequence
            (end-with-linkage lambda-linkage
                              (make-instruction-sequence
                               '(env) (list target)
                               `((assign ,target
                                         (op make-compiled-procedure)
                                         (label ,proc-entry)
                                         (reg env)))))
            (compile-lambda-body exp proc-entry))
           after-lambda))))


    (define (make-compiled-procedure entry env)
      (list 'compiled-procedure entry env))

    (define (compiled-procedure? proc)
      (tagged-list? proc 'compiled-procedure))

    (define (compiled-procedure-entry c-proc) (cadr c-proc))

    (define (compiled-procedure-env c-proc) (caddr c-proc))

    (define (compile-lambda-body exp proc-entry)
      (let ((formals (lambda-parameters exp)))
        (append-instruction-sequences
         (make-instruction-sequence '(env proc argl) '(env)
                                     `(,proc-entry
                                       (assign env (op compiled-procedure-env) (reg proc))
                                       (assign env
                                               (op extend-environment)
                                               (const ,formals)
                                               (reg argl)
                                               (reg env))))
         (compile-sequence (lambda-body exp) 'val 'return))))

    (define (compile-application exp target linkage)
      (let ((proc-code (compile (operator exp) 'proc 'next))
            (operand-codes
             (map (lambda (operand) (compile operand 'val 'next))
                  (operands exp))))
        (preserving '(env continue)
                     proc-code
                     (preserving '(proc continue)
                                  (construct-arglist operand-codes)
                                  (compile-procedure-call target linkage)))))

    (define (construct-arglist operand-codes)
      (let ((operand-codes (reverse operand-codes)))
        (if (null? operand-codes)
            (make-instruction-sequence '() '(argl)
                                        '((assign argl (const ()))))
            (let ((code-to-get-last-arg
                   (append-instruction-sequences
                    (car operand-codes)
                    (make-instruction-sequence '(val) '(argl)
                                                '((assign argl (op list) (reg val)))))))
              (if (null? (cdr operand-codes))
                  code-to-get-last-arg
                  (preserving '(env)
                               code-to-get-last-arg
                               (code-to-get-rest-args
                                (cdr operand-codes))))))))

    (define (code-to-get-rest-args operand-codes)
      (let ((code-for-next-arg
             (preserving ’(argl)
                          (car operand-codes)
                          (make-instruction-sequence
                           '(val argl) '(argl)
                           '((assign argl
                                     (op cons) (reg val) (reg argl)))))))
        (if (null? (cdr operand-codes))
            code-for-next-arg
            (preserving '(env)
                         code-for-next-arg
                         (code-to-get-rest-args (cdr operand-codes))))))

    (define (compile-procedure-call target linkage)
      (let ((primitive-branch (make-label 'primitive-branch))
            (compiled-branch (make-label 'compiled-branch))
            (after-call (make-label 'after-call)))
        (let ((compiled-linkage
               (if (eq? linkage 'next) after-call linkage)))
          (append-instruction-sequences
           (make-instruction-sequence '(proc) '()
                                       `((test (op primitive-procedure?) (reg proc))
                                         (branch (label ,primitive-branch))))
           (parallel-instruction-sequences
            (append-instruction-sequences
             compiled-branch
             (compile-proc-appl target compiled-linkage))
            (append-instruction-sequences
             primitive-branch
             (end-with-linkage linkage
                               (make-instruction-sequence
                                '(proc argl)
                                (list target)
                                '((assign ,target
                                          (op apply-primitive-procedure)
                                          (reg proc)
                                          (reg argl)))))))
           after-call))))


    (define (compile-proc-appl target linkage)
      (cond ((and (eq? target 'val) (not (eq? linkage 'return)))
             (make-instruction-sequence '(proc) all-regs
                                         `((assign continue (label ,linkage))
                                           (assign val (op compiled-procedure-entry)
                                                   (reg proc))
                                           (goto (reg val)))))
            ((and (not (eq? target 'val))
                  (not (eq? linkage 'return)))
             (let ((proc-return (make-label 'proc-return)))
               (make-instruction-sequence '(proc) all-regs
                                          `((assign continue (label ,proc-return))

                                            (assign val (op compiled-procedure-entry)
                                                    (reg proc))
                                            (goto (reg val))
                                            ,proc-return
                                            (assign ,target (reg val))
                                            (goto (label ,linkage))))))
            ((and (eq? target 'val) (eq? linkage 'return))
             (make-instruction-sequence '(proc continue) all-regs
                                         '((assign val (op compiled-procedure-entry)
                                                   (reg proc))
                                           (goto (reg val)))))
            ((and (not (eq? target 'val)) (eq? linkage 'return))
             (error "Тип связи return, цель не val -- COMPILE"
                    target))))

    (define (append-instruction-sequences . seqs)
      (define (append-2-sequences seq1 seq2)
        (make-instruction-sequence
         (list-union (registers-needed seq1)
                     (list-difference (registers-needed seq2)
                                      (registers-modified seq1)))
         (list-union (registers-modified seq1)
                     (registers-modified seq2))
         (append (statements seq1) (statements seq2))))

      (define (append-seq-list seqs)
        (if (null? seqs)
            (empty-instruction-sequence)
            (append-2-sequences (car seqs)
                                (append-seq-list (cdr seqs)))))
      (append-seq-list seqs))

    (define (list-union s1 s2)
      (cond ((null? s1) s2)
            ((memq (car s1) s2) (list-union (cdr s1) s2))
            (else (cons (car s1) (list-union (cdr s1) s2)))))
    (define (list-difference s1 s2)
      (cond ((null? s1) ’())
            ((memq (car s1) s2) (list-difference (cdr s1) s2))
            (else (cons (car s1)
                        (list-difference (cdr s1) s2)))))

    (define (preserving regs seq1 seq2)
      (if (null? regs)
          (append-instruction-sequences seq1 seq2)
          (let ((first-reg (car regs)))
            (if (and (needs-register? seq2 first-reg)
                     (modifies-register? seq1 first-reg))
                (preserving (cdr regs)
                            (make-instruction-sequence
                             (list-union (list first-reg)
                                         (registers-needed seq1))
                             (list-difference (registers-modified seq1)
                                              (list first-reg))
                             (append `((save ,first-reg))
                                      (statements seq1)
                                      `((restore ,first-reg))))
                            seq2)
                (preserving (cdr regs) seq1 seq2)))))

    (define (tack-on-instruction-sequence seq body-seq)
      (make-instruction-sequence
       (registers-needed seq)
       (registers-modified seq)
       (append (statements seq) (statements body-seq))))

    (define (parallel-instruction-sequences seq1 seq2)
      (make-instruction-sequence
       (list-union (registers-needed seq1)
                   (registers-needed seq2))
       (list-union (registers-modified seq1)
                   (registers-modified seq2))
       (append (statements seq1) (statements seq2))))

    (define (registers-needed s)
      (if (symbol? s) '() (car s)))
    (define (registers-modified s)
      (if (symbol? s) '() (cadr s)))
    (define (statements s)
      (if (symbol? s) (list s) (caddr s)))

    (define (needs-register? seq reg)
      (memq reg (registers-needed seq)))

    (define (modifies-register? seq reg)
      (memq reg (registers-modified seq)))

  #+END_SRC


~Компиляция main~

Идея очень простая. Каждой сишной программе нужна входная точка - ~main~,
следовательно, любая скомпилированная программа должна иметь ~main~.

Я думаю, что при компиляции каждое выражение будет компилироваться внутри
отдельной процедуры, исполняться там, а затем его результат будет
возвращен в ~main~.

Таким образм выражение ~(define n 6)~ превратится в что-то вроде этого:

#+BEGIN_SRC c
  val* proc1() {
      int* number = (int*)malloc(sizeof(int));
      ,*number = 6;
      val* n = int_val_constructor(number);
      return n;
  }

  int main () {
      proc1();
  }
  #+END_SRC

Тем не менее нужно понять, вызывается ли определение из глобального
окружения или нет. От этого зависит каким образом будет компилироваться
код, ведь представленный выше вариант определит переменную локально.

Но начнем с простого - напишем фукцию, которая скомпилирует сишный main.

#+NAME: main
#+BEGIN_SRC scheme :noweb yes
  ;; преставление { и } в компилируемом коде
  ;; (define OPENING_BRACE 'OPENING_BRACE)
  ;; (define CLOSING_BRACE 'CLOSING_BRACE)

  (define OPENING_BRACE #\{)
  (define CLOSING_BRACE #\})

  ;; преставление ( и ) в компилируемом коде
  ;; (define OPENING_PARENTHESIS 'OPENING_PARENTHESIS)
  ;; (define CLOSING_PARENTHESIS 'CLOSING_PARENTHESIS)

  (define OPENING_PARENTHESIS #\()
  (define CLOSING_PARENTHESIS #\))

  ;; преставление [ и ] в компилируемом коде
  ;; (define OPENING_BRACKET 'OPENING_BRACKET)
  ;; (define CLOSING_BRACKET 'CLOSING_BRACKET)

  (define OPENING_BRACKET #\[)
  (define CLOSING_BRACKET #\])

  ;; преставление : и , в компилируемом коде
  (define СOLON #\:)
  (define СOMMA #\,)

  ;; преставление * в компилируемом коде
  (define ASTERISK #\*)

  ;; преставление ; в компилируемом коде
  ;; (define SEMICOLON 'SEMICOLON)

  (define SEMICOLON #\;)

  ;; представление ... в компилируемом коде
  (define ELLIPSIS 'ELLIPSIS)

  ;; констуркторы, присоединяющие символы, эмулирующие синтакис, к скомпилированному коду
  (define(compile-braces code)
    (if (pair? code)
        (append (list OPENING_BRACE)
                code
                (list CLOSING_BRACE))
        (append (list OPENING_BRACE)
                (list code)
                (list CLOSING_BRACE))))

  (define(compile-parenthesis code)
    (if (pair? code)
        (append (list OPENING_PARENTHESIS)
                code
                (list CLOSING_PARENTHESIS))
        (append (list OPENING_PARENTHESIS)
                (list code)
                (list CLOSING_PARENTHESIS))))

  (define(compile-brackets code)
    (if (pair? code)
        (append (list OPENING_BRACKET)
                code
                (list CLOSING_BRACKET))
        (append (list OPENING_BRACKET)
                (list code)
                (list CLOSING_BRACKET))))

  (define(compile-colon code)
    (append code
            (list COLON)))

  (define(compile-semicolon code)
    (append code
            (list SEMICOLON)))

  (define(compile-ellipsis code)
    (append code
            (list ELLIPSIS)))


  (define (compile-main fn-calls)
    (let ((code-into-braces (compile-braces fn-calls)))
      (append (list 'int 'main)
              (compile-parenthesis())
              code-into-braces)))


  ;; (list COMMA)

  (compile-main (append '(proc) (compile-parenthesis())))
  #+END_SRC

Надо решить несколько проблем:
- определять из какого окружения что будет вызываться
- генерировать уникальные имена для лямбд и служебных функций, которых в
  исходном коде нет, но они будут вызываться из main, и в них будет
  исполняться введенный код
- создать парсер, который будет переводить полученный список в строку

Генерация новых имен:
- получаем выражение
- переводим его в строку
- хешируем его, хэш = новое имя.
- сохраняем где-то этот хеш (возможно, присоединяем к выражению)

Данный функционал пригодится для сишного представления лямбд и вызова
прочих выражений, чтоб это не делать из мэйна.

#+NAME: list_string
#+BEGIN_SRC scheme :noweb yes
  ;; превращает выражение в строку
  (define (list->string lst)
    (define (rec-list->string lst retval-string)
      ;; (display "lst")
      ;; (display lst)
      ;; (newline)
      ;; (display "retval-string")
      ;; (display retval-string)
      ;; (newline)
      (if (null? lst)
          (string-append retval-string ")")
          (if (pair? (car lst))
              (begin
                ;; (newline)
                ;; (display "car pair")
                ;; (newline)
                (let (( result (string-append (rec-list->string (car lst) "(")
                                              (rec-list->string (cdr lst) ""))))
                  ;; (newline)
                  ;; (display "result")
                  ;; (display result)
                  ;; (newline)
                  (string-append retval-string result)))
              (cond ((symbol? (car lst)) (rec-list->string (cdr lst)
                                                           (string-append retval-string
                                                                          (symbol->string
                                                                           (car lst)))))
                    ((number? (car lst)) (rec-list->string (cdr lst)
                                                           (string-append retval-string
                                                                          (number->string
                                                                           (car lst)))))
                    (else (rec-list->string (cdr lst)
                                            (string-append retval-string
                                                           "string" (car lst))))))))

    (rec-list->string lst "("))


  ;; тесты
  ;; (list->string '(1 2 3))

  ;; (list->string '(lambda (x) (+ x 1)))

  ;; (list->string '(define (factorial n)
  ;;                  (if (= n 0)
  ;;                      1
  ;;                      (* n (factorial (= n 1))))))

  ;; (list->string '(let ((a 3)
  ;;                      (b 4))
  ;;                  (+ 1 a b)))

  ;; (list->string '(1 2 "2"))

  ;; (list->string '(1 2 "(+ 1 2 )"))

  (define (exp->string exp)
    (list->string exp))

  ;; хэширует строку
  (define (hash-exp exp)
    (let ((string (exp->string exp)))
      (display "hash-exp: string ")
      (display string)
      (newline)
      (string-hash string)))

  ;; тесты
  ;; (hash-exp '(1 2 "(+ 1 2 )"))

  ;; (hash-exp '(let ((a 3)
  ;;                  (b 4))
  ;;              (+ 1 a b)))

  ;; (hash-exp '(let ((a 3)
  ;;                  (b 4))
  ;;              (+ 1 a b)))

  ;; (hash-exp '(define (factorial n)
  ;;              (if (= n 0)
  ;;                  1
  ;;                  (* n (factorial (= n 1))))))

  ;; создает "имя" для выражения
  (define (generate-name-string exp)
    (let* ((hash (hash-exp exp))
           (hash-string (number->string hash)))
      ;; добавляем букву, чтоб си в будущем счел хэш именем, а не числом
      (string-append "a" hash-string)))


  (generate-name-string
   '(define (factorial n)
      (if (= n 0)
          1
          (* n (factorial (= n 1))))))

  (generate-name-string
   '(1 2 2))

  (generate-name-string
   '(1 2 "2"))
 #+END_SRC

Данный код будет генерировать код для служебных функций. Таких
функций нет в изначальном коде, но они будут компилироваться, чтоб не
пришлось все выражения компилировать в мэйн.

Служебная функция вызывается без аргументов.
#+NAME: service_procedure
#+BEGIN_SRC scheme :noweb yes
  (define (compile-service-fn name body)
    (let ((code-into-braces (compile-braces fn-calls)))
      (append (list '*val 'name)
              (compile-parenthesis())
              code-into-braces)))
#+END_SRC


#+NAME: syntax_procs
#+BEGIN_SRC scheme :noweb yes
  (define (variable? exp) (symbol? exp))

  (define (quoted? exp)
    (tagged-list? exp 'quote))

  (define (text-of-quotation exp) (cadr exp))

  (define (tagged-list? exp tag)
    (if (pair? exp)
        (eq? (car exp) tag)
        false))

  (define (assignment? exp)
    (tagged-list? exp 'set!))

  (define (assignment-variable exp) (cadr exp))

  (define (assignment-value exp) (caddr exp))

  (define (definition? exp)
    (tagged-list? exp 'define))

  (define (definition-variable exp)
    (if (symbol? (cadr exp))
        (cadr exp)
        (caadr exp)))

  (define (definition-value exp)
    (if (symbol? (cadr exp))
        (caddr exp)
        (make-lambda (cdadr exp)
                     (cddr exp))))

  (define (lambda? exp) (tagged-list? exp 'lambda))

  (define (lambda-parameters exp) (cadr exp))

  (define (lambda-body exp) (cddr exp))

  (define (make-lambda parameters body)
    (cons 'lambda (cons parameters body)))

  (define (if? exp) (tagged-list? exp 'if))

  (define (if-predicate exp) (cadr exp))

  (define (if-consequent exp) (caddr exp))

  (define (if-alternative exp)
    (if (not (null? (cdddr exp)))
        (cadddr exp)
        'false))

  (define (make-if predicate consequent alternative)
    (list 'if predicate consequent alternative))

  (define (begin? exp) (tagged-list? exp 'begin))

  (define (begin-actions exp) (cdr exp))

  (define (last-exp? seq) (null? (cdr seq)))

  (define (first-exp seq) (car seq))

  (define (rest-exps seq) (cdr seq))

  (define (sequence->exp seq)
    (cond ((null? seq) seq)
          ((last-exp? seq) (first-exp seq))
          (else (make-begin seq))))

  (define (make-begin seq) (cons 'begin seq))

  (define (application? exp) (pair? exp))

  (define (operator exp) (car exp))

  (define (operands exp) (cdr exp))

  (define (no-operands? ops) (null? ops))

  (define (first-operand ops) (car ops))

  (define (rest-operands ops) (cdr ops))
#+END_SRC

~Построение окружений~

Они нужны только для того, чтоб компилятор мог отслеживать, в каком месте
появляется переменная и определена ли она была вообще. Получается, что
данные "окружения" будут состоять только из имен переменных без их
значений, поскольку на этапе компиляции значения не играют никакой роли.
Максимум можно указывать какого именно типа переменная - функция, число и
т.д., поскольку мы компилим код для си. Но это необязательно.

Окружения будут иметь списковую структуру как в сикпе, только если в
сикпе кадр состояит из двух списков, где первый список - это имена
переменных, а второй - это их значения, то мои псевдоокружения будут
состоять из кадров, которые будут содержать только имена переменных. Чем
ближе кадр к концу списка кадров, тем ближе он к глобальной области видимости.

То есть в окружении ((d f g h) (n test-fn factorial) (primitives-proc-names))
последий кадр является глобальным окружением.
При запуске компилятора будет устанавливаться начальное окружение,
состоящего только из кадра с примитивами.

При компиляции функции окружение будет расширяться кадром, который будет
наследовать все переменные глобального окружения + формальные параметры
функции, а затем будет дополняться новыми переменными, если в этом
возникнет необходимость. По завершению компиляции этот кадр будет
удаляться, поскольку никакие другие процедуры кроме текущей не должны
иметь доступ к переменным, объявленным внутри этой функции.

Связываем имена лисповых примитивов и сишных, чтоб знать, какие именно
имена компилировать, если использованы данные примитивы, поскольку имена
сишных примитивов и примитивов схемы не всегда совпадают из-за
синтаксических правил си банального неудобства.

#+NAME: primitives
#+BEGIN_SRC scheme :noweb yes
  (define (primitive-proc-bindings)
    (list (list 'car 'car)
          (list 'cdr 'cdr)
          (list 'cons 'cons)
          (list 'list 'make-list)
          (list  '+ 'add)
          (list  '- 'sub)
          (list  '* 'mul)
          (list  '/ 'division)
          (list  '= 'equal_numbers_predicate)
          (list  '> 'bigger_predicate)
          (list  '< 'smaller_predicate)
          (list  'reverse 'reverse)
          (list  'append 'append)
          (list  'assoc 'assoc)
          (list  'length 'length)
          (list  'last-pair 'last_pair)
          (list  'true? 'true_predicate)
          (list  'false? 'false_predicate)
          (list  'null? 'null_predicate)
          (list  'pair? 'pair_predicate)
          (list  'symbol? 'symbol_predicate)
          (list  'atom? 'atom_predicate)
          (list  'string? 'string_predicate)
          (list  'dotpair? 'dotpair_predicate)))

  (define (primitive-procedure-objects)
    (map (lambda (proc) (list 'primitive (cadr proc)))
         primitive-procedures))
#+END_SRC

Конструируем аналоги сикповых процедур для окружений, только с тем
расчетом, что у нас кадр состоит только из имен переменных.
#+NAME: environment
#+BEGIN_SRC scheme :noweb yes

  (define (enclosing-environment env) (cdr env))

  (define (first-frame env) (car env))

  (define the-empty-environment '())

  (define (add-binding-to-frame! var frame)
    (let* ((first-elt (car frame))
           (rest (cdr frame)))
      (set-car! frame var)
      (set-cdr! frame (list first-elt))
      (let ((last-elt (last-pair frame)))
        (set-cdr! last-elt rest)
        frame)))

  (define (extend-environment vars base-env)
    (cons vars base-env))

  (define (lookup-variable var env)
    (define (env-loop env)
      (define (scan vars)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((and (pair? var) (pair? (car vars)))
               (if (eq? (car var) (caar vars))
                   (car vars)
                   (scan (cdr vars))))
              ((and (not (pair? var)) (pair? (car vars)))
               (if (eq? var (caar vars))
                   (car vars)
                   (scan (cdr vars))))
              ((eq? var (car vars)) 'ok)
              (else (scan (cdr vars)))))
      (if (eq? env the-empty-environment)
          (error "Compile: Несвязанная переменная" var)
          (let ((frame (first-frame env)))
            (scan frame))))
    (env-loop env))

  (define (define-variable! var env)
    (let ((frame (first-frame env)))
      (define (scan vars vals)
        (cond ((null? vars)
               (add-binding-to-frame! var frame))
              ((and (pair? var) (pair? (car vars)))
               (if (eq? (car var) (caar vars))
                   (car vars)
                   (scan (cdr vars))))
              ((and (atom? var) (pair? (car vars)))
               (if (eq? var (caar vars))
                   (car vars)
                   (scan (cdr vars))))
              ((eq? var (car vars)) 'ok)
              (else (scan (cdr vars)))))
      (scan frame)))

  (define (delete-frame env)
    (set! env (cdr env)))

  (define (setup-environment)
    (let ((initial-env
           (extend-environment (primitive-proc-bindings)
                               the-empty-environment)))
      initial-env))

  ;; тесты

  (define test-env (setup-environment))

  (set! test-env (extend-environment '( f s n l) test-env))

  (add-binding-to-frame! 'd (first-frame test-env))

  (add-binding-to-frame! '(test_fn compound) (first-frame test-env))

  (lookup-variable '(test_fn compound) test-env)

  (lookup-variable 's test-env)

  (lookup-variable '(s n) test-env)

  (lookup-variable '(car car) test-env)

#+END_SRC

~Печать сгенерированного кода в файл си.~

Алгоритм, который переведет скомпилированный текстом код, в его тектовый
аналог.

Зачем это делать?
Си имеет разнообразный синтаксис, который нужно вкомпиливать в код. В
схеме это приходится делать путем экранирования симвлов или заменой их на
другие.
Следовательно, если мы хотим корректно исполнить скомпилированный си код,
мы должны иметь коректное представление синтаксиса.
Поэтому мы будем обходить скомпилированный код, заменять символы на
нужный синтаксис и записывать все в си-файл.

Этапы преобразования:
- есть общий список скомпилированного кода
- обойти все его подсписки, превратить все символы в строку, кроме тех,
  которые стоит заменить
- сформировать общую строку
- записать строку в файл

Данная часть трасформирует скомпилированный код в строки
#+NAME: trasform_code
#+BEGIN_SRC scheme :noweb yes
  (define (transform-exp exp)
    (define (transform-exp-rec exp list-of-strings)
      (if (null? exp)
          list-of-strings
          (let ((first-elt (car exp )))
            (cond ((number? first-elt) (transform-exp-rec (cdr exp)
                                                          (append list-of-strings
                                                                  (list
                                                                   (string-append
                                                                    " "
                                                                    (number->string
                                                                     first-elt))))))
                  ((string? first-elt) (transform-exp-rec (cdr exp)
                                                          (append list-of-strings
                                                                  (list
                                                                   " "
                                                                   (string-append
                                                                    first-elt)))))
                  (else
                   (cond ((eq? OPENING_BRACE first-elt)
                          (transform-exp-rec (cdr exp)
                                             (append list-of-strings (list " {"))))
                         ((eq? CLOSING_BRACE first-elt)
                          (transform-exp-rec (cdr exp)
                                             (append list-of-strings (list " }"))))
                         ((eq? OPENING_PARENTHESIS first-elt)
                          ;; (if (eq? (cadr exp) CLOSING_PARENTHESIS)
                              (transform-exp-rec (cdr exp)
                                                 (append list-of-strings (list "(")))
                              )
                              ;; (transform-exp-rec (cdr exp)
                              ;;                    (append list-of-strings (list "( ")))))
                         ((eq? CLOSING_PARENTHESIS first-elt)
                          ;; (if (eq? (cadr exp) SEMICOLON)
                          ;;     (transform-exp-rec (cdr exp)
                          ;;                        (append list-of-strings (list ")")))
                          (transform-exp-rec (cdr exp)
                                             (append list-of-strings (list " )"))))
                         ;; )
                         ((eq? OPENING_BRACKET first-elt)
                          (transform-exp-rec (cdr exp)
                                             (append list-of-strings (list "[ "))))
                         ((eq? CLOSING_BRACKET first-elt)
                          (transform-exp-rec (cdr exp)
                                             (append list-of-strings (list " ] "))))
                         ((eq? СOLON first-elt)
                          (transform-exp-rec (cdr exp)
                                             (append list-of-strings (list ":"))))
                         ((eq? SEMICOLON first-elt)
                          (transform-exp-rec (cdr exp)
                                             (append list-of-strings (list ";"))))
                         ((eq? СOMMA first-elt)
                          (transform-exp-rec (cdr exp)
                                             (append list-of-strings (list ", "))))
                         ((eq? ASTERISK first-elt)
                          (transform-exp-rec (cdr exp)
                                             (append list-of-strings (list "*"))))
                         ((eq? ELLIPSIS first-elt)
                          (transform-exp-rec (cdr exp)
                                             (append list-of-strings (list " ..."))))
                         (else
                          (transform-exp-rec (cdr exp)
                                             (append list-of-strings
                                                     (list
                                                      (string-append
                                                       " "
                                                       (symbol->string
                                                        first-elt))))))))))))
    (transform-exp-rec exp (list)))

  (define (compiled-code->string code)
    (define (rec-compiled-code->string code list-of-strings)
      ;; (format #t "code ~A ~%" code)
      (if ( null? code )
          (begin
            ;; (format #t "null~%")
            list-of-strings)
          (begin
            (append list-of-strings (transform-exp (car code))
                    (rec-compiled-code->string (cdr code) list-of-strings)))))
    (rec-compiled-code->string code '()))

  (define test-exp
    (compile-main
     (append (list 'proc1) (compile-parenthesis '()) (list SEMICOLON)
             (list 'proc2) (compile-parenthesis '()) (list SEMICOLON)
             (list 'proc3) (compile-parenthesis '()) (list SEMICOLON))))

  (define test-exp2
    (append (list 'val) (list ASTERISK) (list 'init_syntax_errors)
            (compile-parenthesis '())
            (compile-braces (append (list 'char) (list ASTERISK) (list 'string)
                                    (list ASTERISK) (list '=)
                                    (list 'malloc)
                                    (compile-parenthesis
                                     (append (list 'sizeof)
                                             (compile-parenthesis
                                              (append
                                               (list 'char)
                                               (compile-brackets
                                                (list
                                                 'max_symbol_name_length))))))))))
  ;; (transform-exp test-exp)

  ;; (transform-exp test-exp2)

  ;; (compiled-code->string (list test-exp
                               ;; test-exp2))
#+END_SRC

Данный алгоритм впечатывает преобразованный в строку код в файл, попутно
снабжая код пробелами и переводами строки

Во-первых, мы знаем, что правилам синтаксиса си с новой строки нужно
писать после:
- точки с запятой
- фигурных скобок.
#+NAME: print_code
#+BEGIN_SRC scheme :noweb yes
  (load-option 'format)
  (define *c-file* "test-file.txt")

  (define (print-code code-string)
    (define (rec-print-code code-string output-port)
      (if (null? code-string)
          'ok
          (let ((first-string (car code-string)))
            (if (or (equal? first-string "{" )
                    (equal? first-string " {" )
                    (equal? first-string " { " )
                    (equal? first-string " }" )
                    (equal? first-string " } " )
                    (equal? first-string " } " )
                    (equal? first-string ";" )
                    (equal? first-string "; " )
                    (equal? first-string ":" )
                    (equal? first-string ": " ))
                (begin
                  (format output-port "~A ~% "first-string)
                  (rec-print-code (cdr code-string) output-port))
                (begin
                  ;; (format #t "string ~A ~%" first-string)
                  (format output-port "~A" first-string)
                  (rec-print-code (cdr code-string) output-port))))))
    (let ((output-port (open-output-file  *c-file*)))
      (rec-print-code code-string output-port)
      (close-output-port output-port)
      'ok))


  (define test-exp
    (compile-main
     (append (list 'proc1) (compile-parenthesis '()) (list SEMICOLON)
             (list 'proc2) (compile-parenthesis '()) (list SEMICOLON)
             (list 'proc3) (compile-parenthesis '()) (list SEMICOLON))))

  (define test-exp2
    (append (list 'val) (list ASTERISK) (list 'init_syntax_errors)
            (compile-parenthesis '())
            (compile-braces (append (list 'char) (list ASTERISK) (list 'string)
                                    (list '=)
                                    (list 'malloc)
                                    (compile-parenthesis
                                     (append (list 'sizeof)
                                             (compile-parenthesis
                                              (append
                                               (list 'char)
                                               (compile-brackets
                                                (list
                                                 'max_symbol_name_length))))))
                                    (list SEMICOLON)))))

  (define tokens (compiled-code->string (list test-exp
                                              test-exp2)))

  (print-code tokens)
#+END_SRC

~Компиляция примитивов~

Предположим, компилятору на вход поступило выражение:
#+NAME: compile_primitives
#+BEGIN_SRC scheme :noweb yes
  (list 1 2 3 4 5)
#+END_SRC

Оно должно превратиться в это:
#+NAME: compile_primitives
#+BEGIN_SRC c :noweb yes
  val* some_fn() {
      int* ptr_a = malloc(sizeof(int));
      ,*ptr_a = 1;
      val* a_val = int_val_constructor( ptr_a );


      int* ptr_b = malloc(sizeof(int));
      ,*ptr_b = 2;
      val* b_val = int_val_constructor( ptr_b );


      int* ptr_c = malloc(sizeof(int));
      ,*ptr_c = 3;
      val* c_val = int_val_constructor( ptr_c );


      int* ptr_d = malloc(sizeof(int));
      ,*ptr_d = 4;
      val* d_val = int_val_constructor( ptr_d );


      int* ptr_f = malloc(sizeof(int));
      ,*ptr_f = 5;
      val* f_val = int_val_constructor( ptr_f );

      return make_list(a, b, c, d, f);
  }
#+END_SRC

Для нужно:

- получить оператор выражения
- определяем, что это примитив
- вызываем ~compile-primitive~.

~compile-primitive~
Для компиляции примитивов нам необходимо следующее:
- обязательно подключить заголовочный файл primitives.h - он подключит
  написанные на си примитивы, которые мы создали для интерпретатора
- для каждого вызыова примитива будет сгенерирована служебная функция,
  внутри которой он будет исполняться

~compile-numbers~
Самое простое - это скомпилировать код для представления чисел.
Получив на вход число 3, к примеру, компилятор должен вернуть следующее:
#+NAME: compile-numbers-example
#+BEGIN_SRC c :noweb yes
  int* ptr_a = malloc(sizeof(int));
  ,*ptr_a = 3;
  val* a_val = int_val_constructor( ptr_a );
#+END_SRC

К тому же, нам нужно сгенерировать имя для переменной, потому что иначе
мы не сможем использовать это число.

#+NAME: compile-numbers
#+BEGIN_SRC scheme :noweb yes
  ;; (generate-name-string exp)

  (define (compile-malloc-int var-name)
    (let* ((malloc-int (append '(malloc)
                               (compile-parenthesis (append '(sizeof)
                                                            (compile-parenthesis 'int)))))
           (int-pointer (append '(int) (list ASTERISK)
                                (list (string-append "ptr_" var-name) '=))))
      (append int-pointer malloc-int (list SEMICOLON))))

  ;; (compile-malloc-int "dzen")
  ;; (print-code (transform-exp (compile-malloc-int "dzen")))

  (define (compile-malloc-char var-name)
    (let* ((malloc-char (append '(malloc)
                               (compile-parenthesis (append '(sizeof)
                                                            (compile-parenthesis
                                                             (append '(char)
                                                                     (compile-brackets
                                                                      100)))))))
           (char-pointer (append '(char) (list ASTERISK)
                                (list var-name '=))))
      (append char-pointer malloc-char (list SEMICOLON))))

  ;; (compile-malloc-char "dzen")
  ;; (print-code (transform-exp (compile-malloc-char "dzen")))

  (define (compile-set-value-to-pointer p-name value)
    (append (list ASTERISK) (list (string-append "ptr_"  p-name) '= value)
            (list SEMICOLON)))

  (define (compile-int-val-constructor var-name var-value)
    ;; (display "compile-int-val-constructor")
    ;; (newline)
    (let ((allocated-memory (compile-malloc-int var-name))
          (new-var-name (string-append "val_" var-name))
          (set-value-to-pointer (compile-set-value-to-pointer var-name var-value)))
      (append allocated-memory
              set-value-to-pointer
              '(val) (list ASTERISK) (list new-var-name '= 'int_val_constructor)
              (compile-parenthesis (string-append "ptr_" var-name))
              (list SEMICOLON))))

  ;; (compile-int-val-constructor "some_name" 2)
  ;; (print-code (transform-exp (compile-int-val-constructor "some_name" 2)))

  (define (compile-numbers numbers-list)
    (define (rec-compile-numbers numbers-list compiled-code)
      (if (null? numbers-list)
          compiled-code
          (let* ((var-name (generate-name-string numbers-list))
                 (cur-number (car numbers-list)))
            (rec-compile-numbers (cdr numbers-list)
                                 (append
                                  compiled-code
                                  (compile-int-val-constructor var-name cur-number))))))

    (rec-compile-numbers numbers-list '()))

  ;; (print-code (transform-exp (compile-numbers '(1 2 3 4 5))))
#+END_SRC

#+NAME: code
#+BEGIN_SRC forth :tangle code.scheme  :noweb tangle :exports code :padline no :comments none
  <<main>>
  <<list_string>>
  <<service_procedure>>
  <<syntax_procs>>
  <<primitives>>
  <<environment>>
  <<trasform_code>>
  <<print_code>>
#+END_SRC
