#+STARTUP: showall indent hidestars

Основные принципы системы:

1. Каждая строка кода, написанного на схеме во время компиляции
   оборачивается в служебную функцию. Служебная функция - это функция,
   чье имя генерируется как хэш от выражения на схеме, которое является
   исходником для данного скомпилированного кода. Всегда вызывается без
   аргументов.

2. После компиляции любого выражения, компилятор возвращает 2 значения:
   скомпилированный код и способ, как его можно вызвать, как к нему можно
   обратиться. Если мы скомпилировали функцию, то способ к ней
   обратиться - это вызывать ее. Если мы скомпилировали число или
   строку - а для их компиляции нам нужно выделить память, записать в нее
   значение и вызвать соответствующий конструктор (их мы создали при
   написании интерпретатора) - то способ к ним обратиться - это имена
   переменных, в которых они лежат, и т. д.

3. При компиляции мы рекурсивно обходим выражение. Выражение можно
   представить как дерево, где каждый узел - это выражение. Дерево может
   состоять из одного узла. После обработки каждого выражения мы должны
   получить скомпилированный код  и способ, с помощью которого мы можем к
   нему обратиться. Если мы компилируем несколько выражения -
   последовательность, например - то весь скомпилированный код будет
   соединен в единой выражение, а способ к нему обратиться - это вызов
   самой внешней служебнй функции, которая оборачивает весь прочий код.


На основе этих трех идей пробуем отрефакторить уже написанный код,
сделать его работу более прозрачной и простой.

~Синтаксис~

Си имеет сложный синтаксис, поэтому создадим переменные, которые будут
содержать в себе необходимый синтаксис.
Затем мы будем его обрабатывать, заменяя на строковые
символы. Т.е. вместо ~#\}~ в готовом скомпилированном коде появится ~}~.

#+NAME: syntax_symbols
#+BEGIN_SRC scheme :noweb yes
  ;; преставление { и } в компилируемом коде
  (define OPENING_BRACE #\{)
  (define CLOSING_BRACE #\})

  ;; преставление ( и ) в компилируемом коде

  (define OPENING_PARENTHESIS #\()
  (define CLOSING_PARENTHESIS #\))

  ;; преставление [ и ] в компилируемом коде

  (define OPENING_BRACKET #\[)
  (define CLOSING_BRACKET #\])

  ;; преставление : и , в компилируемом коде
  (define СOLON #\:)
  (define COMMA #\,)

  ;; преставление * в компилируемом коде
  (define ASTERISK #\*)

  ;; преставление ; в компилируемом коде
  (define SEMICOLON #\;)

  ;; представление ... в компилируемом коде
  (define ELLIPSIS 'ELLIPSIS)
  #+END_SRC

Конструкторы, компилирующие разнообразные скобки вокруг уже
скомпилированного кода.
#+NAME: syntax_constructors
#+BEGIN_SRC scheme :noweb yes
  ;; компилирует { }
  (define(compile-braces code)
    (if (or (pair? code) (null? code))
        (append (list OPENING_BRACE)
                code
                (list CLOSING_BRACE))
        (append (list OPENING_BRACE)
                (list code)
                (list CLOSING_BRACE))))

  ;; компилирует ()
  (define(compile-parenthesis code)
    (if (or (pair? code) (null? code))
        (append (list OPENING_PARENTHESIS)
                code
                (list CLOSING_PARENTHESIS))
        (append (list OPENING_PARENTHESIS)
                (list code)
                (list CLOSING_PARENTHESIS))))

  ;; компилирует []
  (define(compile-brackets code)
    (if (or (pair? code) (null? code))
        (append (list OPENING_BRACKET)
                code
                (list CLOSING_BRACKET))
        (append (list OPENING_BRACKET)
                (list code)
                (list CLOSING_BRACKET))))

  ;; компилирует :
  (define(compile-colon code)
    (append code
            (list COLON)))

  ;; компилирует ;
  (define(compile-semicolon code)
    (append code
            (list SEMICOLON)))

  ;; компилирует ...
  (define(compile-ellipsis code)
    (append code
            (list ELLIPSIS)))

#+END_SRC

~main~

Сишному коду, в отличие от схемовского, необходима точка входа -
main. Так что создадим конструктор для компиляции main.
#+NAME: main
#+BEGIN_SRC scheme :noweb yes
  (define (compile-main fn-calls)
    (let ((code-into-braces (compile-braces fn-calls)))
      (append (list 'int 'main)
              (compile-parenthesis())
              code-into-braces)))
#+END_SRC

~Генерация имен~

Для генерации имен переменных и функций необходимо:
- перевести целиком полученное выражение на схеме в строку (без пробелов)
  целиком
- вычислить от нее хэш
- добавить к хэшу буквенный символ - хэш представляет собой числовое
  значение, которое не может быть поспринято как имя в си. Поэтому хэшу
  необходимо добавить хотя бы одну букву

Так же у нас есть следующая проблема.
Часто приходится генерировать имя для переменной и имя для указателя на
выделенную память. Например, когда нужно скомпилировать число. Если
вычислять хэш от выражения в обоих случаях, то хэш будет одинаковым,
следовательно, имена будут одинаковыми. А в си так нельзя.
Поэтому мы создадим два конструктора: один будет присоединять к хэшу
приставку ~ptr_~ - так мы будет обозначать указатель - а другой будет
присоединять ~val_~ - так мы бдем обозначать именя переменных.

Превращаем выражение в строку без пробелов.

#+NAME: list_string
#+BEGIN_SRC scheme :noweb yes
  ;; превращает выражение в строку
  (define (list->string lst)
    (define (rec-list->string lst retval-string)
      (if (null? lst)
          (string-append retval-string ")")
          (if (pair? (car lst))
              (begin
                (let (( result (string-append (rec-list->string (car lst) "(")
                                              (rec-list->string (cdr lst) ""))))
                  (string-append retval-string result)))
              (cond ((symbol? (car lst)) (rec-list->string (cdr lst)
                                                           (string-append retval-string
                                                                          (symbol->string
                                                                           (car lst)))))
                    ((number? (car lst)) (rec-list->string (cdr lst)
                                                           (string-append retval-string
                                                                          (number->string
                                                                           (car lst)))))
                    (else (rec-list->string (cdr lst)
                                            (string-append retval-string
                                                           "string" (car lst))))))))

    (rec-list->string lst "("))
#+END_SRC

Пишем тесты
#+NAME: list_string_tests
#+BEGIN_SRC scheme :noweb yes
  (list->string '(1 2 3))

  (list->string '(lambda (x) (+ x 1)))

  (list->string '(define (factorial n)
                   (if (= n 0)
                       1
                       (* n (factorial (= n 1))))))

  (list->string '(let ((a 3)
                       (b 4))
                   (+ 1 a b)))

  (list->string '(1 2 "2"))

  (list->string '(1 2 "(+ 1 2 )"))

#+END_SRC

Превращаем полученную строку в хэш и генерируем имя
#+NAME: generate_name
#+BEGIN_SRC scheme :noweb yes
  (define (exp->string exp)
    (list->string exp))

  (define (hash-exp exp)
    (let ((string (exp->string exp)))
      (string-hash string)))

  (define (generate-name-string exp)
    ;; (format #t "generate-name-string: ~A ~%" exp)
    (let* ((hash (hash-exp exp))
           (hash-string (number->string hash)))
      (string-append "a" hash-string)))
#+END_SRC

#+NAME: generate_name_tests
#+BEGIN_SRC scheme :noweb yes
  (hash-exp '(1 2 "(+ 1 2 )"))

  (hash-exp '(let ((a 3)
                   (b 4))
               (+ 1 a b)))

  (hash-exp '(let ((a 3)
                   (b 4))
               (+ 1 a b)))

  (hash-exp '(define (factorial n)
               (if (= n 0)
                   1
                   (* n (factorial (= n 1))))))

  (generate-name-string
   '(define (factorial n)
      (if (= n 0)
          1
          (* n (factorial (= n 1))))))

  (generate-name-string
   '(1 2 2))

  (generate-name-string
   '(1 2 "2"))
#+END_SRC

Теперь создаем конструкторы для присоежинения приствок ~ptr_~ и ~val_~
#+NAME: generate_ptr_and_val_names
#+BEGIN_SRC scheme :noweb yes
  (define (append-ptr str)
    (string-append "ptr_" str))

  (define (append-val str)
    (string-append "val_" str))
#+END_SRC

#+NAME: generate_ptr_and_val_names_tests
#+BEGIN_SRC scheme :noweb yes
  (append-ptr "a324789404")
  (append-val "a33189410")

  (append-ptr (generate-name-string
   '(1 2 2)))

  (append-val (generate-name-string
               '(1 2 2)))
#+END_SRC

~печать скомпилированного кода в файл~

Чтоб не ломать каждый раз голову, как должен выглядеть скомпилированный
код - с замененными символами и проч. - сразу напишем функционал, который
будет обрабатывать скомпилированный код и печатать его в файл.

Трансформируем полученное выражение в список строк,  попутно заменяя символы
вроде ~#/}~ на ~}~ и т.д.
#+NAME: transform_exp
#+BEGIN_SRC scheme :noweb yes
  (define (transform-exp exp)
    (if (null? exp)
        '(" ")
        (let ((first-elt (car exp )))
          ;; если число, превратить число в строку и присоединить к списку строк
          (cond ((number? first-elt) (cons (string-append " " (number->string
                                                               first-elt))
                                           (transform-exp (cdr exp))))
                ;; если строка, присоединить как есть
                ((string? first-elt) (cons (string-append " " first-elt)
                                           (transform-exp (cdr exp))))
                ;; если список, то обойти его, преобразовать и присоединить все элементы
                ((pair? first-elt) (cons (transform-exp first-elt)
                                         (transform-exp (cdr exp))))
                ;; если символ
                (else
                 ;; то проверить на совпадение с синтаксическими символами, при необходимости
                 ;; заменить на строковое представление
                 (cond ((eq? OPENING_BRACE first-elt)
                        (cons " {" (transform-exp (cdr exp))))
                       ((eq? CLOSING_BRACE first-elt)
                        (cons " }" (transform-exp (cdr exp))))
                       ((eq? OPENING_PARENTHESIS first-elt)
                        (cons " (" (transform-exp (cdr exp))))
                       ((eq? CLOSING_PARENTHESIS first-elt)
                        (cons " )" (transform-exp (cdr exp))))
                       ((eq? OPENING_BRACKET first-elt)
                        (cons " [" (transform-exp (cdr exp))))
                       ((eq? CLOSING_BRACKET first-elt)
                        (cons " ]" (transform-exp (cdr exp))))
                       ((eq? СOLON first-elt)
                        (cons ":" (transform-exp (cdr exp))))
                       ((eq? SEMICOLON first-elt)
                        (cons ";" (transform-exp (cdr exp))))
                       ((eq? COMMA first-elt)
                        (cons ", " (transform-exp (cdr exp))))
                       ((eq? ASTERISK first-elt)
                        (cons "*" (transform-exp (cdr exp))))
                       ((eq? ELLIPSIS first-elt)
                        (cons " ..." (transform-exp (cdr exp))))
                       ;; это какой-то другой символ
                       ;; преобразовать в строку, присоединить к списку строк
                       (else (cons (string-append " " (symbol->string first-elt))
                                   (transform-exp (cdr exp))))))))))

#+END_SRC

#+NAME: transform_exp_tests
#+BEGIN_SRC scheme :noweb yes
  (define test-exp
    (compile-main
     (append (list 'proc1) (compile-parenthesis '()) (list SEMICOLON)
             (list 'proc2) (compile-parenthesis '()) (list SEMICOLON)
             (list 'proc3) (compile-parenthesis '()) (list SEMICOLON))))

  (transform-exp test-exp)

  (define test-exp2
    (append (list 'val) (list ASTERISK) (list 'init_syntax_errors)
            (compile-parenthesis '())
            (compile-braces (append (list 'char) (list ASTERISK) (list 'string)
                                    (list ASTERISK) (list '=)
                                    (list 'malloc)
                                    (compile-parenthesis
                                     (append (list 'sizeof)
                                             (compile-parenthesis
                                              (append
                                               (list 'char)
                                               (compile-brackets
                                                (list
                                                 'max_symbol_name_length))))))))))

  (transform-exp test-exp2)
#+END_SRC
Теперь напишем функцию, которая будет принимать несколько списков -
скомпилированных выражений - и вызывать transform-exp для каждого из них
и возвращать общий список из результатов, которые вернул transform-exp

#+NAME: compiled_code_to_string
#+BEGIN_SRC scheme :noweb yes
  (define (compiled-code->string code)
    (if (null? code)
        '()
        (let ((first-exp (car code)))
          (if (pair? first-exp)
              (append (transform-exp first-exp) (compiled-code->string (cdr code)))
              (transform-exp code)))))

#+END_SRC

#+NAME: compiled_code_to_string_tests
#+BEGIN_SRC scheme :noweb yes
  (define test-exp
    (compile-main
     (append (list 'proc1) (compile-parenthesis '()) (list SEMICOLON)
             (list 'proc2) (compile-parenthesis '()) (list SEMICOLON)
             (list 'proc3) (compile-parenthesis '()) (list SEMICOLON))))

  (transform-exp test-exp)

  (define test-exp2
    (append (list 'val) (list ASTERISK) (list 'init_syntax_errors)
            (compile-parenthesis '())
            (compile-braces (append (list 'char) (list ASTERISK) (list 'string)
                                    (list ASTERISK) (list '=)
                                    (list 'malloc)
                                    (compile-parenthesis
                                     (append (list 'sizeof)
                                             (compile-parenthesis
                                              (append
                                               (list 'char)
                                               (compile-brackets
                                                (list
                                                 'max_symbol_name_length))))))))))
  (compiled-code->string (list test-exp
                               test-exp2))

  (compiled-code->string test-exp)

  (compiled-code->string test-exp2)
#+END_SRC

Теперь пишем функцию, которая запишет полученный список строк в заданный
файл, снабжая печать переводом строкив случае если:
- это открывающая или закрывающая фигурная скобка
- двоеточие
- точка с запятой

#+NAME: print_code_into_file
#+BEGIN_SRC scheme :noweb yes
  (load-option 'format)
  (define *c-file* "test-file.txt")

  (define (print-code-into-file code-string)
    (define (rec-print-code code-string output-port)
      (if (null? code-string)
          'ok
          (let ((first-string (car code-string)))
            (if (or (equal? first-string " {" )
                    (equal? first-string " }" )
                    (equal? first-string ";" )
                    (equal? first-string ":" ))
                (begin
                  (format output-port "~A ~% "first-string)
                  (rec-print-code (cdr code-string) output-port))
                (begin
                  (format output-port "~A" first-string)
                  (rec-print-code (cdr code-string) output-port))))))
    (let ((output-port (open-output-file  *c-file*)))
      (rec-print-code code-string output-port)
      (close-output-port output-port)
      'ok))
#+END_SRC

#+NAME: print_code_into_file_tests
#+BEGIN_SRC scheme :noweb yes
  (define test-exp
    (compile-main
     (append (list 'proc1) (compile-parenthesis '()) (list SEMICOLON)
             (list 'proc2) (compile-parenthesis '()) (list SEMICOLON)
             (list 'proc3) (compile-parenthesis '()) (list SEMICOLON))))

  (define test-exp2
    (append (list 'val) (list ASTERISK) (list 'init_syntax_errors)
            (compile-parenthesis '())
            (compile-braces (append (list 'char) (list ASTERISK) (list 'string)
                                    (list '=)
                                    (list 'malloc)
                                    (compile-parenthesis
                                     (append (list 'sizeof)
                                             (compile-parenthesis
                                              (append
                                               (list 'char)
                                               (compile-brackets
                                                (list
                                                 'max_symbol_name_length))))))
                                    (list SEMICOLON)))))

  (define tokens (compiled-code->string (list test-exp
                                              test-exp2)))
  (print-code-into-file tokens)
#+END_SRC

Теперь напишем соберем все в единую функцию, которая будет вызывать
преобразование всех скомпилированных выражений и их печать

#+NAME: print_code
#+BEGIN_SRC scheme :noweb yes
  (define (print-code exps)
    (print-code-into-file (compiled-code->string exps)))
#+END_SRC

~Построение окружений~

Здесь обошлось без рефакторинга.

Окружения нужны только для того, чтоб компилятор мог отслеживать, в каком месте
появляется переменная и определена ли она была вообще. Получается, что
данные "окружения" будут состоять только из имен переменных без их
значений, поскольку на этапе компиляции значения не играют никакой роли.
Максимум можно указывать какого именно типа переменная - функция, число и
т.д., поскольку мы компилим код для си. Но это необязательно.

Окружения будут иметь списковую структуру как в сикпе, только если в
сикпе кадр состояит из двух списков, где первый список - это имена
переменных, а второй - это их значения, то мои псевдоокружения будут
состоять из кадров, которые будут содержать только имена переменных. Чем
ближе кадр к концу списка кадров, тем ближе он к глобальной области видимости.

То есть в окружении ((d f g h) (n test-fn factorial) (primitives-proc-names))
последий кадр является глобальным окружением.
При запуске компилятора будет устанавливаться начальное окружение,
состоящего только из кадра с примитивами.

При компиляции функции окружение будет расширяться кадром, который будет
наследовать все переменные глобального окружения + формальные параметры
функции, а затем будет дополняться новыми переменными, если в этом
возникнет необходимость. По завершению компиляции этот кадр будет
удаляться, поскольку никакие другие процедуры кроме текущей не должны
иметь доступ к переменным, объявленным внутри этой функции.

Связываем имена лисповых примитивов и сишных, чтоб знать, какие именно
имена компилировать, если использованы данные примитивы, поскольку имена
сишных примитивов и примитивов схемы не всегда совпадают из-за
синтаксических правил си банального неудобства.

#+NAME: primitives_proc
#+BEGIN_SRC scheme :noweb yes
  (define (primitive-proc-bindings)
    (list (list 'car 'car)
          (list 'cdr 'cdr)
          (list 'cons 'cons)
          (list 'list 'make-list)
          (list  '+ 'add)
          (list  '- 'sub)
          (list  '* 'mul)
          (list  '/ 'division)
          (list  '= 'equal_numbers_predicate)
          (list  '> 'bigger_predicate)
          (list  '< 'smaller_predicate)
          (list  'reverse 'reverse)
          (list  'append 'append)
          (list  'assoc 'assoc)
          (list  'length 'length_compile)
          (list  'last-pair 'last_pair)
          (list  'true? 'true_predicate_compile)
          (list  'false? 'false_predicate_compile)
          (list  'null? 'null_predicate_compile)
          (list  'pair? 'pair_predicate_compile)
          (list  'symbol? 'symbol_predicate_compile)
          (list  'atom? 'atom_predicate_compile)
          (list  'string? 'string_predicate_compile)
          (list  'dotpair? 'dotpair_predicate_compile)))

  (define (primitive-procedure-objects)
    (map (lambda (proc)
           (list (car proc)
                 (list 'primitive (cadr proc))))
         (primitive-proc-bindings)))
#+END_SRC

Конструируем аналоги сикповых процедур для окружений, только с тем
расчетом, что у нас кадр состоит только из имен переменных.
#+NAME: environment
#+BEGIN_SRC scheme :noweb yes
  (define (atom? arg)
    (or (string? arg) (number? arg)
        (symbol? arg)))

  (define (enclosing-environment env) (cdr env))

  (define (first-frame env) (car env))

  (define the-empty-environment '())

  (define (add-binding-to-frame! var frame)
    (let* ((first-elt (car frame))
           (rest (cdr frame)))
      (set-car! frame var)
      (set-cdr! frame (list first-elt))
      (let ((last-elt (last-pair frame)))
        (set-cdr! last-elt rest)
        frame)))

  (define (extend-environment vars base-env)
    (cons vars base-env))

  (define (lookup-variable var env)
    (define (env-loop env)
      (define (scan vars)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((and (pair? var) (pair? (car vars)))
               (if (eq? (car var) (caar vars))
                   (car vars)
                   (scan (cdr vars))))
              ((and (not (pair? var)) (pair? (car vars)))
               (if (eq? var (caar vars))
                   (car vars)
                   (scan (cdr vars))))
              ((eq? var (car vars)) 'ok)
              (else (scan (cdr vars)))))
      (if (eq? env the-empty-environment)
          (error "Compile: Несвязанная переменная" var)
          (let ((frame (first-frame env)))
            (scan frame))))
    (env-loop env))

  (define (define-variable! var env)
    (let ((frame (first-frame env)))
      (define (scan vars)
        (cond ((null? vars)
               (begin
                 (format #t "define-variable!: переменная новая ~%" )
                 (add-binding-to-frame! var frame)
                 'ok))
              ((and (pair? var) (pair? (car vars)))
               (if (eq? (car var) (caar vars))
                   (car vars)
                   (scan (cdr vars))))
              ((and (atom? var) (pair? (car vars)))
               (if (eq? var (caar vars))
                   (car vars)
                   (scan (cdr vars))))
              ((eq? var (car vars)) (car vars))
              (else (scan (cdr vars)))))
      (scan frame)))

  (define (delete-frame env)
    (set! env (cdr env)))

  (define (setup-environment)
    (let ((initial-env
           (extend-environment (primitive-procedure-objects)
                               the-empty-environment)))
      initial-env))

  (define global-environment (setup-environment))
#+END_SRC

#+NAME: environment_tests
#+BEGIN_SRC scheme :noweb yes
  (define test-env (setup-environment))

  (set! test-env (extend-environment '( f s n l) test-env))

  (add-binding-to-frame! 'd (first-frame test-env))

  (add-binding-to-frame! '(test_fn compound) (first-frame test-env))

  (lookup-variable '(test_fn compound) test-env)

  (lookup-variable 's test-env)

  (lookup-variable '(s n) test-env)

  (lookup-variable '(car car) test-env)
#+END_SRC

~Компиляция примитивов~

Для компиляции вызовов примитивов и любых функций вообще, необходимо
сначала скомпилировать аргументы вызова, а затем передеть их имена или
вызовы их функций в вызов примитива и так скомиплировать.

Для начала научимся компилировать:
- числа
- строки
- символы
- вызовы других примитивов

Если в схеме можно споокйно передать в вызов число, то в си сначала
придется выделять под него память, потом заносить значение по указателю,
потом вызывать конструктор. В общем, заморочно.

Создадим конструкторы, которые будут компилировать символы, строки и
числа. Каждый из них будет принимать имя будущей переменной, которая
будет содержать в себе необходимое значение. Этик онструкторы нам
пригодятся, когда мы будем компилировать определения переменных.

Нужно создать конструкторы, комиплирующие:
- строки
- символы
- числа

Сначала создадим конструкторы, которые будут комиплировать код для
выделения памяти.
#+NAME: allocate_memory_constructors
#+BEGIN_SRC scheme :noweb yes
  ;; компилирует выделение памяти на 1 инт
  (define (compile-malloc-int var-name)
    (let* ((malloc-int (append '(malloc)
                               (compile-parenthesis (append '(sizeof)
                                                            (compile-parenthesis 'int)))))
           (int-pointer (list 'int  ASTERISK (append-ptr var-name) '=)))
      (append int-pointer malloc-int (list SEMICOLON))))

  ;; кмопилирует код для выделения массива на 100 чаров
  (define (compile-malloc-char var-name)
    (let* ((malloc-char (append '(malloc)
                                (compile-parenthesis (append '(sizeof)
                                                             (compile-parenthesis
                                                              (append '(char)
                                                                      (compile-brackets
                                                                       100)))))))
           (char-pointer (list 'char ASTERISK (append-ptr var-name) '=)))
      (append char-pointer malloc-char (list SEMICOLON))))

  ;; комиплирует код для комипрования строки в выделенную память
  (define (compile-strcpy var-name string)
    (append
     '(strncpy) (compile-parenthesis
                 (list (append-ptr var-name) COMMA string COMMA 100))
     (list SEMICOLON)))

  ;; присваивает неинициализированному указателю значение
  (define (compile-set-value-to-pointer p-name value)
    (list ASTERISK (append-ptr p-name) '= value SEMICOLON))
#+END_SRC

Теперь на их основе создаем конструкторы для строк, чисел и символов.
Они компилируют код для выделения памяти, присвоения ей значения и вызова
соответствующих конструкторов, определенных в файле ~test.c~.

Параметр ~var-name~ должен быть строкой.
#+NAME: nums_strings_symols_constructors
#+BEGIN_SRC scheme :noweb yes
  (define (compile-int-val-constructor var-name var-value)
    (if (string? var-name)
        (let ((allocated-memory (compile-malloc-int var-name))
              (set-value-to-pointer (compile-set-value-to-pointer var-name var-value)))
          (append allocated-memory
                  set-value-to-pointer
                  (list 'val ASTERISK var-name '= 'int_val_constructor)
                  (compile-parenthesis (append-ptr var-name))
                  (list SEMICOLON)))
        (error "var-name should be a string -- compile-int-val-constructor" var-name)))

  (define (compile-symbol-val-constructor var-name string)
    (if (string? var-name)
    (let* ((allocated-memory (compile-malloc-char var-name))
           (strcpy (compile-strcpy var-name string)))
      (append
       allocated-memory strcpy
       (list 'val ASTERISK var-name '= 'symbol_val_constructor)
       (compile-parenthesis (append-ptr var-name))
       (list SEMICOLON)))
    (error "var-name should be a string -- compile-symbol-val-constructor" var-name)))


  (define (compile-string-val-constructor var-name string)
    (if (string? var-name)
        (let* ((allocated-memory (compile-malloc-char var-name))
               (strcpy (compile-strcpy var-name string)))
          (append
           allocated-memory strcpy
           (list 'val ASTERISK var-name '= 'string_val_constructor)
           (compile-parenthesis (append-ptr var-name))
           (list SEMICOLON)))
        (error "var-name should be a string -- compile-string-val-constructor" var-name)))

#+END_SRC

#+NAME: nums_strngs_symols_constructors_tests
#+BEGIN_SRC scheme :noweb yes
  (print-code (compile-int-val-constructor "var1" 1))

  ;; должны получить ошибку
  (print-code (compile-int-val-constructor 'var1 1))

  (print-code (compile-string-val-constructor "var1" "\"string\""))

  ;; должны получить ошибку
  (print-code (compile-string-val-constructor 'var1 "\"string\""))

  (print-code (compile-symbol-val-constructor "var1" "\"symbol\""))

  ;; должны получить ошибку
  (print-code (compile-symbol-val-constructor 'var1 "\"symbol\""))
#+END_SRC

Теперь приступаем к самой компиляции примитивов.

#+NAME: compile_primitives_constructors
#+BEGIN_SRC scheme :noweb yes
  (define (compile-list args)
    (define (compile-list-rec args compiled-code)
      (if (null? args)
          compiled-code
          (compile-list-rec (cdr args) (append compiled-code
                                               (list COMMA)
                                               (list (car args))))))
    (let ((amount-of-args (length args)))
      (append '(make_list)
              (compile-parenthesis
               (append (compile-list-rec args (list amount-of-args)))))))


  ;; (print-code( transform-exp (compile-list '("\" 3 \"" 1 2 d))))

  (define (compile-cons args)
    (let ((first-arg (car args))
          (second-arg (cadr args)))
      (append '(cons)
              (compile-parenthesis
               (append (list first-arg)
                       (list COMMA)
                       (list second-arg))))))

  ;; (print-code( transform-exp (compile-cons '(1 2))))


  (define (compile-car args)
    (append '(car)
            (compile-parenthesis args)))

  ;; (print-code( transform-exp (compile-car '(some-list))))

  (define (compile-cdr args)
    (append '(cdr)
            (compile-parenthesis args)))

  ;; (print-code( transform-exp (compile-cdr '(some-list))))

  (define (compile-set-car args)
    (append '(set_car)
            (compile-parenthesis args)))

  ;; (print-code( transform-exp (compile-set-car '(some-list))))

  (define (compile-set-cdr args)
    (append '(set_cdr)
            (compile-parenthesis args)))

  ;; (print-code( transform-exp (compile-set-cdr '(some-list))))

  (define (compile-append args)
    (let ((first-arg (car args))
          (second-arg (cadr args)))
      (append '(append)
              (compile-parenthesis
               (append (list first-arg)
                       (list COMMA)
                       (list second-arg))))))

  ;; (print-code( transform-exp (compile-append '(some-list1 some-list2))))


  (define (compile-assoc args)
    (let ((first-arg (car args))
          (second-arg (cadr args)))
      (append '(assoc)
              (compile-parenthesis
               (append (list first-arg)
                       (list COMMA)
                       (list second-arg))))))

  ;; (print-code( transform-exp (compile-assoc '( some-key some-list))))

  (define (compile-length args)
    (append '(length_compile)
            (compile-parenthesis args)))

  ;; (print-code( transform-exp (compile-length '(some-list))))

  (define (compile-last-pair args)
    (append '(last-pair)
            (compile-parenthesis args)))

  (define (compile-smaller-predicate-compile args)
    (append '(smaller_predicate_compile)
            (compile-parenthesis args)))

  (define (compile-bigger-predicate-compile args)
    (append '(bigger_predicate_compile)
            (compile-parenthesis args)))

  (define (compile-equal-numbers args)
    (let ((first-arg (car args))
          (second-arg (cadr args)))
      (append '(equal_numbers_predicate_compile)
              (compile-parenthesis
               (append (list first-arg)
                       (list COMMA)
                       (list second-arg))))))

  (define (compile-add args)
    (append '(add)
            (compile-parenthesis args)))

  (define (compile-sub args)
    (append '(sub)
            (compile-parenthesis args)))

  (define (compile-mul args)
    (append '(mul)
            (compile-parenthesis args)))

  (define (compile-division args)
    (append '(division)
            (compile-parenthesis args)))

  (define (compile-reverse args)
    (append '(reverse)
            (compile-parenthesis args)))

  (define (compile-true? args)
    (append '(true_predicate_compile)
            (compile-parenthesis args)))

  (define (compile-false? args)
    (append '(false_predicate_compile)
            (compile-parenthesis args)))

  (define (compile-null? args)
    (append '(null_predicate_compile)
            (compile-parenthesis args)))

  (define (compile-pair? args)
    (append '(pair_predicate_compile)
            (compile-parenthesis args)))

  (define (compile-atom? args)
    (append '(atom_predicate_compile)
            (compile-parenthesis args)))
#+END_SRC

#+NAME: code
#+BEGIN_SRC forth :tangle code.scheme :noweb tangle :exports code :padline no :comments none
  <<syntax_symbols>>
  <<syntax_constructors>>
  <<main>>
  <<list_string>>
  <<generate_name>>
  <<generate_ptr_and_val_names>>
  <<transform_exp>>
  <<compiled_code_to_string>>
  <<print_code_into_file>>
  <<print_code>>
  <<primitives_proc>>
  <<environment>>
#+END_SRC
