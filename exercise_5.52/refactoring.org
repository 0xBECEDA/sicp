#+STARTUP: showall indent hidestars

Основные принципы системы:

1. Каждая строка кода, написанного на схеме во время компиляции
   оборачивается в служебную функцию. Служебная функция - это функция,
   чье имя генерируется как хэш от выражения на схеме, которое является
   исходником для данного скомпилированного кода. Всегда вызывается без
   аргументов.

2. После компиляции любого выражения, компилятор возвращает 2 значения:
   скомпилированный код и способ, как его можно вызвать, как к нему можно
   обратиться. Если мы скомпилировали функцию, то способ к ней
   обратиться - это вызывать ее. Если мы скомпилировали число или
   строку - а для их компиляции нам нужно выделить память, записать в нее
   значение и вызвать соответствующий конструктор (их мы создали при
   написании интерпретатора) - то способ к ним обратиться - это имена
   переменных, в которых они лежат, и т. д.

3. При компиляции мы рекурсивно обходим выражение. Выражение можно
   представить как дерево, где каждый узел - это выражение. Дерево может
   состоять из одного узла. После обработки каждого выражения мы должны
   получить скомпилированный код  и способ, с помощью которого мы можем к
   нему обратиться. Если мы компилируем несколько выражения -
   последовательность, например - то весь скомпилированный код будет
   соединен в единой выражение, а способ к нему обратиться - это вызов
   самой внешней служебнй функции, которая оборачивает весь прочий код.


На основе этих трех идей пробуем отрефакторить уже написанный код,
сделать его работу более прозрачной и простой.

~Синтаксис~

Си имеет сложный синтаксис, поэтому создадим переменные, которые будут
содержать в себе необходимый синтаксис.
Затем мы будем его обрабатывать, заменяя на строковые
символы. Т.е. вместо ~#\}~ в готовом скомпилированном коде появится ~}~.

#+NAME: syntax_symbols
#+BEGIN_SRC scheme :noweb yes
  ;; преставление { и } в компилируемом коде
  (define OPENING_BRACE #\{)
  (define CLOSING_BRACE #\})

  ;; преставление ( и ) в компилируемом коде

  (define OPENING_PARENTHESIS #\()
  (define CLOSING_PARENTHESIS #\))

  ;; преставление [ и ] в компилируемом коде

  (define OPENING_BRACKET #\[)
  (define CLOSING_BRACKET #\])

  ;; преставление : и , в компилируемом коде
  (define COLON #\:)
  (define COMMA #\,)

  ;; преставление * в компилируемом коде
  (define ASTERISK #\*)

  ;; преставление ; в компилируемом коде
  (define SEMICOLON #\;)

  ;; представление ... в компилируемом коде
  (define ELLIPSIS 'ELLIPSIS)
  #+END_SRC

Конструкторы, компилирующие разнообразные скобки вокруг уже
скомпилированного кода.
#+NAME: syntax_constructors
#+BEGIN_SRC scheme :noweb yes
  ;; компилирует { }
  (define(compile-braces code)
    (if (or (pair? code) (null? code))
        (append (list OPENING_BRACE)
                code
                (list CLOSING_BRACE))
        (append (list OPENING_BRACE)
                (list code)
                (list CLOSING_BRACE))))

  ;; компилирует ()
  (define(compile-parenthesis code)
    (if (or (pair? code) (null? code))
        (append (list OPENING_PARENTHESIS)
                code
                (list CLOSING_PARENTHESIS))
        (append (list OPENING_PARENTHESIS)
                (list code)
                (list CLOSING_PARENTHESIS))))

  ;; компилирует []
  (define(compile-brackets code)
    (if (or (pair? code) (null? code))
        (append (list OPENING_BRACKET)
                code
                (list CLOSING_BRACKET))
        (append (list OPENING_BRACKET)
                (list code)
                (list CLOSING_BRACKET))))

  ;; компилирует :
  (define(compile-colon code)
    (append code
            (list COLON)))

  ;; компилирует ;
  (define(compile-semicolon code)
    (append code
            (list SEMICOLON)))

  ;; компилирует ...
  (define(compile-ellipsis code)
    (append code
            (list ELLIPSIS)))

#+END_SRC

~main~

Сишному коду, в отличие от схемовского, необходима точка входа -
main. Так что создадим конструктор для компиляции main.
#+NAME: main
#+BEGIN_SRC scheme :noweb yes
  (define (compile-main fn-calls)
    (let ((code-into-braces (compile-braces fn-calls)))
      (append (list 'int 'main)
              (compile-parenthesis())
              code-into-braces)))
#+END_SRC

Процедуры для синтаксического анализа выражений
#+NAME: syntax_procs
#+BEGIN_SRC scheme :noweb yes
  (define (variable? exp) (symbol? exp))

  (define (quoted? exp)
    (tagged-list? exp 'quote))

  (define (text-of-quotation exp) (cadr exp))

  (define (tagged-list? exp tag)
    (if (pair? exp)
        (eq? (car exp) tag)
        false))

  (define (assignment? exp)
    (tagged-list? exp 'set!))

  (define (assignment-variable exp) (cadr exp))

  (define (assignment-value exp) (caddr exp))

  (define (definition? exp)
    (tagged-list? exp 'define))

  (define (definition-variable exp)
    (if (symbol? (cadr exp))
        (cadr exp)
        (caadr exp)))

  (define (definition-value exp)
    (if (symbol? (cadr exp))
        (caddr exp)
        (make-lambda (cdadr exp)
                     (cddr exp))))

  (define (lambda? exp) (tagged-list? exp 'lambda))

  (define (lambda-parameters exp) (cadr exp))

  (define (lambda-body exp) (cddr exp))

  (define (make-lambda parameters body)
    (cons 'lambda (cons parameters body)))

  (define (if? exp) (tagged-list? exp 'if))

  (define (if-predicate exp) (cadr exp))

  (define (if-consequent exp) (caddr exp))

  (define (if-alternative exp)
    (if (not (null? (cdddr exp)))
        (cadddr exp)
        'false))

  (define (make-if predicate consequent alternative)
    (list 'if predicate consequent alternative))

  (define (begin? exp) (tagged-list? exp 'begin))

  (define (begin-actions exp) (cdr exp))

  (define (last-exp? seq) (null? (cdr seq)))

  (define (first-exp seq) (car seq))

  (define (rest-exps seq) (cdr seq))

  (define (sequence->exp seq)
    (cond ((null? seq) seq)
          ((last-exp? seq) (first-exp seq))
          (else (make-begin seq))))

  (define (make-begin seq) (cons 'begin seq))

  (define (application? exp) (pair? exp))

  (define (operator exp) (car exp))

  (define (operands exp) (cdr exp))

  (define (no-operands? ops) (null? ops))

  (define (first-operand ops) (car ops))

  (define (rest-operands ops) (cdr ops))
#+END_SRC

~Генерация имен~

Для генерации имен переменных и функций необходимо:
- перевести целиком полученное выражение на схеме в строку (без пробелов)
  целиком
- вычислить от нее хэш
- добавить к хэшу буквенный символ - хэш представляет собой числовое
  значение, которое не может быть поспринято как имя в си. Поэтому хэшу
  необходимо добавить хотя бы одну букву

Так же у нас есть следующая проблема.
Часто приходится генерировать имя для переменной и имя для указателя на
выделенную память. Например, когда нужно скомпилировать число. Если
вычислять хэш от выражения в обоих случаях, то хэш будет одинаковым,
следовательно, имена будут одинаковыми. А в си так нельзя.
Поэтому мы создадим два конструктора: один будет присоединять к хэшу
приставку ~ptr_~ - так мы будет обозначать указатель - а другой будет
присоединять ~val_~ - так мы бдем обозначать именя переменных.

Превращаем выражение в строку без пробелов.

#+NAME: list_string
#+BEGIN_SRC scheme :noweb yes
  (define (atom? arg)
    (or (string? arg) (number? arg)
        (symbol? arg)))

  ;; превращает выражение в строку
  (define (list->string lst)
    (define (rec-list->string lst retval-string)
      (if (null? lst)
          (string-append retval-string ")")
          (if (pair? (car lst))
              (let ((result (string-append (rec-list->string (car lst) "(")
                                           (rec-list->string (cdr lst) ""))))
                (string-append retval-string result))
              (cond ((symbol? (car lst)) (rec-list->string (cdr lst)
                                                           (string-append retval-string
                                                                          (symbol->string
                                                                           (car lst)))))
                    ((number? (car lst)) (rec-list->string (cdr lst)
                                                           (string-append retval-string
                                                                          (number->string
                                                                           (car lst)))))
                    (else (rec-list->string (cdr lst)
                                            (string-append retval-string
                                                           "string" (car lst))))))))
    (if (atom? lst)
        (cond ((symbol? lst) (symbol->string lst))
              ((number? lst) (string-append (number->string lst)))
              (else (string-append "string" lst)))
    (rec-list->string lst "(")))
#+END_SRC

Пишем тесты
#+NAME: list_string_tests
#+BEGIN_SRC scheme :noweb yes
  (list->string '(1 2 3))

  (list->string '(lambda (x) (+ x 1)))

  (list->string '(define (factorial n)
                   (if (= n 0)
                       1
                       (* n (factorial (= n 1))))))

  (list->string '(let ((a 3)
                       (b 4))
                   (+ 1 a b)))

  (list->string '(1 2 "2"))

  (list->string '(1 2 "(+ 1 2 )"))

#+END_SRC

Превращаем полученную строку в хэш и генерируем имя
#+NAME: generate_name
#+BEGIN_SRC scheme :noweb yes
  (define (exp->string exp)
    (list->string exp))

  (define (hash-exp exp)
    (let ((string (exp->string exp)))
      (string-hash string)))

  (define (generate-name-string exp)
    ;; (format #t "generate-name-string: ~A ~%" exp)
    (let* ((hash (hash-exp exp))
           (hash-string (number->string hash)))
      (string-append "a" hash-string)))
#+END_SRC

#+NAME: generate_name_tests
#+BEGIN_SRC scheme :noweb yes
  (hash-exp '(1 2 "(+ 1 2 )"))

  (hash-exp '(let ((a 3)
                   (b 4))
               (+ 1 a b)))

  (hash-exp '(let ((a 3)
                   (b 4))
               (+ 1 a b)))

  (hash-exp '(define (factorial n)
               (if (= n 0)
                   1
                   (* n (factorial (= n 1))))))

  (generate-name-string
   '(define (factorial n)
      (if (= n 0)
          1
          (* n (factorial (= n 1))))))

  (generate-name-string
   '(1 2 2))

  (generate-name-string
   '(1 2 "2"))
#+END_SRC

Теперь создаем конструкторы для присоежинения приствок ~ptr_~ и ~val_~
#+NAME: generate_ptr_and_val_names
#+BEGIN_SRC scheme :noweb yes
  (define (append-ptr str)
    (string-append "ptr_" str))

  (define (append-val str)
    (string-append "val_" str))
#+END_SRC

#+NAME: generate_ptr_and_val_names_tests
#+BEGIN_SRC scheme :noweb yes
  (append-ptr "a324789404")
  (append-val "a33189410")

  (append-ptr (generate-name-string
   '(1 2 2)))

  (append-val (generate-name-string
               '(1 2 2)))
#+END_SRC

Данный код будет генерировать код для служебных функций. Таких
функций нет в изначальном коде, но они будут компилироваться, чтоб не
пришлось все выражения компилировать в мэйн.

Служебная функция вызывается без аргументов.
#+NAME: service_procedure
#+BEGIN_SRC scheme :noweb yes
  (define (compile-service-fn name body)
    (let ((code-into-braces (compile-braces body)))
      (append (list 'val ASTERISK name)
              (compile-parenthesis '())
              code-into-braces)))
#+END_SRC

~печать скомпилированного кода в файл~

Чтоб не ломать каждый раз голову, как должен выглядеть скомпилированный
код - с замененными символами и проч. - сразу напишем функционал, который
будет обрабатывать скомпилированный код и печатать его в файл.

Трансформируем полученное выражение в список строк,  попутно заменяя символы
вроде ~#/}~ на ~}~ и т.д.
#+NAME: transform_exp
#+BEGIN_SRC scheme :noweb yes
  (define (transform-exp exp)
    (if (null? exp)
        '(" ")
        (let ((first-elt (car exp )))
          ;; если число, превратить число в строку и присоединить к списку строк
          (cond ((number? first-elt) (cons (string-append " " (number->string
                                                               first-elt))
                                           (transform-exp (cdr exp))))
                ;; если строка, присоединить как есть
                ((string? first-elt) (cons (string-append " " first-elt)
                                           (transform-exp (cdr exp))))
                ;; если список, то обойти его, преобразовать и присоединить все элементы
                ((pair? first-elt) (append (transform-exp first-elt)
                                         (transform-exp (cdr exp))))
                ;; если символ
                (else
                 ;; то проверить на совпадение с синтаксическими символами, при необходимости
                 ;; заменить на строковое представление
                 (cond ((eq? OPENING_BRACE first-elt)
                        (cons " {" (transform-exp (cdr exp))))
                       ((eq? CLOSING_BRACE first-elt)
                        (cons " }" (transform-exp (cdr exp))))
                       ((eq? OPENING_PARENTHESIS first-elt)
                        (cons " (" (transform-exp (cdr exp))))
                       ((eq? CLOSING_PARENTHESIS first-elt)
                        (cons " )" (transform-exp (cdr exp))))
                       ((eq? OPENING_BRACKET first-elt)
                        (cons " [" (transform-exp (cdr exp))))
                       ((eq? CLOSING_BRACKET first-elt)
                        (cons " ]" (transform-exp (cdr exp))))
                       ((eq? COLON first-elt)
                        (cons ":" (transform-exp (cdr exp))))
                       ((eq? SEMICOLON first-elt)
                        (cons ";" (transform-exp (cdr exp))))
                       ((eq? COMMA first-elt)
                        (cons ", " (transform-exp (cdr exp))))
                       ((eq? ASTERISK first-elt)
                        (cons "*" (transform-exp (cdr exp))))
                       ((eq? ELLIPSIS first-elt)
                        (cons " ..." (transform-exp (cdr exp))))
                       ;; это какой-то другой символ
                       ;; преобразовать в строку, присоединить к списку строк
                       (else (cons (string-append " " (symbol->string first-elt))
                                   (transform-exp (cdr exp))))))))))

#+END_SRC

#+NAME: transform_exp_tests
#+BEGIN_SRC scheme :noweb yes
  (define test-exp
    (compile-main
     (append (list 'proc1) (compile-parenthesis '()) (list SEMICOLON)
             (list 'proc2) (compile-parenthesis '()) (list SEMICOLON)
             (list 'proc3) (compile-parenthesis '()) (list SEMICOLON))))

  (transform-exp test-exp)

  (define test-exp2
    (append (list 'val) (list ASTERISK) (list 'init_syntax_errors)
            (compile-parenthesis '())
            (compile-braces (append (list 'char) (list ASTERISK) (list 'string)
                                    (list ASTERISK) (list '=)
                                    (list 'malloc)
                                    (compile-parenthesis
                                     (append (list 'sizeof)
                                             (compile-parenthesis
                                              (append
                                               (list 'char)
                                               (compile-brackets
                                                (list
                                                 'max_symbol_name_length))))))))))

  (transform-exp test-exp2)
#+END_SRC
Теперь напишем функцию, которая будет принимать несколько списков -
скомпилированных выражений - и вызывать transform-exp для каждого из них
и возвращать общий список из результатов, которые вернул transform-exp

#+NAME: compiled_code_to_string
#+BEGIN_SRC scheme :noweb yes
  (define (compiled-code->string code)
    (if (null? code)
        '()
        (let ((first-exp (car code)))
          (if (pair? first-exp)
              (append (transform-exp first-exp) (compiled-code->string (cdr code)))
              (transform-exp code)))))

#+END_SRC

#+NAME: compiled_code_to_string_tests
#+BEGIN_SRC scheme :noweb yes
  (define test-exp
    (compile-main
     (append (list 'proc1) (compile-parenthesis '()) (list SEMICOLON)
             (list 'proc2) (compile-parenthesis '()) (list SEMICOLON)
             (list 'proc3) (compile-parenthesis '()) (list SEMICOLON))))

  (transform-exp test-exp)

  (define test-exp2
    (append (list 'val) (list ASTERISK) (list 'init_syntax_errors)
            (compile-parenthesis '())
            (compile-braces (append (list 'char) (list ASTERISK) (list 'string)
                                    (list ASTERISK) (list '=)
                                    (list 'malloc)
                                    (compile-parenthesis
                                     (append (list 'sizeof)
                                             (compile-parenthesis
                                              (append
                                               (list 'char)
                                               (compile-brackets
                                                (list
                                                 'max_symbol_name_length))))))))))
  (compiled-code->string (list test-exp
                               test-exp2))

  (compiled-code->string test-exp)

  (compiled-code->string test-exp2)
#+END_SRC

Теперь пишем функцию, которая запишет полученный список строк в заданный
файл, снабжая печать переводом строкив случае если:
- это открывающая или закрывающая фигурная скобка
- двоеточие
- точка с запятой

#+NAME: print_code_into_file
#+BEGIN_SRC scheme :noweb yes
  (load-option 'format)
  (define *c-file* "test-file.txt")

  (define (print-code-into-file code-string)
    (define (rec-print-code code-string output-port)
      (if (null? code-string)
          'ok
          (let ((first-string (car code-string)))
            (if (or (equal? first-string " {" )
                    (equal? first-string " }" )
                    (equal? first-string ";" )
                    (equal? first-string ":" ))
                (begin
                  (format output-port "~A ~% "first-string)
                  (rec-print-code (cdr code-string) output-port))
                (begin
                  (format output-port "~A" first-string)
                  (rec-print-code (cdr code-string) output-port))))))
    (let ((output-port (open-output-file  *c-file*)))
      (rec-print-code code-string output-port)
      (close-output-port output-port)
      'ok))
#+END_SRC

#+NAME: print_code_into_file_tests
#+BEGIN_SRC scheme :noweb yes
  (define test-exp
    (compile-main
     (append (list 'proc1) (compile-parenthesis '()) (list SEMICOLON)
             (list 'proc2) (compile-parenthesis '()) (list SEMICOLON)
             (list 'proc3) (compile-parenthesis '()) (list SEMICOLON))))

  (define test-exp2
    (append (list 'val) (list ASTERISK) (list 'init_syntax_errors)
            (compile-parenthesis '())
            (compile-braces (append (list 'char) (list ASTERISK) (list 'string)
                                    (list '=)
                                    (list 'malloc)
                                    (compile-parenthesis
                                     (append (list 'sizeof)
                                             (compile-parenthesis
                                              (append
                                               (list 'char)
                                               (compile-brackets
                                                (list
                                                 'max_symbol_name_length))))))
                                    (list SEMICOLON)))))

  (define tokens (compiled-code->string (list test-exp
                                              test-exp2)))
  (print-code-into-file tokens)
#+END_SRC

Теперь напишем соберем все в единую функцию, которая будет вызывать
преобразование всех скомпилированных выражений и их печать

#+NAME: print_code
#+BEGIN_SRC scheme :noweb yes
  (define (print-code exps)
    (print-code-into-file (compiled-code->string exps)))
#+END_SRC

~Построение окружений~

Здесь обошлось без рефакторинга.

Окружения нужны только для того, чтоб компилятор мог отслеживать, в каком месте
появляется переменная и определена ли она была вообще. Получается, что
данные "окружения" будут состоять только из имен переменных без их
значений, поскольку на этапе компиляции значения не играют никакой роли.
Максимум можно указывать какого именно типа переменная - функция, число и
т.д., поскольку мы компилим код для си. Но это необязательно.

Окружения будут иметь списковую структуру как в сикпе, только если в
сикпе кадр состояит из двух списков, где первый список - это имена
переменных, а второй - это их значения, то мои псевдоокружения будут
состоять из кадров, которые будут содержать только имена переменных. Чем
ближе кадр к концу списка кадров, тем ближе он к глобальной области видимости.

То есть в окружении ((d f g h) (n test-fn factorial) (primitives-proc-names))
последий кадр является глобальным окружением.
При запуске компилятора будет устанавливаться начальное окружение,
состоящего только из кадра с примитивами.

При компиляции функции окружение будет расширяться кадром, который будет
наследовать все переменные глобального окружения + формальные параметры
функции, а затем будет дополняться новыми переменными, если в этом
возникнет необходимость. По завершению компиляции этот кадр будет
удаляться, поскольку никакие другие процедуры кроме текущей не должны
иметь доступ к переменным, объявленным внутри этой функции.

Связываем имена лисповых примитивов и сишных, чтоб знать, какие именно
имена компилировать, если использованы данные примитивы, поскольку имена
сишных примитивов и примитивов схемы не всегда совпадают из-за
синтаксических правил си банального неудобства.

#+NAME: primitives_proc
#+BEGIN_SRC scheme :noweb yes
  (define (primitive-proc-bindings)
    (list (list 'car 'car)
          (list 'cdr 'cdr)
          (list 'cons 'cons)
          (list 'list 'make-list)
          (list  '+ 'add)
          (list  '- 'sub)
          (list  '* 'mul)
          (list  '/ 'division)
          (list  '= 'equal_numbers_predicate)
          (list  '> 'bigger_predicate)
          (list  '< 'smaller_predicate)
          (list  'reverse 'reverse)
          (list  'append 'append)
          (list  'assoc 'assoc)
          (list  'length 'length_compile)
          (list  'last-pair 'last_pair)
          (list  'true? 'true_predicate_compile)
          (list  'false? 'false_predicate_compile)
          (list  'null? 'null_predicate_compile)
          (list  'pair? 'pair_predicate_compile)
          (list  'symbol? 'symbol_predicate_compile)
          (list  'atom? 'atom_predicate_compile)
          (list  'string? 'string_predicate_compile)
          (list  'dotpair? 'dotpair_predicate_compile)))

  (define (primitive-procedure-objects)
    (map (lambda (proc)
           (list (car proc)
                 (list 'primitive (cadr proc))))
         (primitive-proc-bindings)))
#+END_SRC

Конструируем аналоги сикповых процедур для окружений, только с тем
расчетом, что у нас кадр состоит только из имен переменных.
#+NAME: environment
#+BEGIN_SRC scheme :noweb yes
  (define (atom? arg)
    (or (string? arg) (number? arg)
        (symbol? arg)))

  (define (enclosing-environment env) (cdr env))

  (define (first-frame env) (car env))

  (define the-empty-environment '())

  (define (add-binding-to-frame! var frame)
    (let* ((first-elt (car frame))
           (rest (cdr frame)))
      (set-car! frame var)
      (set-cdr! frame (list first-elt))
      (let ((last-elt (last-pair frame)))
        (set-cdr! last-elt rest)
        frame)))

  (define (extend-environment vars base-env)
    (if (null? vars)
        base-env
    (cons vars base-env)))

  (define (lookup-variable var env)
    (define (env-loop env)
      (define (scan vars)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((and (pair? var) (pair? (car vars)))
               (if (eq? (car var) (caar vars))
                   (car vars)
                   (scan (cdr vars))))
              ((and (not (pair? var)) (pair? (car vars)))
               (if (eq? var (caar vars))
                   (car vars)
                   (scan (cdr vars))))
              ((eq? var (car vars)) 'ok)
              (else (scan (cdr vars)))))
      (if (eq? env the-empty-environment)
          (error "Compile: Несвязанная переменная" var)
          (let ((frame (first-frame env)))
            (scan frame))))
    (env-loop env))

  (define (define-variable! var env)
    (let ((frame (first-frame env)))
      (define (scan vars)
        (cond ((null? vars)
               (begin
                 (format #t "define-variable!: переменная новая ~%" )
                 (add-binding-to-frame! var frame)
                 'ok))
              ((and (pair? var) (pair? (car vars)))
               (if (eq? (car var) (caar vars))
                   (car vars)
                   (scan (cdr vars))))
              ((and (atom? var) (pair? (car vars)))
               (if (eq? var (caar vars))
                   (car vars)
                   (scan (cdr vars))))
              ((eq? var (car vars)) (car vars))
              (else (scan (cdr vars)))))
      (scan frame)))

  (define (delete-frame env)
    (set! env (cdr env)))

  (define (setup-environment)
    (let ((initial-env
           (extend-environment (primitive-procedure-objects)
                               the-empty-environment)))
      initial-env))

  (define global-environment (setup-environment))
#+END_SRC

#+NAME: copy_environment
#+BEGIN_SRC scheme :noweb yes
  (define (copy-frame frame)
    (if (null? frame)
        '()
        (let ((first-elt (car frame)))
          (if (pair? first-elt)
          (cons (copy-frame first-elt)
                (copy-frame (cdr frame)))
          (cons first-elt (copy-frame (cdr frame)))))))

  (define test-env (copy-frame global-environment))

  (add-binding-to-frame! 'n (car test-env))
#+END_SRC

#+NAME: environment_tests
#+BEGIN_SRC scheme :noweb yes
  (define test-env (setup-environment))

  (set! test-env (extend-environment '( f s n l) test-env))

  (add-binding-to-frame! 'd (first-frame test-env))

  (add-binding-to-frame! '(test_fn compound) (first-frame test-env))

  (lookup-variable '(test_fn compound) test-env)

  (lookup-variable 's test-env)

  (lookup-variable '(s n) test-env)

  (lookup-variable '(car car) test-env)
#+END_SRC

~Компиляция примитивов~

Для компиляции вызовов примитивов и любых функций вообще, необходимо
сначала скомпилировать аргументы вызова, а затем передеть их имена или
вызовы их функций в вызов примитива и так скомиплировать.

Для начала научимся компилировать:
- числа
- строки
- символы
- вызовы других примитивов

Если в схеме можно споокйно передать в вызов число, то в си сначала
придется выделять под него память, потом заносить значение по указателю,
потом вызывать конструктор. В общем, заморочно.

Создадим конструкторы, которые будут компилировать символы, строки и
числа. Каждый из них будет принимать имя будущей переменной, которая
будет содержать в себе необходимое значение. Этик онструкторы нам
пригодятся, когда мы будем компилировать определения переменных.

Нужно создать конструкторы, комиплирующие:
- строки
- символы
- числа

Сначала создадим конструкторы, которые будут комиплировать код для
выделения памяти.
#+NAME: allocate_memory_constructors
#+BEGIN_SRC scheme :noweb yes
  ;; компилирует выделение памяти на 1 инт
  (define (compile-malloc-int var-name)
    (let* ((malloc-int (append '(malloc)
                               (compile-parenthesis (append '(sizeof)
                                                            (compile-parenthesis 'int)))))
           (int-pointer (list 'int  ASTERISK (append-ptr var-name) '=)))
      (append int-pointer malloc-int (list SEMICOLON))))

  ;; кмопилирует код для выделения массива на 100 чаров
  (define (compile-malloc-char var-name)
    (let* ((malloc-char (append '(malloc)
                                (compile-parenthesis (append '(sizeof)
                                                             (compile-parenthesis
                                                              (append '(char)
                                                                      (compile-brackets
                                                                       100)))))))
           (char-pointer (list 'char ASTERISK (append-ptr var-name) '=)))
      (append char-pointer malloc-char (list SEMICOLON))))

  (define (compile-malloc-cell var-name)
    (let* ((malloc-int (append '(malloc)
                               (compile-parenthesis (append '(sizeof)
                                                            (compile-parenthesis 'cell)))))
           (int-pointer (list 'int  ASTERISK (append-ptr var-name) '=)))
      (append int-pointer malloc-int (list SEMICOLON))))

  ;; комиплирует код для комипрования строки в выделенную память
  (define (compile-strcpy var-name string)
    (append
     '(strncpy) (compile-parenthesis
                 (list (append-ptr var-name) COMMA string COMMA 100))
     (list SEMICOLON)))

  ;; присваивает неинициализированному указателю значение
  (define (compile-set-value-to-pointer p-name value)
    (list ASTERISK (append-ptr p-name) '= value SEMICOLON))
#+END_SRC

Теперь на их основе создаем конструкторы для строк, чисел и символов.
Они компилируют код для выделения памяти, присвоения ей значения и вызова
соответствующих конструкторов, определенных в файле ~test.c~.

Параметр ~var-name~ должен быть строкой.
#+NAME: nums_strings_symbols_constructors
#+BEGIN_SRC scheme :noweb yes
  (define (compile-int-val-constructor var-name var-value)
    (if (string? var-name)
        (let ((allocated-memory (compile-malloc-int var-name))
              (set-value-to-pointer (compile-set-value-to-pointer var-name var-value)))
          (list (append allocated-memory
                        set-value-to-pointer
                        (list 'val ASTERISK var-name '= 'int_val_constructor)
                        (compile-parenthesis (append-ptr var-name))
                        (list SEMICOLON))
                (list var-name)))
        (error "var-name should be a string -- compile-int-val-constructor" var-name)))

  (define (compile-symbol-val-constructor var-name string)
    (if (string? var-name)
        (let* ((allocated-memory (compile-malloc-char var-name))
               (strcpy (compile-strcpy var-name string)))
          (list (append
                 allocated-memory strcpy
                 (list 'val ASTERISK var-name '= 'symbol_val_constructor)
                 (compile-parenthesis (append-ptr var-name))
                 (list SEMICOLON)) (list var-name)))
        (error "var-name should be a string -- compile-symbol-val-constructor" var-name)))

  (define (compile-string-val-constructor var-name string)
    (if (string? var-name)
        (let* ((allocated-memory (compile-malloc-char var-name))
               (strcpy (compile-strcpy var-name string)))
          (list (append
                 allocated-memory strcpy
                 (list 'val ASTERISK var-name '= 'string_val_constructor)
                 (compile-parenthesis (append-ptr var-name))
                 (list SEMICOLON)) (list var-name)))
        (error "var-name should be a string -- compile-string-val-constructor" var-name)))

#+END_SRC

#+NAME: nums_strngs_symols_constructors_tests
#+BEGIN_SRC scheme :noweb yes
  (print-code (compile-int-val-constructor "var1" 1))

  ;; должны получить ошибку
  (print-code (compile-int-val-constructor 'var1 1))

  (print-code (compile-string-val-constructor "var1" "\"string\""))

  ;; должны получить ошибку
  (print-code (compile-string-val-constructor 'var1 "\"string\""))

  (print-code (compile-symbol-val-constructor "var1" "\"symbol\""))

  ;; должны получить ошибку
  (print-code (compile-symbol-val-constructor 'var1 "\"symbol\""))
#+END_SRC

Теперь приступаем к самой компиляции примитивов.

Помимо компиляции аргументов, надо еще правильно скомпилировать вызов
примитива. Например, list принимает множество параметров, которые в си
должны быть перечислены через запятую. То же самое касается люых
составных функций, которые будет вызывать пользователь.

Создадим конструктор, который будет принимать список параметров, а
возвращать этот же список, но только параметры будут перечислены через
запятую.

#+NAME: compile_call_params_in_c_syntax
#+BEGIN_SRC scheme :noweb yes
  (define (compile-call-params-in-c-syntax params)
    ;; (format #t "compile-call-params-in-c-syntax: params ~A ~%" params)
    (if (null? params)
        '()
        (let ((cur-param (if (null? (cdr params))
                             (list  (car params))
                             (list  (car params) COMMA))))
          (append cur-param (compile-call-params-in-c-syntax (cdr params))))))

#+END_SRC

#+NAME: compile_call_params_in_c_syntax_tests
#+BEGIN_SRC scheme :noweb yes
  (compile-call-params-in-c-syntax '(0 1 2 3 4))

  (compile-call-params-in-c-syntax '(0 val1 "string" (some list)))

  (compile-call-params-in-c-syntax '())
#+END_SRC

Теперь сами конструкторы для вызова примитивов.
#+NAME: compile_primitives_constructors
#+BEGIN_SRC scheme :noweb yes
  (define (compile-list args)
    (let* ((amount-of-args (length args))
           (new-args (append (list amount-of-args)
                             args)))
      (append '(make_list)
              (compile-parenthesis (compile-call-params-in-c-syntax new-args)))))

  (define (compile-cons args)
    (let ((first-arg (car args))
          (second-arg (cadr args)))
      (append '(cons)
              (compile-parenthesis
               (list first-arg COMMA second-arg)))))

  (define (compile-car args)
    (append '(car)
            (compile-parenthesis args)))

  (define (compile-cdr args)
    (append '(cdr)
            (compile-parenthesis args)))

  (define (compile-set-car args)
    (append '(set_car)
            (compile-parenthesis args)))

  (define (compile-set-cdr args)
    (append '(set_cdr)
            (compile-parenthesis args)))

  (define (compile-append args)
    (let ((first-arg (car args))
          (second-arg (cadr args)))
      (append '(append)
              (compile-parenthesis
               (list first-arg COMMA second-arg)))))

  (define (compile-assoc args)
    (let ((first-arg (car args))
          (second-arg (cadr args)))
      (append '(assoc)
              (compile-parenthesis
               (list first-arg COMMA second-arg)))))

  (define (compile-length args)
    (append '(length_compile)
            (compile-parenthesis args)))

  (define (compile-last-pair args)
    (append '(last_pair)
            (compile-parenthesis args)))

  (define (compile-smaller-predicate-compile args)
    (append '(smaller_predicate_compile)
            (compile-parenthesis args)))

  (define (compile-bigger-predicate-compile args)
    (append '(bigger_predicate_compile)
            (compile-parenthesis args)))

  (define (compile-equal-numbers args)
    (let ((first-arg (car args))
          (second-arg (cadr args)))
      (append '(equal_numbers_predicate_compile)
              (compile-parenthesis
               (list first-arg COMMA second-arg)))))

  (define (compile-add args)
    (append '(add)
            (compile-parenthesis args)))

  (define (compile-sub args)
    (append '(sub)
            (compile-parenthesis args)))

  (define (compile-mul args)
    (append '(mul)
            (compile-parenthesis args)))

  (define (compile-division args)
    (append '(division)
            (compile-parenthesis args)))

  (define (compile-reverse args)
    (append '(reverse)
            (compile-parenthesis args)))

  (define (compile-true? args)
    (append '(true_predicate_compile)
            (compile-parenthesis args)))

  (define (compile-false? args)
    (append '(false_predicate_compile)
            (compile-parenthesis args)))

  (define (compile-null? args)
    (append '(null_predicate_compile)
            (compile-parenthesis args)))

  (define (compile-pair? args)
    (append '(pair_predicate_compile)
            (compile-parenthesis args)))

  (define (compile-atom? args)
    (append '(atom_predicate_compile)
            (compile-parenthesis args)))
#+END_SRC

#+NAME: compile_primitives_constructors_tests
#+BEGIN_SRC scheme :noweb yes
  (print-code (compile-list '("\" 3 \"" 1 2 d)))

  (print-code( compile-cons '(1 2)))

  (print-code(compile-car '(some-list)))

  (print-code(compile-cdr '(some-list)))

  (print-code(compile-set-car '(some-list)))

  (print-code(compile-set-cdr '(some-list)))

  (print-code(compile-assoc '(some-key some-list)))

  (print-code(compile-length '(some-list)))

  (print-code(compile-last-pair '(some-list)))

  (print-code(compile-smaller-predicate-compile '(some args)))

  (print-code(compile-bigger-predicate-compile '(some args)))

  (print-code(compile-equal-numbers '(some args)))
#+END_SRC


Теперь стоит еще одна задача: правильно соединить скомиплированный код
для аргументов и вызов примитива. Эта задача касается не только текущего
примера, но и всего компилятора в целом.

Мы представляем себе, что скомиплированный код всегда будет возвращаться
в следующем виде ~((скомиплированный код) (способ, которым можно к нему
обратиться))~ , если было скомпилировано одно выражение, и
~(((скомиплированный код) (способ, которым можно к нему обратиться))
  ((скомиплированный код) (способ, которым можно к нему обратиться))
  ((скомиплированный код) (способ, которым можно к немe обратиться)))~,
если было скомиплировано несколько выражений.

Следовательно, нужно вытащить из списков сам скомиплированный код,
соединить его с другим скомпилированным кодом, и отдельно получить
способ, как ко всему этому коду можно было бы обратиться.

Напишем функцию, которая получает на вход описанный выше список, а
возвращает список только с скомпилированным кодом.

#+NAME: connect_compiled_code
#+BEGIN_SRC scheme :noweb yes
  (define (connect-compiled-exps compiled-exps-with-names)
    (if (null? compiled-exps-with-names)
        '()
        (let* ((compiled-exp (car compiled-exps-with-names))
               (compiled-code (car compiled-exp))
               (name-compiled-code (cadr compiled-exp)))
          ;; проверяем, поступило нам множество скомиплированных выражений
          (if (and (pair? compiled-code)
                   (pair? name-compiled-code))
              ;; выражений множество
              (append compiled-code
                      (connect-compiled-exps (cdr compiled-exps-with-names)))
              ;; выражение было единичным
              compiled-exp))))
#+END_SRC

И напишем функцию, которая будет вытаскивать вызовы скомпилированного
кода из полученных списков, показанных выше, и формировать из них
отдельный список.
#+NAME: get_names_and_calls
#+BEGIN_SRC scheme :noweb yes
  (define (get-names-and-calls compiled-exps-with-names)
    (let* ((compiled-exp (car compiled-exps-with-names))
           (compiled-code (car compiled-exp))
           (name-compiled-code (cadr compiled-exp)))
      ;; проверяем, скомиплировано у нас 1 выражение или много
      (if (and (pair? compiled-code)
               (pair? name-compiled-code))
          (map (lambda (code)
                 (if (= 1 (length (cadr code)))
                     (caadr code)
                 ;; (format #t "get-names-and-calls: ~A ~%" (cadr code))
                     (cadr code))) compiled-exps-with-names)
          (cadr compiled-exps-with-names))))
#+END_SRC

#+NAME: connect_compiled_code_and_get_names_and_calls_tests
#+BEGIN_SRC scheme :noweb yes
  (define test-code
    (list
     (compile-int-val-constructor "var1" 1)
     (compile-int-val-constructor "var2" 2)
     (compile-symbol-val-constructor "var3" "\"some symbol\"")
     (list  '("some_fn_name") (append '( "some_fn_call") (compile-parenthesis'())))))

  (define test-code2
    (compile-int-val-constructor "var1" 1))

  (define test-code3
    '((existing_var some_var) (some_var)))

  (define test-code4
    (list  (append '( "some_fn_name") (compile-parenthesis'()))
           (append '( "some_fn_call") (compile-parenthesis'()))))

  (print-code (connect-compiled-exps test-code))
  (print-code (get-names-and-calls test-code))

  (print-code (connect-compiled-exps test-code2))
  (print-code (get-names-and-calls test-code2))

  (print-code (connect-compiled-exps test-code3))
  (print-code (get-names-and-calls test-code3))

  (print-code (connect-compiled-exps test-code4))
  (print-code (get-names-and-calls test-code4))
#+END_SRC

Пишем конструктор для создания возвращемого значения.
#+NAME: return_value_constructor
#+BEGIN_SRC scheme :noweb yes
  (define (return-value-constructor retval)
    (if (pair? retval)
        (append '(return)
                retval (list SEMICOLON))
        (list 'return retval SEMICOLON)))
#+END_SRC

#+NAME: return_value_constructor_tests
#+BEGIN_SRC scheme :noweb yes
  (return-value-constructor (append (list "some_fn_call")
                                    (compile-parenthesis'())))

  (return-value-constructor 1)
#+END_SRC

Теперь нам нужна процедура, которая будет вызывать компиляцию всех
аргументов. Она нам пригодится не только для вызова примитивов, но и для
вызова любых процедур.

Механизм очень простой: каждый аргумент будет передаваться в функцию
~compile~, которая будет определять, какого типа у нас выражение:
определение, вызов функции, переменная и т.д. и вызывать соответствующий
констрктор для компиляции выражения.

Пока что ~compile~ будет поддерживать только 3 вида выражений:
самовычисляющиеся - строки и числа - нахождение переменных и вызов
примитивов.

#+NAME: compile_args
#+BEGIN_SRC scheme :noweb yes
  (define (compile-args args env)
    (define (compile-args-rec args compiled-code)
      (if (null? args)
          (begin
            ;; (format #t "compiled-code ~A ~%" compiled-code)
            compiled-code)
          (let* ((compiled-arg-code (compile (car args) env)))
            ;; (format #t "compiled-arg-code ~A ~%" compiled-arg-code)
            (compile-args-rec (cdr args) (append compiled-code (list
                                                                compiled-arg-code))))))
    (compile-args-rec (cdr args) (list (compile (car args) env))))
#+END_SRC

#+NAME: compile_self_evaluating
#+BEGIN_SRC scheme :noweb yes
  (define (self-evaluating? exp)
    (cond ((number? exp) true)
          ((string? exp) true)
          (else false)))

  (define (compile-self-evaluating exp)
    ;; (format #t "compile-self-evaluating ~A ~%" exp)
    (if (number? exp)
        (compile-int-val-constructor (generate-name-string exp)
                                     exp)
        (compile-string-val-constructor (generate-name-string exp)
                                        exp)))
#+END_SRC

#+NAME: compile_variable
#+BEGIN_SRC scheme :noweb yes
  (define (compile-variable exp env)
    ;; (format #t "compile-variable: exp ~A ~%" exp)
    (if (lookup-variable exp env)
        (let* ((return-value (return-value-constructor exp))
               (service-fn-name (generate-name-string exp))
               (call-service-fn (append (list service-fn-name) (compile-parenthesis '()))))
          (list (compile-service-fn service-fn-name
                                    return-value)
                call-service-fn))))
#+END_SRC

Создаем ~compile~ для наших текущих целей. По мере добавления нового
функционала в компилятор эта функция будет расширяться.
#+NAME: compile_for_primitives
#+BEGIN_SRC scheme :noweb yes
  (define (compile exp env)
    (cond ((self-evaluating? exp)
           (compile-self-evaluating exp))
          ((variable? exp)
           (compile-variable exp env))
          (else (compile-primitive exp env))))

#+END_SRC

Теперь напишем процедуру, которая будет вызывать тот или иной конструктор
для в зависимости от того, вызов какого примитива нужено скомпилировать
#+NAME: compile_primitives
#+BEGIN_SRC scheme :noweb yes
  (define (compile-primitive-call operator compiled-args-names)
    ;; (format #t "compile-primitive-call: compiled-args-names ~A ~%" compiled-args-names)
    (cond ((eq? operator 'list)
           (compile-list compiled-args-names))
          ((eq? operator 'cons)
           (compile-cons compiled-args-names))
          ((eq? operator 'car)
           (compile-car compiled-args-names))
          ((eq? operator 'cdr)
           (compile-cdr compiled-args-names))
          ((eq? operator 'set-car!)
           (compile-set-car compiled-args-names))
          ((eq? operator 'set-cdr!)
           (compile-set-cdr compiled-args-names))
          ((eq? operator 'append)
           (compile-append compiled-args-names))
          ((eq? operator 'assoc)
           (compile-assoc compiled-args-names))
          ((eq? operator 'length)
           (compile-length compiled-args-names))
          ((eq? operator 'last-pair)
           (compile-last-pair compiled-args-names))
          ((eq? operator '=)
           (compile-equal-numbers compiled-args-names))
          ((eq? operator '+)
           (compile-add (compile-list compiled-args-names)))
          ((eq? operator '>)
           (compile-bigger-predicate-compile (compile-list compiled-args-names)))
          ((eq? operator '<)
           (compile-smaller-predicate-compile (compile-list compiled-args-names)))
          ((eq? operator '-)
           (compile-sub (compile-list compiled-args-names)))
          ((eq? operator '*)
           (compile-mul (compile-list compiled-args-names)))
          ((eq? operator '/)
           (compile-division (compile-list compiled-args-names)))
          ((eq? operator 'reverse)
           (compile-reverse compiled-args-names))
          ((eq? operator 'true?)
           (compile-true? compiled-args-names))
          ((eq? operator 'false?)
           (compile-false? compiled-args-names))
          ((eq? operator 'null?)
           (compile-null? compiled-args-names))
          ((eq? operator 'pair?)
           (compile-pair? compiled-args-names))
          ((eq? operator 'atom?)
           (atom? compiled-args-names))
          (else (error "Неизвестный примитив -- compile-primitive" operator))))

  (define (compile-primitive exp env)
    (if (null? (operands exp))
        (let* ((compiled-args '())
               (return-value (return-value-constructor
                              (compile-primitive-call (operator exp) compiled-args)))
               (service-fn-name (generate-name-string exp))
               (call-service-fn (append (list service-fn-name) (compile-parenthesis '()))))
          (list (compile-service-fn service-fn-name return-value)
                (list  call-service-fn)))
        (let* ((compiled-args (compile-args (operands exp) env)))
          ;; (format #t "compiled-args ~A ~%" compiled-args)
          (let*
              ((compiled-args-names (get-names-and-calls compiled-args))
            (return-value (return-value-constructor
                           (compile-primitive-call (operator exp) compiled-args-names)))
            (service-fn-name (generate-name-string exp))
            (call-service-fn (append (list service-fn-name) (compile-parenthesis '()))))
          ;; (format #t "compile-cur-primitive: compiled-args ~A ~%"
          ;; (connect-compiled-exps compiled-args))
          (list (compile-service-fn service-fn-name
                                    (append (connect-compiled-exps compiled-args)
                                            return-value))
                call-service-fn)))))
#+END_SRC

#+NAME: compile_primitives_tests
#+BEGIN_SRC scheme :noweb yes
  (print-code (compile-primitive '(list 1 2 3 4) global-environment))

  (print-code (compile-primitive '(cons 1 2) global-environment))

  (print-code (compile-primitive '(cons (list 1 2) (list 3 4)) global-environment))

  (print-code (compile-primitive '(cons (+ 1 2) (list 4 5)) global-environment))

  (print-code (compile-primitive '(+ (* 1 2) (/ 9 (+ 1 2)) (- 4 5) 8)
                                 global-environment))

  (print-code (compile-primitive '(last-pair (list 1 2 3 4))
                                 global-environment))

  (print-code (compile-primitive '(> 1 2)
                                 global-environment))
#+END_SRC


~Определения~

Определять можно как функции, так и переменные, а так же это можно делать
локально или глобально.

Сначала определяем, поступило нам на вход определение функции или
переменной.
#+NAME: define_definition
#+BEGIN_SRC scheme :noweb yes
  (define (tagged-list? exp tag)
    (if (pair? exp)
        (eq? (car exp) tag)
        false))

  (define (definition? exp)
    (tagged-list? exp 'define))

  (define (definition-fn? exp)
    (pair? (cadr exp)))

  (define (compile-definition exp env)
    ;; (format #t "compile-definition ~A ~%" exp)
    (if (definition-fn? exp)
        (compile-named-function exp env)
        (compile-global-var exp env)))
#+END_SRC

Сначала разбираемся с переменными.
Нам нужно пределить, локальная она или глобальная. Если у нас 1 кадр в
окружении, то мы в голобальном окружении. Иначе считаем окружение
локальным.

А теперь мысль: область виимости переменной определяет буквально то
место, где она была объявлена. То есть скомпиленный код в моем случае
будет вкомпилен туда, откуда его вызвали. Так что нет никакой разницы
между кодом, который я буду компилить для локальной переменной или
глобальной.

Пока что не включать этот код в компилятор.
#+NAME: compile_definition_var
#+BEGIN_SRC scheme :noweb yes
  (define (global-env? env)
    ( = ( length env) 1))

  ;; (global-env? global-environment)

  ;; (global-env? (cons '(some var names) global-environment))

  ;; вызывает компиляцию локальной или глобальной переменной
  (define (compile-definition-var exp env)
    (if (global-env? env)
        (compile-definition-var-global exp env)
        (compile-definition-var-local exp env)))
#+END_SRC

Начнем с глобальных переменных.
Объявление неинициализированной глобальной переменной в си.

Вкопиль сюда switch!

Нельзя просто так приравнять одну переменную другой, поскольку в
скомпиленном коде мы все врем оперируем указателями на структуры,
следовательно, при попытке сделать ~n = d;~ мы приравняем указатели. А
нам нужно, чтоб в n попало значение d. Так что придется выяснять,какого
типа структура d - строка, символ, ячейка и т.д. и приравнивать
соответствующим образом.
#+NAME: compile_unassigned_variable
#+BEGIN_SRC scheme :noweb yes
  (define (compile-unassigned-variable var-name)
    (list 'val ASTERISK (symbol->string var-name) SEMICOLON))
#+END_SRC

Теперь компиляция присваивания ей значений. Значения могут:
- другая переменная
- список
- строка
- число
- символ

При присваивании есть тонкость. Переменные могут быть как определены
только что, так и переопределены. В случае, если переменные уже были
определны и теперь переопределяются, память под них уже выделена, поэтому
к ней можно обращаться, не рискуя наткнуться на NULL или мусор, который в
дальнейшем приведет к падению сишной программы.
Но если переменная была только объявлена и неинициализированна, то память
под нее еще не выделена, следовательно при попытке получить указатель на
значение, чтоб присвоить ему другое значение, можно наткнуться на крупные
неприятности.

Поэтому присваивание значения будет выполняться по-разному в завиимости
от того, определяем мы переменную заново или переопределяем.

Сначала сделаем присваиния для случая, кoгда переменная
неинициализирована.

#+NAME: make_unassigned-var_assingments
#+BEGIN_SRC scheme :noweb yes
  (define (make-int-assignment-for-unassigned-var var-name var-value)
    (let* ((var-name-string (if (string? var-name)
                                var-name
                                (symbol->string var-name)))
           (allocated-memory (compile-malloc-int var-name-string))
           (set-value-to-pointer (compile-set-value-to-pointer var-name-string var-value)))
      (list (append allocated-memory
                    set-value-to-pointer
                    (list var-name-string '= 'int_val_constructor)
                    (compile-parenthesis (append-ptr var-name-string))
                    (list SEMICOLON))
            (list var-name-string))))


  (define (make-string-assignment-for-unassigned-var var-name string)
    (let* ((var-name-string (if (string? var-name)
                                var-name
                                (symbol->string var-name)))
           (allocated-memory (compile-malloc-char var-name-string))
           (strcpy (compile-strcpy var-name-string string)))
      (list (append
             allocated-memory strcpy
             (list var-name-string '= 'string_val_constructor)
             (compile-parenthesis (append-ptr var-name-string))
             (list SEMICOLON)) (list var-name-string))))


  (define (make-symbol-assignment-for-unassigned-var var-name string)
    (let* ((var-name-string (if (string? var-name)
                                var-name
                                (symbol->string var-name)))
           (allocated-memory (compile-malloc-char var-name-string))
           (strcpy (compile-strcpy var-name-string string)))
      (list (append
             allocated-memory strcpy
             (list var-name-string '= 'symbol_val_constructor)
             (compile-parenthesis (append-ptr var-name-string))
             (list SEMICOLON)) (list var-name-string))))

  (define (make-var-assignment-for-unassigned-var var-name1 var-name2)
    (list (list var-name1 '= var-name2 SEMICOLON) (list var-name1)))


  (define (make-var-assignment-for-unassigned-var var-name1 var-name2)
    (list (list ASTERISK var-name1 '= ASTERISK var-name2 SEMICOLON) (list var-name1)))

  (define (make-int-ptr-malloc-assignment ptr-name)
    (list  ptr-name '=
          (append '(malloc)
                  (compile-parenthesis (append '(sizeof)
                                               (compile-parenthesis 'int))))
          SEMICOLON))

  (define (make-char-ptr-malloc-assignment ptr-name)
    (list ptr-name '=
          (append '(malloc)
                  (compile-parenthesis (append '(sizeof)
                                               (compile-parenthesis
                                                (append '(char)
                                                        (compile-brackets
                                                         100))))))
          SEMICOLON))

  (define (make-var-assignment-for-unassigned-var var1 var2)
    (let* ((var-name1 (if (symbol? var1)
                          (symbol->string var1)
                          var1))
           (var-name2 (if (symbol? var2)
                          (symbol->string var2)
                          var2))
           (type-num-pointer (string-append var-name2 "->type_num"))
           (char-ptr (append-ptr (string-append "char_" var-name1)))
           (int-ptr (append-ptr (string-append "int_" var-name1))))
      (list
       (append
        (list 'int ASTERISK int-ptr SEMICOLON)
        (list 'char ASTERISK char-ptr SEMICOLON)
        (list '(switch) (compile-parenthesis type-num-pointer)
              (compile-braces (append
                               (append
                                (list 'case "TYPE_INT" COLON)
                                (make-int-ptr-malloc-assignment
                                 int-ptr)
                                (compile-set-value-to-pointer
                                 (string-append "int_" var-name1)
                                 (list
                                  ASTERISK
                                  (string-append var-name2 "->uni_val.int_val")))
                                (list var-name1 '= 'int_val_constructor)
                                (compile-parenthesis int-ptr)
                                (list SEMICOLON)
                                (list 'break SEMICOLON))

                               (append
                                (list 'case "TYPE_STRING" COLON)
                                (make-char-ptr-malloc-assignment char-ptr)
                                (compile-strcpy (string-append "char_" var-name1)
                                                (string-append var-name2
                                                               "->uni_val.char_val"))
                                (list var-name1 '= 'string_val_constructor)
                                (compile-parenthesis char-ptr)
                                (list SEMICOLON)
                                (list 'break SEMICOLON))

                               (append
                                (list 'case "TYPE_SYMBOL" COLON)
                                (make-char-ptr-malloc-assignment char-ptr)
                                (compile-strcpy (string-append "char_" var-name1)
                                                (string-append var-name2
                                                               "->uni_val.char_val"))
                                (list var-name1 '= 'symbol_val_constructor)
                                (compile-parenthesis char-ptr)
                                (list SEMICOLON)
                                (list 'break SEMICOLON))

                               (append
                                (list 'case "TYPE_NIL" COLON)
                                (list var-name1 '= 'nil_constructor)
                                (compile-parenthesis '())
                                (list SEMICOLON)
                                (list 'break SEMICOLON))

                               (append
                                (list 'case "TYPE_CELL" COLON)
                                (list var-name1 '= 'cell_val_constructor)
                                (compile-parenthesis (string-append var-name2
                                                                    "->uni_val.cell_val"))
                                (list SEMICOLON)
                                (list 'break SEMICOLON))))))
       (list var-name1))))
#+END_SRC

#+NAME: make_unassigned-var_assingments_tests
#+BEGIN_SRC scheme :noweb yes
  (print-code (make-int-assignment-for-unassigned-var 's 1))

  (print-code (make-int-assignment-for-unassigned-var "s" 1))

  (print-code (make-string-assignment-for-unassigned-var "s" "\" string \""))

  (print-code (make-string-assignment-for-unassigned-var 's "\" string \""))

  (print-code (make-symbol-assignment-for-unassigned-var "s" "symbol"))

  (print-code (make-symbol-assignment-for-unassigned-var 's "symbol"))

  (print-code (make-var-assignment-for-unassigned-var 's 'n))

#+END_SRC

Все констуркторы, созданные ниже, пригодятся при определении
присваиваний.
#+NAME: make_assingments
#+BEGIN_SRC scheme :noweb yes
  (define (make-int-assignment-for-assigned-var var value)
    (let* ((var-name (if (symbol? var)
                         (symbol->string var)
                         var))
           (int-val-pointer (string-append var-name "->uni_val.int_val"))
           (type-num-pointer (string-append var-name "->type_num")))
      (list (append
             (make-int-ptr-malloc-assignment
              (string-append var-name
                             "->uni_val.int_val"))
             (list ASTERISK int-val-pointer '= value SEMICOLON)
             (list type-num-pointer '= "TYPE_INT" SEMICOLON))
            (list var))))

  (define (make-string-assignment-for-assigned-var var string)
    (let* ((var-name (if (symbol? var)
                         (symbol->string var)
                         var))
           (char-val-pointer (string-append var-name "->uni_val.char_val"))
           (type-num-pointer (string-append var-name "->type_num")))
      (list (append
             (compile-malloc-char var-name)
             (compile-strcpy var-name string)
             (list char-val-pointer '= (append-ptr var-name) SEMICOLON)
             (list type-num-pointer '= "TYPE_STRING" SEMICOLON))
            (list var))))

  (define (make-symbol-assignment-for-assigned-var var string)
    (let* ((var-name (if (symbol? var)
                         (symbol->string var)
                         var))
           (char-val-pointer (string-append var-name "->uni_val.char_val"))
           (type-num-pointer (string-append var-name "->type_num")))
      (list (append
             (compile-malloc-char var-name)
             (compile-strcpy var-name string)
             (list char-val-pointer '= (append-ptr var-name) SEMICOLON)
             (list type-num-pointer '= "TYPE_SYMBOL" SEMICOLON))
            (list var))))


  (define (compile-strcpy-existed-ptr var-name string)
    (append
     '(strncpy) (compile-parenthesis
                 (list var-name COMMA string COMMA 100))
     (list SEMICOLON)))

  (define (make-var-assignment-for-assigned-var var1 var2)
    ;; (format #t "make-var-assignment-for-assigned-var ~%")
    (let* ((var-name1 (if (symbol? var1)
                          (symbol->string var1)
                          var1))
           (var-name2 (if (symbol? var2)
                          (symbol->string var2)
                          var2))
           (type-num-pointer2 (string-append var-name2 "->type_num"))
           (type-num-pointer1 (string-append var-name1 "->type_num"))
           (char-ptr (append-ptr (string-append "char_" var-name1)))
           (int-ptr (append-ptr (string-append "int_" var-name1))))
      (list
       (append
        (list 'int ASTERISK int-ptr SEMICOLON)
        (list 'char ASTERISK char-ptr SEMICOLON)
        (list '(switch) (compile-parenthesis type-num-pointer2)
              (compile-braces (append
                               (append
                                (list 'case "TYPE_INT" COLON)
                                (make-int-ptr-malloc-assignment
                                 (string-append var-name1
                                                "->uni_val.int_val"))
                                (list
                                 ASTERISK
                                 (string-append var-name1 "->uni_val.int_val")
                                 '=)
                                (list
                                 ASTERISK
                                 (string-append var-name2 "->uni_val.int_val") SEMICOLON)
                                (list type-num-pointer1 '= "TYPE_INT" SEMICOLON)
                                (list 'break SEMICOLON))

                               (append
                                (list 'case "TYPE_STRING" COLON)
                                (make-char-ptr-malloc-assignment
                                 (string-append var-name1
                                                "->uni_val.char_val"))
                                (compile-strcpy-existed-ptr (string-append var-name1
                                                               "->uni_val.char_val")
                                                (string-append var-name2
                                                               "->uni_val.char_val"))
                                (list type-num-pointer1 '= "TYPE_STRING" SEMICOLON)
                                (list 'break SEMICOLON))

                               (append
                                (list 'case "TYPE_SYMBOL" COLON)
                                (make-char-ptr-malloc-assignment
                                 (string-append var-name1
                                                "->uni_val.char_val"))
                                (compile-strcpy-existed-ptr (string-append var-name1
                                                               "->uni_val.char_val")
                                                (string-append var-name2
                                                               "->uni_val.char_val"))
                                (list type-num-pointer1 '= "TYPE_SYMBOL" SEMICOLON)
                                (list 'break SEMICOLON))

                               (append
                                (list 'case "TYPE_NIL" COLON)
                                (list type-num-pointer1 '= "TYPE_NIL" SEMICOLON)
                                (list 'break SEMICOLON))

                               (append
                                (list 'case "TYPE_CELL" COLON)
                                (list
                                 ASTERISK
                                 (string-append var-name1 "->uni_val.cell_val")
                                 '=)
                                 (list
                                  ASTERISK
                                  (string-append var-name2 "->uni_val.cell_val") SEMICOLON)
                                (list type-num-pointer1 '= "TYPE_CELL" SEMICOLON)
                                (list 'break SEMICOLON))))))
       (list var-name1))))
#+END_SRC

#+NAME: make_assingments
#+BEGIN_SRC scheme :noweb yes
  (print-code (make-int-assignment-for-assigned-var 's 1))

  (print-code (make-int-assignment-for-assigned-var "s" 1))

  (print-code (make-string-assignment-for-assigned-var 's "\" string\""))

  (print-code (make-string-assignment-for-assigned-var "s" "\" string\""))

  (print-code (make-symbol-assignment-for-assigned-var 's "\"symbol\""))

  (print-code (make-symbol-assignment-for-assigned-var "s" "\"symbol\""))
#+END_SRC

Теперь создем две функции.
Одна будет компилировать код для глобальной переменной, которая ранее не
была определена, а вторая будет компилировать код для переопределения
глобальной переменной.

#+NAME: define_global_var
#+BEGIN_SRC scheme :noweb yes
  (define (compile-definition-var var-name value env)
    (let* ((unassigned-variable (compile-unassigned-variable var-name))
           (var-assignment
            (cond ((variable? value)
                   (if (lookup-variable value env)
                       (connect-compiled-exps
                        (make-var-assignment-for-unassigned-var var-name value))))
                  ((number? value)
                   (connect-compiled-exps
                    (make-int-assignment-for-unassigned-var var-name value)))
                  ((string? value)
                   (connect-compiled-exps
                    (make-string-assignment-for-unassigned-var var-name value)))
                  (else (let* ((compiled-value (compile value env))
                               (compile-value-code (connect-compiled-exps compiled-value))
                               (value-call (get-names-and-calls compiled-value)))
                          (append
                           compile-value-code
                           (list var-name '= value-call SEMICOLON))))))
           (service-fn-name (generate-name-string (list var-name value)))
           (call-service-fn (append (list service-fn-name) (compile-parenthesis '()))))
      (list (append
             unassigned-variable
             (compile-service-fn service-fn-name
                                 var-assignment))

            call-service-fn)))

  (define (compile-redefinition-var var-name value env)
    (format #t "compile-redefinition-var ~%")
    (let* ((var-assignment
            (cond ((variable? value)
                   (if (lookup-variable value env)
                       (begin
                         (format #t "значение = переменная ~%")
                         (connect-compiled-exps
                          (make-var-assignment-for-assigned-var var-name value)))))
                  ((number? value)
                   (connect-compiled-exps
                    (make-int-assignment-for-assigned-var var-name value)))
                  ((string? value)
                   (connect-compiled-exps
                    (make-string-assignment-for-assigned-var var-name value)))
                  (else (let* ((compiled-value (compile value env))
                               (compile-value-code (connect-compiled-exps compiled-value))
                               (value-call (get-names-and-calls compiled-value)))
                          (append
                           compile-value-code
                           (list var-name '= value-call SEMICOLON))))))
           (service-fn-name (generate-name-string (list var-name value)))
           (call-service-fn (append (list service-fn-name) (compile-parenthesis '()))))
      (list (compile-service-fn service-fn-name
                                var-assignment)
            call-service-fn)))
#+END_SRC

#+NAME: compile_global_var
#+BEGIN_SRC scheme :noweb yes
  (define (compile-global-var exp env)
    (let ((return-value (define-variable! (definition-variable exp) env)))
      (if (eq? return-value 'ok)
          (begin
            (format #t "Новая переменная ~%")
          (compile-definition-var (definition-variable exp)
                                         (definition-value exp) env))
          (begin
            (format #t "Переопределение переменной ~%")
            (compile-redefinition-var (definition-variable exp)
                                             (definition-value exp) env)))))
#+END_SRC

Теперь тестим это.

#+NAME: compile_global_var_tests
#+BEGIN_SRC scheme :noweb yes
  ;; определяем новые прееменные
  ;; (если их нет в окружении, в противном случае они будут переопределены)
  (print-code (compile-global-var '(define n 10)  global-environment))

  (print-code (compile-global-var '(define f "\"some string\"")  global-environment))

  (print-code (compile-global-var '(define b n)  global-environment))

  (print-code (compile-global-var '(define c (list 1 2 3))  global-environment))

  (print-code (compile-global-var '(define a f)  global-environment))

  (print-code (compile-global-var '(define g c)  global-environment))

  ;; теперь пробуем переопределить переменные

  (print-code (compile-global-var '(define n "\"some string\"")  global-environment))

  (print-code (compile-global-var '(define b g)  global-environment))

  (print-code (compile-global-var '(define c b)  global-environment))

  (print-code (compile-global-var '(define c f)  global-environment))

  (print-code (compile-global-var '(define f 0)  global-environment))

  (define global-environment (setup-environment))
#+END_SRC

Теперь тестим определения со всей системой.

#+NAME: compile_for_definitions
#+BEGIN_SRC scheme :noweb yes
  (define (compile exp env)
    (cond ((self-evaluating? exp)
           (compile-self-evaluating exp))
          ((variable? exp)
           (compile-variable exp env))
          ((definition? exp)
           (compile-global-var exp env))
           (else (compile-primitive exp env))))
#+END_SRC

#+NAME: compile_for_definitions_tests
#+BEGIN_SRC scheme :noweb yes
  (print-code (compile '(define n "\" string\"") global-environment))

  (print-code (compile '(define n (car (list 1 2 3 4))) global-environment))

  (print-code (compile '(define n (cdr (list 1 2 3 4))) global-environment))
#+END_SRC

~Компиляция функций~

Сначала компилируем тело функций. Тело функции представляет собой
последовательность. Нужно просто скомпилировать выражение одно за другим,
а затем соединить код.

#+NAME: compile_sequences
#+BEGIN_SRC scheme :noweb yes
  (define (compile-sequences sequences env)
    (define (compile-sequences-rec sequences compiled-code)
      ;; (format #t "compile-sequences-rec sequences ~A compiled-code ~A ~%" sequences
      ;;         compiled-code)
      (if (null? sequences)
          compiled-code
          (let ((first-compiled-seq (compile (car sequences) env)))
            (compile-sequences-rec (cdr sequences)
                                   (cons first-compiled-seq compiled-code)))))
    ;; (format #t "sequences ~A env ~A ~%" sequences env)
    (format #t "env ~A ~%" env)
    (let* ((compiled-code-with-names (reverse (compile-sequences-rec sequences '())))
           (compiled-code (connect-compiled-exps compiled-code-with-names))
           (compiled-code-names (get-names-and-calls compiled-code-with-names)))
      (list compiled-code compiled-code-names)))
#+END_SRC


#+NAME: compile_for_sequences
#+BEGIN_SRC scheme :noweb yes
  (define (compile exp env)
    (cond ((self-evaluating? exp)
           (compile-self-evaluating exp))
          ((variable? exp)
           (compile-variable exp env))
          ((definition? exp)
           (compile-global-var exp env))
          ((begin? exp)
           (compile-sequences (begin-actions exp) env))
           (else (compile-primitive exp env))))
#+END_SRC

#+NAME: compile_for_sequences_tests
#+BEGIN_SRC scheme :noweb yes
  (print-code (compile '(begin
                          (define q 10)
                          (define q "\"string\"")
                          (define a q)
                          (define q (list 1 2 3 4))
                          (* (- (+ 1 2) 4) (+ 5 0))) global-environment))
#+END_SRC

Теперь создаем констурктор, который будет компилировать функции.

#+NAME: compile_function
#+BEGIN_SRC scheme :noweb yes
  (define (copy-list list)
    (fold-right cons '() list))

  (define (compile-fn-params-in-c-syntax params)
    (define (compile-fn-params-in-c-syntax-rec params-lisp params-c)
      (if (null? params-lisp)
          params-c
          (let ((cur-param (if (null? (cdr params-lisp))
                               (list 'val ASTERISK (car params-lisp))
                               (list 'val ASTERISK (car params-lisp) COMMA))))
            (compile-fn-params-in-c-syntax-rec (cdr params-lisp)
                                               (append params-c cur-param)))))
    ;; (format #t "params ~A ~%" params)
    (compile-fn-params-in-c-syntax-rec params '()))

  (define (call-all-exps-in-body calls)
    (if (null? calls)
        '()
        (let ((first-call (car calls)))
          (if (and (null? (cdr calls)) (pair? first-call))
              (cons (return-value-constructor first-call)
                    (call-all-exps-in-body (cdr calls)))
              (if (pair? first-call)
                  (cons (append first-call (list SEMICOLON))
                        (call-all-exps-in-body (cdr calls)))
                  (call-all-exps-in-body (cdr calls)))))))


  (define (compile-function fn-name params body env)
    ;; (format #t "compile-function: fn-name ~A params ~A body ~A ~%"
    ;;         fn-name params body)
    (let* ((new-env (extend-environment (copy-list params) (copy-frame env)))
           (compiled-body-with-names (compile-sequences body new-env)))
      (format #t "compile-function: compiled-body-with-names ~A ~%"
              compiled-body-with-names)
      ;; (format #t "compile-function: params1 ~A ~% ~% " params)
      ;; (format #t "global-environment ~A ~%" env)
      (let*(
           (compiled-body (car compiled-body-with-names))
           (names-and-calls (cadr compiled-body-with-names)))
        ;; (format #t "compile-function: params2 ~A ~% ~% "params)
        (let* (
               (return-value (call-all-exps-in-body  names-and-calls))
               (param-in-c-syntax (compile-fn-params-in-c-syntax params)))
          ;; (format #t "compile-function: last-pair ~A ~% ~% "(last-pair names-and-calls))
          ;; (format #t "compile-function: names-and-calls ~A ~% ~% "names-and-calls)
          (append (list 'val ASTERISK fn-name)
                  (compile-parenthesis param-in-c-syntax)
                  (compile-braces
                   (append compiled-body
                           return-value)))))))
#+END_SRC

Создаем констуркторы, которые позволят компилировать именованные функции.
#+NAME: compile_named_function
#+BEGIN_SRC scheme :noweb yes
  (define (named-fn-params exp)
    ;; (format #t "(cdr (cadr exp)) ~A ~%" (cdr (cadr exp)))
    (cdr (cadr exp)))

  (define (named-fn-body exp)
    (cdr (cdr exp)))

  (define (compile-named-function exp env)
    (define-variable! (definition-variable exp) env)
    (list (compile-function (definition-variable exp)
                            (named-fn-params exp) (named-fn-body exp) env)
          (list (definition-variable exp))))
#+END_SRC

#+NAME: compile_for_named_fns
#+BEGIN_SRC scheme :noweb yes
  (define (compile exp env)
    ;; (format #t "exp ~A ~%" exp)
    (cond ((self-evaluating? exp)
           (compile-self-evaluating exp))
          ((variable? exp)
           (compile-variable exp env))
          ((definition? exp)
           (compile-definition exp env))
          ((begin? exp)
           (compile-sequences (begin-actions exp) env))
           (else (compile-primitive exp env))))
#+END_SRC

#+NAME: compile_named_function_tests
#+BEGIN_SRC scheme :noweb yes
  (define global-environment (setup-environment))

  (print-code (compile '(define (test x)
                          (+ x 1)) global-environment))

  (print-code (compile '(define (test x)
                          (define n 10)
                          (+ n x)) global-environment))

  (print-code (compile '(define (test)
                          (define n (list 1 2 3 4))
                          (define f (append n (list 5 6 7 8)))) global-environment))

#+END_SRC

Теперь пишем функционал для ламбды.

На основе этого инструмента очень легко скомпилировать лямбду. Достаточно
только "вытащить" из выражения формальные параметры и тело.
#+NAME: compile_lambda
#+BEGIN_SRC scheme :noweb yes
  (define (compile-lambda exp env)
    (list (compile-function (generate-name-string exp) (lambda-parameters exp)
                            (lambda-body exp) env)
          (list (generate-name-string exp))))
#+END_SRC

Добавляем соответствующую ветку в compile
#+NAME: compile_for_lambda
#+BEGIN_SRC scheme :noweb yes
  (define (compile exp env)
    ;; (format #t "exp ~A ~%" exp)
    (cond ((self-evaluating? exp)
           (compile-self-evaluating exp))
          ((variable? exp)
           (compile-variable exp env))
          ((definition? exp)
           (compile-definition exp env))
          ((lambda? exp)
           (compile-lambda exp env))
          ((begin? exp)
           (compile-sequences (begin-actions exp) env))
           (else (compile-primitive exp env))))
#+END_SRC

#+NAME: compile_lambda_tests
#+BEGIN_SRC scheme :noweb yes
  (print-code (compile '(lambda (x)
                          (+ x 1)) global-environment))

  (print-code (compile '(lambda (x)
                          (define n (* 2 3 4 5))
                          (+ x n)) global-environment))
#+END_SRC

Теперь компилируем вызовы составных процедур.

#+NAME: compile_application
#+BEGIN_SRC scheme :noweb yes
  (define (primitive-proc? exp env)
    ;; (format #t "primitive proc exp ~A ~%" exp)
    (let* ((op (operator exp))
           (value (lookup-variable op env)))
      (if (pair? value)
          (let ((proc-binding (cadr value)))
            (if (eq? 'primitive (car proc-binding))
                true
                false))
          false)))

  (define (lambda-call? exp)
    (and (pair? exp)
         (lambda? (car exp))))

  ;; (lambda-call? '((lambda (x)
  ;;                  (+ x 1)) 2))

  (define (compile-application exp env)
    ;; (format #t "compile-application: exp ~A ~%" exp)
    (cond  ((lambda-call? exp)
            (begin
              ;; (format #t "lambda call ~%")
              (compile-lambda-call exp env)))
           ((primitive-proc? exp env)
            (begin
              ;; (format #t "primitive call ~%")
              (compile-primitive exp env)))
           (else (begin
                   ;; (format #t "compound call ~%")
                   (compile-compound exp env)))))

  (define (compile-compound-proc-call exp env)
    (let* ((compiled-args-with-names (compile-args (operands exp) env))
           (compiled-code (connect-compiled-exps compiled-args-with-names))
           (compiled-code-names (get-names-and-calls compiled-args-with-names))
           (service-fn-name (generate-name-string exp))
           (call-service-fn (append (list service-fn-name) (compile-parenthesis '())))
           (call-params-in-c-syntax (compile-call-params-in-c-syntax compiled-code-names))
           (return-value (return-value-constructor (list (operator exp)
                                                         (compile-parenthesis
                                                          call-params-in-c-syntax)))))
      (format #t "compile-compound-proc-call: compiled-code ~A ~% ~%" compiled-code)

      (list (append (list 'val ASTERISK service-fn-name)
              (compile-parenthesis '())
              (compile-braces (append
                               compiled-code
                               return-value)))
            (list call-service-fn))))

  (define (compile-compound exp env)
    (if (lookup-variable (operator exp) env)
        (compile-compound-proc-call exp env)))

#+END_SRC

Отдельно обрабатываем вызовы лямбд.

Сначала надо скомпилировать саму лямбду, ее аргументы, а потом вызвать ее
с этими аргументами и вернуть результат.

#+NAME: compile_lambda_call
#+BEGIN_SRC scheme :noweb yes
  (define (compile-lambda-call exp env)
    (let* ((lambda-definition (car exp))
           (lambda-call-args (cdr exp))
           (lambda-call-compiled-args (compile-args lambda-call-args env))
           (lambda-call-compiled-code (connect-compiled-exps lambda-call-compiled-args))
           (lambda-call-compiled-names (get-names-and-calls lambda-call-compiled-args))
           (lambda-definition-compiled (compile lambda-definition env))
           (lambda-definition-compiled-code (connect-compiled-exps
                                             lambda-definition-compiled))
           (lambda-definition-compiled-name (get-names-and-calls lambda-definition-compiled))
           (lambda-params-in-c-syntax (compile-call-params-in-c-syntax
                                       lambda-call-compiled-names))
           (lambda-call (return-value-constructor
                         (append lambda-definition-compiled-name
                                 (compile-parenthesis lambda-params-in-c-syntax))))
           (service-fn-name (generate-name-string exp))
           (call-service-fn (append (list service-fn-name) (compile-parenthesis '()))))
      (list (compile-service-fn service-fn-name
                                (append
                                 lambda-call-compiled-code
                                 lambda-definition-compiled-code
                                 lambda-call))
            call-service-fn)))

#+END_SRC

#+NAME: compile_lambda_call_tests
#+BEGIN_SRC scheme :noweb yes
  (print-code (compile '((lambda (x)
                           (+ x 1)) 2) global-environment))


  (print-code (compile '((lambda (x y)
                           (define (test x)
                             (+ x 1))
                           (* x (test x) y))
                            2 3) global-environment))
#+END_SRC

#+NAME: compile_for_application
#+BEGIN_SRC scheme :noweb yes
  (define (compile exp env)
    ;; (format #t "exp ~A ~%" exp)
    (cond ((self-evaluating? exp)
           (compile-self-evaluating exp))
          ((variable? exp)
           (compile-variable exp env))
          ((definition? exp)
           (compile-definition exp env))
          ((lambda? exp)
           (compile-lambda exp env))
          ((begin? exp)
           (compile-sequences (begin-actions exp) env))
           (else (compile-application exp env))))
#+END_SRC

#+NAME: compile_application_tests
#+BEGIN_SRC scheme :noweb yes
  (print-code (compile-sequences
               '((define (test x)
                  (define n 10)
                  (+ n x))
               (test 3)) global-environment))
#+END_SRC

~Компиляция ифа~.
#+NAME: compile_if
#+BEGIN_SRC scheme :noweb yes
  (define (compile-if exp env)
    ;; компилируем код для условия, консеквента и антецедента
    (let* ((condition-code (compile (if-predicate exp) env))
          (consequent-code (compile (if-consequent exp) env))
          (alternative-code (compile (if-alternative exp) env))
          ;; компилируем переменную, в которую бдем записывать результат выполния условия
          (conpidion-result-var (generate-name-string exp))
          (assign-condition-result (list 'val ASTERISK
                                         conpidion-result-var '= (cadr condition-code)
                                         SEMICOLON))
          ;; компилируем возвращаемое значение консеквента и антецедента
          (return_consequent (return-value-constructor
                              (get-names-and-calls consequent-code)))
          (return_alternative (return-value-constructor
                               (get-names-and-calls
                                    alternative-code)))
          ;; компилируем имя и вызов служебной функции, внутри которой
          ;; будет исполняться иф
          (service-fn-name (string-append
                            conpidion-result-var "_if_fn"))
          (call-service-fn (append (list service-fn-name) (compile-parenthesis '()))))
      ;; компилируем служебную функцию
      (list (append  (list 'val ASTERISK service-fn-name)
               (compile-parenthesis '())
               (compile-braces
                ;; соединяем код условия, консеквента и антецедента
                (append (connect-compiled-exps condition-code)
                        (connect-compiled-exps consequent-code)
                        (connect-compiled-exps alternative-code)
                        ;; присоединяем к нему присваивание переменной результата выполнения
                        ;; условия
                        assign-condition-result
                        ;; компиляция проверки условия
                        (list 'if (compile-parenthesis (list 'symbol_predicate
                                                             (compile-parenthesis
                                                              conpidion-result-var)))
                              (compile-braces
                               (list 'if
                                     (compile-parenthesis
                                      (list 'eq_names_predicate
                                            (compile-parenthesis
                                             (list "\"true\"" COMMA
                                                   (string-append
                                                    conpidion-result-var
                                                    "->uni_val.char_val")))))
                                     (compile-braces return_consequent)
                                     'else
                                     (compile-braces return_alternative))))
                        (list 'else 'if
                              (compile-parenthesis
                               (list 'true_predicate
                                     (compile-parenthesis conpidion-result-var)))
                              (compile-braces return_consequent)
                              'else
                              (compile-braces return_alternative)))))
            ;; если не обернуть в список дополнительно, то ничего не заработает
            ;; хорошо бы узнать, почему
            call-service-fn)))

#+END_SRC

#+NAME: compile_for_if
#+BEGIN_SRC scheme :noweb yes
  (define (compile exp env)
    (cond ((self-evaluating? exp)
           (compile-self-evaluating exp))
          ((variable? exp)
           (compile-variable exp env))
          ((definition? exp)
           (compile-definition exp env))
          ((lambda? exp)
           (compile-lambda exp env))
          ((if? exp)
           (compile-if exp env))
          ((begin? exp)
           (compile-sequences (begin-actions exp) env))
           (else (compile-application exp env))))
#+END_SRC

#+NAME: compile_if_tests
#+BEGIN_SRC scheme :noweb yes
  (print-code (compile '(if (+ 1 2)
                            2
                            3) global-environment))

  (print-code (compile '(if (true? 1)
                            2
                            3) global-environment))

  (print-code (compile '(if (= 1 2)
                            4
                            (list 1 2 3 4) global-environment)))
  (print-code  (compile
                '(define (factorial n)
                   (if (= n 0)
                       1
                       (* n (factorial (- n 1)))))
                global-environment))

  (print-code (compile '(define (my_reverse lst)
                          (define (my_reverse_rec lst new_lst)
                            (if (null? lst)
                                new_lst
                                (my_reverse_rec (cdr lst) (cons (car lst) new_lst))))
                          (my_reverse_rec lst (list))) global-environment))

  (print-code (compile '(my_reverse (list 1 2 3 4))
                       global-environment))

#+END_SRC

~Присваивания~

Необходимый функционал для присваиний у нас уже есть. Мы его создали для
переопределений.
#+NAME: assignments
#+BEGIN_SRC scheme :noweb yes
  (define (compile-assignment exp env)
    (if (lookup-variable (assignment-variable exp) env)
        (compile-redefinition-var (assignment-variable exp)
                                  (assignment-value exp) env)))
#+END_SRC

Добавляем ветку вычисления в compile
#+NAME: compile_for_assignments
#+BEGIN_SRC scheme :noweb yes
  (define (compile exp env)
    (format #t "compile exp ~A ~%" exp)
    (cond ((self-evaluating? exp)
           (compile-self-evaluating exp))
          ((variable? exp)
           (compile-variable exp env))
          ((definition? exp)
           (compile-definition exp env))
          ((lambda? exp)
           (compile-lambda exp env))
          ((if? exp)
           (compile-if exp env))
          ((begin? exp)
           (compile-sequences (begin-actions exp) env))
          ((assignment? exp)
           (compile-assignment exp env))
          (else (compile-application exp env))))
#+END_SRC

#+NAME: compile_for_assignments_tests
#+BEGIN_SRC scheme :noweb yes
  (print-code (compile-sequences '((define n 10)
                                   (set! n "\"string\"")) global-environment))
#+END_SRC

~компиляция заковыченных выражений~

Заковыченные выражения бывают следующих видов:
- список
- число
- строка
- символ

Технически, мы можем заковычить что угодно, в том числе и саму
кавычку. Но представленные выше типы - основные.
Следовательно, нам нужно проверить, что за выражение мы заковычиваем.
Если символ, число или строку - то просто вызываем соответствующие
конструкторы и компилируем их. Если же заковычивается список, то нужно
скомпилировать каждый его элемент.

#+NAME: compile_quoted_exp
#+BEGIN_SRC scheme :noweb yes
  (define (compile-quoted-exp exp)
    (let* ((compiled-exp (compile-cur-quoted-exp exp))
           (compiled-exp-names (get-names-and-calls compiled-exp))
           (compiled-exp-code (connect-compiled-exps compiled-exp))
           (service-fn-name (generate-name-string exp))
           (call-service-fn (append (list service-fn-name) (compile-parenthesis '())))
           (return-value (if (pair? exp)
                             (return-value-constructor
                              (compile-list compiled-exp-names))
                             (return-value-constructor
                              compiled-exp-names))))
      (list
       (compile-service-fn service-fn-name
                           (append
                            compiled-exp-code
                            return-value))
       call-service-fn)))

  (define (compile-cur-quoted-exp exp)
    (format #t "compile-quoted-exp exp ~A ~%" exp)
    (cond ((number? exp)
           (compile-int-val-constructor (generate-name-string exp)
                                        exp))
          ((string? exp)
           (compile-string-val-constructor (generate-name-string exp)
                                           exp))
          ((pair? exp)
           (compile-quoted-list exp))
          (else  (compile-symbol-val-constructor (generate-name-string exp)
                                                 (symbol->string exp)))))

  (define (compile-quoted-list exp)
    (define (compile-quoted-list-rec exp compiled-code)
      (if (null? exp)
          (begin
            (format #t "exit ~A ~%" compiled-code)
          compiled-code)
          (let ((first-elt (compile-cur-quoted-exp (car exp))))
            (compile-quoted-list-rec (cdr exp) (append compiled-code (list
                                                                      first-elt))))))
    (compile-quoted-list-rec (cdr exp) (list (compile-cur-quoted-exp (car exp)))))
#+END_SRC

#+NAME: final_compile
#+BEGIN_SRC scheme :noweb yes
  (define (compile exp env)
    (cond ((quoted? exp)
           (compile-quoted-exp (text-of-quotation exp)))
          ((self-evaluating? exp)
           (compile-self-evaluating exp))
          ((variable? exp)
           (compile-variable exp env))
          ((definition? exp)
           (compile-definition exp env))
          ((lambda? exp)
           (compile-lambda exp env))
          ((if? exp)
           (compile-if exp env))
          ((begin? exp)
           (compile-sequences (begin-actions exp) env))
          ((assignment? exp)
           (compile-assignment exp env))
          (else (compile-application exp env))))
#+END_SRC

#+NAME: compile_for_quotation_tests
#+BEGIN_SRC scheme :noweb yes
  (print-code (compile ''(1 2 3 4) global-environment))

  (print-code (compile ''d global-environment))

  (print-code (compile ''"string" global-environment))

  (print-code (compile ''1 global-environment))

#+END_SRC

#+NAME: code
#+BEGIN_SRC forth :tangle code.scheme :noweb tangle :exports code :padline no :comments none
  <<syntax_procs>>
  <<syntax_symbols>>
  <<syntax_constructors>>
  <<main>>
  <<list_string>>
  <<generate_name>>
  <<generate_ptr_and_val_names>>
  <<service_procedure>>
  <<transform_exp>>
  <<compiled_code_to_string>>
  <<print_code_into_file>>
  <<print_code>>
  <<primitives_proc>>
  <<environment>>
  <<copy_environment>>
  <<allocate_memory_constructors>>
  <<nums_strings_symbols_constructors>>
  <<compile_call_params_in_c_syntax>>
  <<compile_primitives_constructors>>
  <<connect_compiled_code>>
  <<get_names_and_calls>>
  <<return_value_constructor>>
  <<compile_args>>
  <<compile_self_evaluating>>
  <<compile_variable>>
  <<compile_primitives>>
  <<define_definition>>
  <<compile_definition_var>>
  <<compile_unassigned_variable>>
  <<make_unassigned-var_assingments>>
  <<make_assingments>>
  <<define_global_var>>
  <<compile_global_var>>
  <<compile_sequences>>
  <<compile_function>>
  <<compile_named_function>>
  <<compile_for_definitions>>
  <<compile_lambda>>
  <<compile_application>>
  <<compile_lambda_call>>
  <<compile_if>>
  <<assignments>>
  <<compile_for_assignments>>
  <<compile_quoted_exp>>
  <<final_compile>>
#+END_SRC
