
#+STARTUP: showall indent hidestars


Все(?) процедуры, указанные в мане для построения метациклического
интерпретатора

~метациклический интерпретатор~

#+BEGIN_SRC scheme
  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((if? exp) (eval-if exp env))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((application? exp)
           (apply (eval (operator exp) env)
                  (list-of-values (operands exp) env)))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))

  (define apply-in-underlying-scheme apply)

  ;; (define (apply procedure arguments)
  ;;   (cond ((primitive-procedure? procedure)
  ;;          (apply-primitive-procedure procedure arguments))
  ;;         ((compound-procedure? procedure)
  ;;          (eval-sequence
  ;;           (procedure-body procedure)
  ;;           (extend-environment
  ;;            (procedure-parameters procedure)
  ;;            arguments
  ;;            (procedure-environment procedure))))
  ;;         (else
  ;;          (error
  ;;           "Неизвестный тип процедуры -- APPLY" procedure))))

  (define (list-of-values exps env)
    (if (no-operands? exps)
        '()
         (cons (eval (first-operand exps) env)
               (list-of-values (rest-operands exps) env))))

  (define (eval-if exp env)
    (if (true? (eval (if-predicate exp) env))
        (eval (if-consequent exp) env)
        (eval (if-alternative exp) env)))

  (define (eval-sequence exps env)
    (cond ((last-exp? exps) (eval (first-exp exps) env))
          (else (eval (first-exp exps) env)
                (eval-sequence (rest-exps exps) env))))

  (define (eval-assignment exp env)
    (set-variable-value! (assignment-variable exp)
                         (eval (assignment-value exp) env)
                         env)
    'ok)

  (define (eval-definition exp env)
    (define-variable! (definition-variable exp)
      (eval (definition-value exp) env)
      env)
    'ok)

  (define (self-evaluating? exp)
    (cond ((number? exp) true)
          ((string? exp) true)
          (else false)))

  (define (variable? exp) (symbol? exp))

  (define (quoted? exp)
    (tagged-list? exp 'quote))

  (define (text-of-quotation exp) (cadr exp))

  (define (tagged-list? exp tag)
    (if (pair? exp)
        (eq? (car exp) tag)
        false))

  (define (assignment? exp)
    (tagged-list? exp 'set!))

  (define (assignment-variable exp) (cadr exp))

  (define (assignment-value exp) (caddr exp))

  (define (definition? exp)
    (tagged-list? exp 'define))

  (define (definition-variable exp)
    (if (symbol? (cadr exp))
        (cadr exp)
        (caadr exp)))

  (define (definition-value exp)
    (if (symbol? (cadr exp))
        (caddr exp)
        (make-lambda (cdadr exp)
                     (cddr exp))))

  (define (lambda? exp) (tagged-list? exp 'lambda))

  (define (lambda-parameters exp) (cadr exp))

  (define (lambda-body exp) (cddr exp))

  (define (make-lambda parameters body)
    (cons 'lambda (cons parameters body)))

  (define (if? exp) (tagged-list? exp 'if))

  (define (if-predicate exp) (cadr exp))

  (define (if-consequent exp) (caddr exp))

  (define (if-alternative exp)
    (if (not (null? (cdddr exp)))
        (cadddr exp)
        'false))

  (define (make-if predicate consequent alternative)
    (list 'if predicate consequent alternative))

  (define (begin? exp) (tagged-list? exp 'begin))

  (define (begin-actions exp) (cdr exp))

  (define (last-exp? seq) (null? (cdr seq)))

  (define (first-exp seq) (car seq))

  (define (rest-exps seq) (cdr seq))

  (define (sequence->exp seq)
    (cond ((null? seq) seq)
          ((last-exp? seq) (first-exp seq))
          (else (make-begin seq))))

  (define (make-begin seq) (cons 'begin seq))

  (define (application? exp) (pair? exp))

  (define (operator exp) (car exp))

  (define (operands exp) (cdr exp))

  (define (no-operands? ops) (null? ops))

  (define (first-operand ops) (car ops))

  (define (rest-operands ops) (cdr ops))

  (define (cond? exp) (tagged-list? exp 'cond))

  (define (cond-clauses exp) (cdr exp))

  (define (cond-else-clause? clause)
    (eq? (cond-predicate clause) 'else))

  (define (cond-predicate clause) (car clause))

  (define (cond-actions clause) (cdr clause))

  (define (cond->if exp)
    (expand-clauses (cond-clauses exp)))

  (define (expand-clauses clauses)
    (if (null? clauses)
        'false
                                          ; нет ветви else
         (let ((first (car clauses))
               (rest (cdr clauses)))
           (if (cond-else-clause? first)
               (if (null? rest)
                   (sequence->exp (cond-actions first))
                   (error "Ветвь ELSE не последняя -- COND->IF"
                          clauses))
               (make-if (cond-predicate first)
                        (sequence->exp (cond-actions first))
                        (expand-clauses rest))))))

  (define (true? x)
    (not (eq? x false)))

  (define (false? x)
    (eq? x false))

  (define (make-procedure parameters body env)
  (list 'procedure parameters body env))

  (define (compound-procedure? p)
    (tagged-list? p 'procedure))

  (define (procedure-parameters p) (cadr p))

  (define (procedure-body p) (caddr p))

  (define (procedure-environment p) (cadddr p))

  (define (enclosing-environment env) (cdr env))

  (define (first-frame env) (car env))

  (define the-empty-environment '())

  (define (make-frame variables values)
    (cons variables values))

  (define (frame-variables frame) (car frame))

  (define (frame-values frame) (cdr frame))

  (define (add-binding-to-frame! var val frame)
    (set-car! frame (cons var (car frame)))
    (set-cdr! frame (cons val (cdr frame))))

  (define (extend-environment vars vals base-env)
    (if (= (length vars) (length vals))
        (cons (make-frame vars vals) base-env)
        (if (< (length vars) (length vals))
            (error "Получено слишком много аргументов" vars vals)
            (error "Получено слишком мало аргументов" vars vals))))

  (define (lookup-variable-value var env)
    (define (env-loop env)
      (define (scan vars vals)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((eq? var (car vars))
               (car vals))
              (else (scan (cdr vars) (cdr vals)))))
      (if (eq? env the-empty-environment)
          (error "Несвязанная переменная" var)
          (let ((frame (first-frame env)))
            (scan (frame-variables frame)
                  (frame-values frame)))))
    (env-loop env))

  (define (set-variable-value! var val env)
    (define (env-loop env)
      (define (scan vars vals)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((eq? var (car vars))
               (set-car! vals val))
              (else (scan (cdr vars) (cdr vals)))))
      (if (eq? env the-empty-environment)
          (error "Несвязанная переменная -- SET!" var)
          (let ((frame (first-frame env)))
            (scan (frame-variables frame)
                  (frame-values frame)))))
    (env-loop env))

  (define (define-variable! var val env)
    (let ((frame (first-frame env)))
      (define (scan vars vals)
        (cond ((null? vars)
               (add-binding-to-frame! var val frame))
              ((eq? var (car vars))
               (set-car! vals val))
              (else (scan (cdr vars) (cdr vals)))))
      (scan (frame-variables frame)
            (frame-values frame))))

  (define (setup-environment)
    (let ((initial-env
           (extend-environment (primitive-procedure-names)
                               (primitive-procedure-objects)
                               the-empty-environment)))
      (define-variable! 'true true initial-env)
      (define-variable! 'false false initial-env)
      initial-env))

  (define (primitive-procedure? proc)
    (tagged-list? proc 'primitive))

  (define (primitive-implementation proc) (cadr proc))

  (define primitive-procedures
    (list (list 'car car)
          (list 'cdr cdr)
          (list 'cadr cadr)
          (list 'cdar cdar)
          (list 'cddr cddr)
          (list 'caddr caddr)
          (list 'first first)
          (list 'second second)
          (list 'third third)
          (list 'fourth fourth)
          (list 'cons cons)
          (list 'null? null?)
          (list 'list list)
          (list 'assoc assoc)
          (list 'append append)
          (list 'not not)
          (list 'eq? eq?)
          (list 'equal? equal?)
          (list 'xor xor)
          (list 'memq memq)
          (list 'newline newline)
          (list 'last-pair last-pair)
          (list '< <)
          (list '> >)
          (list '= =)
          (list '/ /)
          (list '* *)
          (list '+ +)
          (list '- -)
          (list 'display display)
          (list 'member member)
          (list 'even? even?)
          (list 'remainder remainder)
          ))

  (define (primitive-procedure-names)
    (map car
         primitive-procedures))

  (define (primitive-procedure-objects)
    (map (lambda (proc) (list 'primitive (cadr proc)))
         primitive-procedures))

  (define (apply-primitive-procedure proc args)
    (apply-in-underlying-scheme
     (primitive-implementation proc) args))

  (define input-prompt ";;; Ввод M-Eval:")
  (define output-prompt ";;; Значение M-Eval:")

  (define (driver-loop)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (let ((output (eval input the-global-environment)))
        (announce-output output-prompt)
        (user-print output)))
    (driver-loop))

  (define (prompt-for-input string)
    (newline) (newline) (display string) (newline))

  (define (announce-output string)
    (newline) (display string) (newline))

  (define (user-print object)
    (if (compound-procedure? object)
        (display (list 'compound-procedure
                        (procedure-parameters object)
                        (procedure-body object)
                        '<procedure-env>))
        (display object)))

  (define the-global-environment (setup-environment))
#+END_SRC


~Отделение анализа от исполнения~
#+BEGIN_SRC scheme
  (define (eval exp env)
    ((analyze exp) env))

  (define (analyze exp)
    (cond ((self-evaluating? exp)
           (analyze-self-evaluating exp))
          ((quoted? exp) (analyze-quoted exp))
          ((variable? exp) (analyze-variable exp))
          ((assignment? exp) (analyze-assignment exp))
          ((definition? exp) (analyze-definition exp))
          ((if? exp) (analyze-if exp))
          ((lambda? exp) (analyze-lambda exp))
          ((begin? exp) (analyze-sequence (begin-actions exp)))
          ((cond? exp) (analyze (cond->if exp)))
          ((application? exp) (analyze-application exp))
          (else
           (error "Неизвестный тип выражения -- ANALYZE" exp))))

  (define (analyze-self-evaluating exp)
    (lambda (env) exp))

  (define (analyze-quoted exp)
    (let ((qval (text-of-quotation exp)))
      (lambda (env) qval)))

  (define (analyze-variable exp)
    (lambda (env) (lookup-variable-value exp env)))

  (define (analyze-assignment exp)
    (let ((var (assignment-variable exp))
          (vproc (analyze (assignment-value exp))))
      (lambda (env)
        (set-variable-value! var (vproc env) env)
        'ok)))

  (define (analyze-definition exp)
    (let ((var (definition-variable exp))
          (vproc (analyze (definition-value exp))))
      (lambda (env)
        (define-variable! var (vproc env) env)
        'ok)))

  (define (analyze-if exp)
    (let ((pproc (analyze (if-predicate exp)))
          (cproc (analyze (if-consequent exp)))
          (aproc (analyze (if-alternative exp))))
      (lambda (env)
        (if (true? (pproc env))
            (cproc env)
            (aproc env)))))

  (define (analyze-lambda exp)
    (let ((vars (lambda-parameters exp))
          (bproc (analyze-sequence (lambda-body exp))))
      (lambda (env) (make-procedure vars bproc env))))

  (define (analyze-sequence exps)
    (define (sequentially proc1 proc2)
      (lambda (env) (proc1 env) (proc2 env)))
    (define (loop first-proc rest-procs)
      (if (null? rest-procs)
          first-proc
          (loop (sequentially first-proc (car rest-procs))
                (cdr rest-procs))))
    (let ((procs (map analyze exps)))
      (if (null? procs)
          (error "Пустая последовательность -- ANALYZE"))
      (loop (car procs) (cdr procs))))

  (define (analyze-application exp)
    (let ((fproc (analyze (operator exp)))
          (aprocs (map analyze (operands exp))))
      (lambda (env)
        (execute-application (fproc env)
                             (map (lambda (aproc) (aproc env))
                                  aprocs)))))
  (define (execute-application proc args)
    (cond ((primitive-procedure? proc)
           (apply-primitive-procedure proc args))
          ((compound-procedure? proc)
           ((procedure-body proc)
            (extend-environment (procedure-parameters proc)
                                args
                                (procedure-environment proc))))
          (else
           (error
            "Неизвестный тип процедуры -- EXECUTE-APPLICATION"
            proc))))
#+END_SRC

~ленивый интерпретатор~

Залей все для метациклического оператора (можно без кода для анализа
выражений до исполнения)

Можно, теоретически, проверить этим упражнения на ленивый интерпретатор:

И потом залей это:
Дополнения:
#+BEGIN_SRC scheme
  (define (actual-value exp env)
    (force-it (eval exp env)))

  (define (eval exp env)
    ;; самовычисляющееся? - вычислить сразу
    (cond ((self-evaluating? exp) exp)
          ;; переменная? - запусть ее поиск в окружении
          ((variable? exp) (lookup-variable-value exp env))
          ;; построение списока? - вернуть список или заковыченное выражение
          ((quoted? exp) (text-of-quotation exp))
          ;; присваивание? - запустить процесс присваивания
          ((assignment? exp) (eval-assignment exp env))
          ;; определение? - запустить процесс определения
          ((definition? exp) (eval-definition exp env))
          ;; особая форма if? - вычислить if
          ((if? exp) (eval-if exp env))
          ;; особая формя lambda? - создать процедуру
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ;; форма begin? - создать блок begin
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ;; cond? - превратить его в вложенные ифы
          ((cond? exp) (eval (cond->if exp) env))
          ;;вызов процедуры? - запустить вычисление процедуры
          ((application? exp)
           (apply (actual-value (operator exp) env)
                  (operands exp)
                  env))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))

  (define (apply procedure arguments env)
    (cond ((primitive-procedure? procedure)
           (apply-primitive-procedure
            procedure
            (list-of-arg-values arguments env))) ; изменение
          ((compound-procedure? procedure)
           (eval-sequence
            (procedure-body procedure)
            (extend-environment
             (procedure-parameters procedure)
             (list-of-delayed-args arguments env) ; изменение
             (procedure-environment procedure))))
          (else
           (error
            "Неизвестный тип процедуры -- APPLY" procedure))))

  (define (list-of-arg-values exps env)
    (if (no-operands? exps)
        '()
         (cons (actual-value (first-operand exps) env)
               (list-of-arg-values (rest-operands exps)
                                   env))))
  (define (list-of-delayed-args exps env)
    (if (no-operands? exps)
        '()
         (cons (delay-it (first-operand exps) env)
               (list-of-delayed-args (rest-operands exps)
                                     env))))
  (define (eval-if exp env)
    (if (true? (actual-value (if-predicate exp) env))
        (eval (if-consequent exp) env)
        (eval (if-alternative exp) env)))

  (define input-prompt ";;; Ввод L-Eval:")
  (define output-prompt ";;; Значение L-Eval:")

  (define (driver-loop)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (let ((output
             (actual-value input the-global-environment)))
        (announce-output output-prompt)
        (user-print output)))
    (driver-loop))

  (define the-global-environment (setup-environment))

  (define (delay-it exp env)
    (list 'thunk exp env))

  (define (thunk? obj)
    (tagged-list? obj 'thunk))

  (define (thunk-exp thunk) (cadr thunk))

  (define (thunk-env thunk) (caddr thunk))

  (define (evaluated-thunk? obj)
    (tagged-list? obj 'evaluated-thunk))

  (define (thunk-value evaluated-thunk) (cadr evaluated-thunk))

  (define (force-it obj)
    (cond ((thunk? obj)
           (let ((result (actual-value
                          (thunk-exp obj)
                          (thunk-env obj))))
             (set-car! obj 'evaluated-thunk)
             (set-car! (cdr obj) result)
                                          ; заменить exp на его значение
             (set-cdr! (cdr obj) '()) ; забыть ненужное env
             result))
          ((evaluated-thunk? obj)
           (thunk-value obj))
          (else obj)))

#+END_SRC


~Упражнение 4.1.~
Заметим, что мы не можем сказать, вычисляет ли метациклический
интерпретатор операнды слева направо или справа налево. Порядок
вычисления наследуется от нижележащего Лиспа: если аргументы ~cons~ в
процедуре ~list-of-values~ вычисляются слева направо, то и
операнды в ~list-of-values~ будут вычисляться слева направо. Если же вычисление
аргументов ~cons~ происходит справа налево, то и ~list-of-values~ будет
вычислять операнды справа налево.
Напишите версию ~list-of-values~, которая вычисляет операнды слева направо,
вне зависимости от порядка вычислений в нижележащем Лиспе. Напишите также версию,
которая вычисляет операнды справа налево.

Определение исходной версии ~list-of-values~

#+BEGIN_SRC scheme
  ;; принимает на вход список выражений и окружение
  ;; на выходе получим список рехультатов выражений
  (define (list-of-values exps env)
    (if (no-operands? exps)
        '()
         (cons (eval (first-operand exps) env)
               (list-of-values (rest-operands exps) env))))
#+END_SRC

Было похожее ~упражнение 3.8~, в котором требовалось именить порядок
вычисления.
В этом нам помог ~set!~, поскольку порядок вычисления формы ~set!~ всегда
будет один и тот же: сначала вычисляем выражение, результ которого
запишем в переменную, и только затем присвоим результат переменной.

Исходя из формулировки упражнения ясно, что ~cons~ использовать нельзя,
поскольку порядок вычислений может меняться. Значит нам надо соединить
результаты вычисления в список вручную, используя присваивание.

#+BEGIN_SRC scheme
  ;;вычисляет аргументы слева направо
  (define (my-list-of-values exps env)
    (define (iter exps env results)
    (if (no-operands? exps)
        results
        (let ((first-exp-result (list (eval (first-operand exps) env))))
          (if (null? results)
              (begin
                (set! results (list first-exp-result))
                (iter (rest-operands exps) env results))
              (begin
                (set-cdr! (last-pair results) (list first-exp-result))
                (iter (rest-operands exps) env results))))))
    (iter exps env '()))

  ;; поскольку my-list-of-values, определенную выше, протестить пока невозможно,
  ;; пишем аналогичную функцию и тестим ее
  (define (test list-args)
    (define (iter list-args results)
      (if (null? list-args)
          results
          (let ((first-elt (list (car list-args))))
            (if (null? results)
                (begin
                  (set! results (list first-elt))
                  (iter (cdr list-args) results))
                (begin
                  (set-cdr! (last-pair results) (list first-elt))
                  (iter (cdr list-args) results))))))
    (iter list-args '()))

  (test '(1 2 3 4))

  ;;вычисляет аргументы справа налево
  ;; выглядит как грязный хак, но работает
  (define (my-list-of-values exps env)
      (if (no-operands? exps)
          '()
          (let ((first-exp-result (eval (first-operand exps) env))
                (rest-args (my-list-of-values (rest-operands exps) env)))
            (cons first-exp-result rest-args))))

  ;; пишем аналогичную тестовую функцию
  (define (test list-args)
    (if (null? list-args)
        '()
        (let ((first (list (car list-args)))
              (rest (test (cdr list-args))))
          (cons first rest))))

  (test '(1 2 3 4))
#+END_SRC

~Упражнение 4.2.~
Хьюго Дум хочет переупорядочить ветви ~eval~ так, чтобы ветвь для вызова
процедур располагалась перед веткой для присваивания. Он утверждает, что при этом
интерпретатор станет эффективнее: поскольку в программах обычно больше
вызовов процедур, чем присваиваний, определений и т. д., его
усовершенствованный eval обычно будет рассматривать меньше вариантов,
чем исходный, при распознавании типа выражения.

а. Что за ошибка содержится в плане Хьюго? (Подсказка: что сделает его
интерпретатор с выражением (define x 3)?)

б. Хьюго расстроен, что его план не сработал. Он готов пойти на любые
жертвы, чтобы позволить интерпретатору распознавать вызовы процедур до того, как он
проверяет все остальные типы выражений.
Помогите ему, изменив синтаксис интерпретируемого языка
так, чтобы вызовы процедур начинались с символа call.
Например, вместо (factorial 3) нам теперь придется
писать (call factorial 3), а вместо (+ 1 2) — (call + 1 2).

Ответ а:
Хьюго в первом задании предлагает ветку исполнения процедур поместить в
начале, поскольку вызовы процедур встречаются чаще, значит, не придется
проверять все ветки каждый раз.

Но возникает проблема с определениями процедур типа (define x 3)
Срабатывает предикат ~defenition?~, поскольку выражение начинается с
~define~, затем вызывается данная процедура:

#+BEGIN_SRC scheme
  (define (eval-definition exp env)
    (define-variable! (definition-variable exp)
      (eval (definition-value exp) env)
      env)
    'ok)
#+END_SRC

Получаем имя переменной, затем вычисляем значение выражения в данном
окружении и присваиваем значение имени. Проблема в том, что define - это
синтаксический сахар для лямбды, которая в нем содержится. Это значит,
что (define x 3) может быть воспринят как вызов процедуры, в результате
таг define будет воспринят как оператор, который следует применить к
аргументм x и 3. В результате нас ждут ошибки.

Ответ б:
Чтоб избежать проблемы, описанной выше, нам теперь перед каждым вызовом
процедуры нужно будет писать, что это именно вызов, т.е. ~call~ или любой
другой зарезервированный для этого символ, что довольно неудобно.
И тогда редикат application? следует переписать таким образом, чтоб
первым делом он проверял наличие соответствующего тага у выражения.
Например, так:

#+BEGIN_SRC scheme
  (define (application? exp)
    (tagged-list? exp 'call))
#+END_SRC

~Упражнение 4.3.~
Перепишите ~eval~ так, чтобы диспетчеризация происходила в стиле,
управляемом данными. Сравните результат с дифференцированием, управляемым
данными, из упражнения 2.73. (Можно использовать car составного выражения
в качестве типа этого выражения, так как это хорошо
сочетается с синтаксисом, реализованным в этом разделе.)

Итак, раз нас просят использовать стиль, управляемый данными, значит, нам
нужно представить, что у нас есть таблица типов, как в колнце второй
главы и использовать ее. Предположим, что все операции уже помещены в
таблицу и теперь нам только достать их с gjvjom. ~apply-generic~, которая
самостоятельно найдет операцию в таблице для типов данных аргументов и
применит ее, если операция существует.

Некоторые процедуры будут вызываться самостоятельно, без ~apply-generic~,
поскольку сущесвуют в единственном виде для всех типов, остальные
выражения будут обрабатываться с помощью ~apply-generic~. Здесь есть
важное дополнение: чтоб данный способ сработал, вызов процедур должен
иметь вид (call вызов_нужной_процедуры), поскольку в исходном варианте
~eval~ вызовом процедуры считается любое выражение, которое является
списком и не подошло ни под одно предыдущее условие ~cond~

Сравнение с упражнением 2.73 выглядело бы более корректным, если бы я
использовала ~get~ вместо ~apply-generic~. Так что я напишу второй
вариант как в упражнении 2.73. В этом сучае так же придется изменить
представление вызова процедур.

Данное представление ~eval~, как и представление ~deriv~ делает программу
более гибкой, поскольку в случае добавления типов выражений, которые мы
хотим вычислить, нам не придется менять саму ~eval~, мы просто добавим
дополнительную процедуру в таблицу.

#+BEGIN_SRC scheme
  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          (else
           (apply-generic 'eval exp env))))

  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          (else
           ((get 'eval (car exp)) (cdr exp) env))))

#+END_SRC

~Упражнение 4.4.~
Вспомним определения особых форм and и or из главы 1:

- and: выражения вычисляются слева направо. Если значение какого-то из
  них оказывается ложным, возвращается ложь; оставшиеся выражения не
  вычисляются. Если все выражения оказываются истинными, возвращается
  значение последнего из них. Если нет ни одного выражения, возвращается истина.
- or: выражения вычисляются слева направо. Если значение какого-то из
  них оказывается истинным, возвращается это значение; оставшиеся
  выражения не вычисляются. Если все выражения оказываются ложными,
  или нет ни одного выражения, возвращается ложь.

Введите and и or в качестве новых особых форм интерпретатора, определив
соответствующие синтаксические процедуры и процедуры выполнения eval-and и eval-or. В
качестве альтернативы покажите, как можно реализовать and и or в виде
производных выражений.

Вариант а:
#+BEGIN_SRC scheme
  (define (or? exp)
    (tagged-list? exp 'or))

  (define (and? exp)
    (tagged-list? exp 'and))

  (define (eval-and exp env)
    (define (eval-and-iter exps env)
      (display exps)
      (newline)
      (cond ((null? exps) #t)
            ((null? (rest-exps exps)) (eval (first-exp exps) env))
            ((eval (first-exp exps) env) (eval-and-iter (rest-exps exps) env))
            (else #f)))
    (eval-and-iter (cdr exp) env))

  (define (eval-or exp env)
    (define (eval-or-iter exps env)
    (if (null? exps)
        #f
        (let ((some-result (eval (first-exp exps) env)))
          (if some-result
              some-result
              (eval-or (rest-exps exps) env)))))
    (display "eval-or")
    (newline)
    (display exp)
    (newline)
    (eval-or-iter (cdr exp) env))
#+END_SRC

Вставляем необходиые ветки в eval  и задливаем все в интерпретатор для проверки.
#+BEGIN_SRC scheme
  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((if? exp) (eval-if exp env))
          ((or? exp) (eval-or exp env))
          ((and? exp) (eval-and exp env))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((application? exp)
           (apply (eval (operator exp) env)
                  (list-of-values (operands exp) env)))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))
#+END_SRC

Вариант с производными выражениями:

#+BEGIN_SRC scheme
  (define (expand-and exp)
    (define (expand-and-iter exps)
      (if (null? exp)
          #t
          (let ((first (first-exp exps))
                (rest (rest-exps exps)))
            (if (null? rest)
                (sequence->exp (list first))
                (make-if first
                         (expand-and-iter (rest-exps exps))
                         #f)))))
    (expand-and-iter (cdr exp)))

  (define (expand-or exp)
    (define (expand-or-iter exps)
    (if (null? exps)
        #f
        (let ((first (first-exp exps))
              (rest (rest-exps exps)))
          (make-if first
                   (sequence->exp (list first))
                   (expand-or-iter (rest-exps exps))))))
    (expand-or-iter (cdr exp)))
#+END_SRC

Вставляем процедуры в eval и заливаем в интерпретатор
#+BEGIN_SRC scheme
  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((if? exp) (eval-if exp env))
          ((or? exp) (expand-or exp))
          ((and? exp) (expand-and exp))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((application? exp)
           (apply (eval (operator exp) env)
                  (list-of-values (operands exp) env)))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))
#+END_SRC

~Упражнение 4.5.~
В языке Scheme есть дополнительная разновидность синтаксиса вариантов
cond, (проверка) => (потребитель). Если результат вычисления <проверки> оказывается
истинным значением, то вычисляется <потребитель>. Его значение должно быть
одноместной процедурой; эта процедура вызывается со значением <проверки>
в качестве аргумента, и результат этого вызова возвращается как значение
выражения cond. Измените обработку cond так, чтобы она поддерживала этот
расширенный синтаксис.

У меня получилось только полностью его заменить..
#+BEGIN_SRC scheme
  (define (=>? exp)
    (tagged-list? exp '=>))

  (define (expand-clauses clauses)
    (if (null? clauses)
        'false
        (let ((first (car clauses))
              (rest (cdr clauses)))
          (if (cond-else-clause? first)
              (if (null? rest)
                  (sequence->exp (cond-actions first))
                  (error "Ветвь ELSE не последняя -- COND->IF"
                         clauses))
              (begin
                (display (sequence->exp
                          (list (append (cond-actions (cdr first))
                                        (list (cond-predicate first))))))
              ;; если первый символ из списка действий в текущем выражении =>
              ;; и при этом предикат истинен
              (make-if (and (=>? (cond-actions first)) (cond-predicate first))
                       ;; создаем выражение, в котором передаем действию из выражения
                       ;; значение предиката
                       (sequence->exp
                        (list (append (cond-actions (cdr first))
                                      (list (cond-predicate first)))))

                       ;; иначе создаем стандартный иф для cond
                       (make-if (cond-predicate first)
                                  (sequence->exp (cond-actions first))
                                  (expand-clauses rest))))))))

  (cond ((assoc 'v '((a 1) (b 2))) => cadr)
        ((assoc 'b '((a 3) (b 4))) => cadr)
        (else false))

#+END_SRC

~Упражнение 4.6.~
Выражения let производны, поскольку раскрываются в лямбду.
Напишите синтаксическое преобразование ~let->combination~, которое сводит
вычисление let-выражений к вычислению комбинаций указанного вида, и добавьте
соответствующую ветку для обработки let к eval.

#+BEGIN_SRC scheme
  (define (make-lambda parameters body)
    (cons 'lambda (cons parameters body)))

  (define (let? exp)
    (tagged-list? exp 'let))

  (define (let->combination exp)
    (define (get-all-params exp)
      (if (null? exp)
          '()
          (cons (caar exp) (get-all-params (cdr exp)))))
    (define (get-all-exps exp)
      (if (null? exp)
          '()
          (cons (cadar exp) (get-all-exps (cdr exp)))))
    (append (list (make-lambda (get-all-params (cadr exp))
                               (cddr exp)))
            (get-all-exps (cadr exp))))

;; тест
  (let ((a 3)
        (b 4))
    (let ((v 5)
          (g 7))
    (+ a b g v)))

#+END_SRC

Добавляем ветку в ~eval~

#+BEGIN_SRC scheme
  (define (eval exp env)
      (cond ((self-evaluating? exp) exp)
            ((variable? exp) (lookup-variable-value exp env))
            ((quoted? exp) (text-of-quotation exp))
            ((assignment? exp) (eval-assignment exp env))
            ((definition? exp) (eval-definition exp env))
            ((if? exp) (eval-if exp env))
            ((lambda? exp)
             (make-procedure (lambda-parameters exp)
                             (lambda-body exp)
                             env))
            ((begin? exp)
             (eval-sequence (begin-actions exp) env))
            ((cond? exp) (eval (cond->if exp) env))
            ((let? exp) (eval (let->combination exp) env))
            ((application? exp)
             (apply (eval (operator exp) env)
                    (list-of-values (operands exp) env)))
            (else
             (error "Неизвестный тип выражения -- EVAL" exp))))
#+END_SRC

~Упражнение 4.7~.
Особая форма ~let*~ подобна let, но только связывания переменных в let*
происходят последовательно, и каждое следующее связывание происходит в
окружении, где видны все предыдущие.
Объясните, каким образом можно переписать выражение ~let*~ в виде
набора вложенных выражений ~let~, и напишите процедуру ~let*->nested-lets~,
которая проделывает это преобразование. Если мы уже реализовали let (упражнение 4.6)
и хотим теперь расширить интерпретатор так, чтобы он обрабатывал let*, достаточно ли
будет добавить в ~eval~ ветвь, в которой действием записано
~(eval (let*->nested-lets exp) env)~
или нужно явным образом преобразовывать let* в набор непроизводных
выражений?

Преобразование формы let* -> вложенные let -> вложенные лямбды:
#+BEGIN_SRC scheme
  (let* ((x 3)
         (y (+ x 2))
         (z (+ x y 5)))
    (* x z))

  (let ((x 3))
    (let ((y (+ x 2)))
      (let ((z (+ x y 5)))
        (* x z))))

  ((lambda (x)
    ((lambda (y)
       ((lambda (z)
          (* x z)) (+ x y 5))) (+ x 2))) 3)
#+END_SRC

Пишем преобразование let* в вложенные let:

#+BEGIN_SRC scheme
  (define (make-let param-and-expr-list body)
    (list 'let param-and-expr-list body))

  (define (let*? exp)
    (tagged-list? exp 'let*))

  (define (let*->nested-lets exp)
    (define (iter param-and-expr-list body)
      (if (null? param-and-expr-list)
          body
          (make-let (list (car param-and-expr-list))
                    (iter (cdr param-and-expr-list) body))))
    (iter (cadr exp) (car (last-pair exp))))

  ;; тест
    (let* ((x 3)
           (y (+ x 2))
           (z (+ x y 5)))
      (* x z))

#+END_SRC

#+BEGIN_SRC scheme
  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((if? exp) (eval-if exp env))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((let? exp) (eval (let->combination exp) env))
          ((let*? exp) (eval (let*->nested-lets exp) env))
          ((application? exp)
           (apply (eval (operator exp) env)
                  (list-of-values (operands exp) env)))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))

#+END_SRC

Отдельно преобразовывать let* в вложенные лямбды не нужно, поскольку
~eval~ все доделает за нас:
 - при получении let* eval раскроет его в вложенные let благодаря
   сработавшей ветке  ~(eval (let*->nested-lets exp) env)~,
 - затем let будет преобразован в лямбду, а все вложенные let станут телом
   лямбды.
 - при вычислении процедуры вычисляется ее тело и аргументы. При
   вычислении тела лямбды мы наткнемся на вложенные ~let~ и раскроем их
   тоже.

И так до тех пор, пока выражение не превратится в такое, которое можно
вычислить полностью, поскольку именно к этому стремится ~eval~

~Упражнение 4.8.~
«Именованный let» — это вариант let, который имеет вид
(let <переменная> <связывание> <тело>)
Измените преобразование ~let->combination~ из упражнения 4.6 так, чтобы оно
поддерживало именованный let.

Пример именованного ~let~:
#+BEGIN_SRC scheme
  (define (fib n)
    (let fib-iter ((a 1)
                   (b 0)
                   (count n))
      (if (= count 0)
          b
          (fib-iter (+ a b) a (- count 1)))))
#+END_SRC

Обычно ~let~ раскрывается в вызов лямбды, а именованая лямбда выглядит так:
#+BEGIN_SRC scheme
  (define square
    (lambda (x) (* x x)))
#+END_SRC

Соответственно, нам просто нужно ракрыть вызов именованного ~let~ в
именованную лямбду. Это в общем случае. В конкретном пришлось
использовать промисы из-за имеющейся рекурсии, поэтому данное
преобразование годится только для этого примера.

Пока в матециклическом интерпретаторе проверить не удалось.
#+BEGIN_SRC scheme
  (define (fib n)
    (let fib-iter ((a 1)
                   (b 0)
                   (count n))
      (if (= count 0)
          b
          (fib-iter (+ a b) a (- count 1)))))

  ;; именованный let должен раскрыться в:
    (define fib-iter
      (lambda (a b count)
        (cons-stream a
                     (if (= count 0)
                         b
                         (fib-iter (+ a b) a (- count 1))))))

  (define (make-lambda parameters body)
    (cons 'lambda (cons parameters body)))

  (define (show-stream stream n)
    (if (= n 0)
        'done
        (begin
          (display (stream-car stream))
          (newline)
          (show-stream (stream-cdr stream) (- n 1)))))

  (define (let->combination exp)
    (define (get-all-params exp)
      (map (lambda (x) (car x)) exp))
    (define (get-all-exps exp)
      (map (lambda (x) (cadr x)) exp))
    (list 'define (cadr exp)
          (make-lambda (get-all-params (caddr exp))
                       (list (list
                              'cons-stream (car (get-all-params (caddr exp)))
                              (cadddr exp))))))

  (let->combination '(let fib-iter ((a 1)
                                    (b 0)
                                    (count n))
                       (if (= count 0)
                           b
                           (fib-iter (+ a b) a (- count 1)))))
#+END_SRC

~Упражнение 4.9~.
Во многих языках имеются различные конструкции для построения циклов,
например, do, for, while и until. В Scheme итеративные процессы можно
выразить через обычные вызовы процедур, так что особые конструкции не
дают никакого существенного выигрыша в вычислительной мощности.
С другой стороны, часто они удобны. Придумайте какие-нибудь
конструкции для итерации, дайте примеры их использования и покажите, как
их реализовать в виде производных выражений.

Попробуем реализовать относительно несложный цикл ~while~. Итерации
происходят до тех пор, пока условие while истинно.

#+BEGIN_SRC scheme
  (define (make-while condition step-form body)
    (list 'while condition step-form body ))

  (define (while? exp)
    (tagged-list? exp 'while))

  (define (eval-while exp env)
    (define (eval-while-iter condition body)
      (if (eval condition env)
          (begin
            (eval-sequence body env)
            (eval-while-iter condition body))
          'done
          ))
    (let ((exp-without-tag (rest-exps exp)))
      (eval-while-iter (first-exp exp-without-tag) (rest-exps exp-without-tag))))


  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((if? exp) (eval-if exp env))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((let? exp) (eval (let->combination exp) env))
          ((let*? exp) (eval (let*->nested-lets exp) env))
          ((while? exp) (eval-while exp env))
          ((application? exp)
           (apply (eval (operator exp) env)
                  (list-of-values (operands exp) env)))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))

  (define test 0)

  (while (< test 10)
         (display test)
         (set! test (+ test 1)))


#+END_SRC

И попробуем реализовать цикл ~for~.

#+BEGIN_SRC scheme
  (define (make-for var-and-init-value step-form condition body)
    (list 'for var-and-init-value step-form condition body))


  (define test (for (list i 0) (set! i (+ i 1)) (> i 20)
                     (display i))

  (define (for? exp)
    (tagged-list? exp 'for))

  (define (eval-for exp env)
    (define (eval-for-iter condition step-form-and-body)
      (if (not (eval condition env))
          (begin
            (eval-sequence step-form-and-body env)
            (eval-for-iter condition step-form-and-body))
          'done))
    (let* ((initial-form (first-exp (rest-exps exp)))
           (var (car initial-form))
           (init-value (cadr initial-form))
           (step-form (third exp))
           (condition (fourth exp))
           (step-form-and-body (append (cddddr exp) (list step-form))))
      (eval `(define ,var ,init-value) env)
      (eval-for-iter condition step-form-and-body)))

  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((if? exp) (eval-if exp env))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((let? exp) (eval (let->combination exp) env))
          ((let*? exp) (eval (let*->nested-lets exp) env))
          ((while? exp) (eval-while exp env))
          ((for? exp) (eval-for exp env))
          ((application? exp)
           (apply (eval (operator exp) env)
                  (list-of-values (operands exp) env)))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))
#+END_SRC

~Упражнение 4.11.~
Вместо того, чтобы представлять кадр в виде списка списков, его можно
представить как список связываний, где каждое связывание является парой из имени и
значения. Перепишите операции с окружениями в соответствии с этим
альтернативным представлением.

Исходное представление окружения:
- окружение - это список, состоящий из списокв
- каждый подсписок - это кадр
- каждый кадр содержит в себе два списка: список переменных и список их значений:

~'((a b c d) (1 2 3 4))~
Вместо исходного представления кадра нам предлагается представить кадр
как список списков, где каждый подсписок - это пара переменная-значение:
~'((a 1) (b 2) (c 3) (d 4))~

Значит, нам надо только изменить процедуры, работающие непосредственно с
кадрами.

Функции ~look-up-for-variable~ и ~extend-environment~ изменять не
пришлось
Проверено через обычную схему
#+BEGIN_SRC scheme
  (define the-empty-environment '())

  (define (enclosing-environment env) (cdr env))

  (define (first-frame env) (car env))

  (define (make-frame vars vals)
    (map (lambda (x y)
           (list x y )) vars vals))

  (define test-frame (make-frame '(a b c d) '(1 2 3 4)))

  (define (frame-variables frame)
    (map (lambda (x)
           (car x)) frame))

  (frame-variables test-frame)

  (define (frame-values frame)
    (map (lambda (x)
           (cadr x)) frame))

  (frame-values test-frame)

  (define (add-binding-to-frame! var val frame)
    (cons (list var val) frame))

  (add-binding-to-frame! 'e 5 test-frame)

  (define base-env (list test-frame test-frame))

  ;; присоединяем новый кадр к текущему окружению
  ;; изменять не пришлось
  (define (extend-environment vars vals base-env)
    (if (= (length vars) (length vals))
        (cons (make-frame vars vals) base-env)
        (if (< (length vars) (length vals))
            (error "Получено слишком много аргументов" vars vals)
            (error "Получено слишком мало аргументов" vars vals))))

  (set! base-env (extend-environment '(r t y u) '(5 6 7 8) base-env))

  (define (define-variable! var val env)
    (let ((cur-frame (first-frame env)))
      (define (scan frame)
        (if (null? frame)
            (begin
            (set-car! env
                      (add-binding-to-frame! var val cur-frame))
            #t)
            (let ((cur-pair (car frame)))
              (if (eq? var (car cur-pair))
                  (begin
                    (set-cdr! cur-pair (list val))
                    #t)
                  (scan (cdr frame))))))
      (scan cur-frame)))

  (define-variable! 't 0 base-env)
  (define-variable! 'k 0 base-env)

  (define (set-variable-value! var val env)
    (define (env-loop env)
      (define (scan frame)
        (if (null? frame)
            (env-loop (enclosing-environment env))
            (let ((cur-pair (car frame)))
              (if (eq? var (car cur-pair))
                  (begin
                    (set-cdr! cur-pair (list val))
                    #t)
                  (scan (cdr frame))))))
      (if (eq? env the-empty-environment)
          (error "Несвязанная переменная -- SET!" var)
          (let ((frame (first-frame env)))
            (scan frame))))
    (env-loop env))

  (set-variable-value! 'r 13 base-env)
  (set-variable-value! 'a 8 base-env)
  (set-variable-value! 'g 0 base-env)

  ;; ничего менять не пришлось
  (define (lookup-variable-value var env)
    (define (env-loop env)
      (define (scan vars vals)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((eq? var (car vars))
               (car vals))
              (else (scan (cdr vars) (cdr vals)))))
      (if (eq? env the-empty-environment)
          (error "Несвязанная переменная" var)
          (let ((frame (first-frame env)))
            (scan (frame-variables frame)
                  (frame-values frame)))))
    (env-loop env))

  (lookup-variable-value 'd base-env)
#+END_SRC

~Упражнение 4.12.~
Процедуры ~set-variable-value!~, ~define-variable!~ и ~lookup-variable-value~
можно выразить посредством более абстрактных процедур для просмотра структуры
окружений. Определите абстракции, которые фиксируют общую схему
поведения, и с их помощью перепишите эти три процедуры.

Я так понимаю, что нам нужно написать общую процедуру, через которую мы
сможем выразить три названные процедуры.

Чем похожи эти процедуры?
- все три ищут переменные в окружении
- все делают это более-менее похожим образом

Напишем общую процедуру для поиска чего-либо внутри окружения/кадра. Она
будет искать переменную в кадре и если найдет, то вернет ее индекс в
списке переменных (индекс начинается с нуля) или же #f если ничего нет.

Так же внутри исходной функции ~scan~ при нахождении нужной переменной
выполняются заданные действия, например, присвоение переменной другого
значения или же генерирование нового связывния и добавления его в текущий
кадр.

Мы для этого напишем отдельные функции: ~get-value-by-indx!~ и
~set-value-by-indx!~, они оба принимают индекс.
~get-value-by-indx!~ - возвращает хначение пересенной
~set-value-by-indx!~ - устанавливает значение переменной

Зачем нам индексы вообще? Дело в том, что список переменных и их значений
идет параллельно. Т.е. первый элемент списка переменных соответстввует
первому элементу писка значений и т.д. Соответственно, когда мы ищем
переменную, мы возвращаем ее порядковый номер, индекс, чтоб в дальнейшем
могли добраться до ее значения или ее самой по индексу.

Недостаток этого подхода заключается в том, что приходится дважды
проходить по спискам: первый раз когда ищем переменную и второй, когда
возвращаем/устанавливаем значение

Проверено через обычную схему
#+BEGIN_SRC scheme
  (define (make-frame variables values)
    (cons variables values))

  (define (frame-variables frame) (car frame))

  (define (frame-values frame) (cdr frame))

  (define (add-binding-to-frame! var val frame)
    (set-car! frame (cons var (car frame)))
    (set-cdr! frame (cons val (cdr frame))))

  (define base-env (list (make-frame '(a b c d) '(1 2 3 4))
                         (make-frame '(e f v n) '(5 6 7 8))))

  (define (set-value-by-indx! val vals indx)
    (if (= indx 0)
        (set-car! vals val)
        (set-value-by-indx! val (cdr vals) (- indx 1))))

  (define (scan var vars vals indx)
    (if (null? vars)
        #f
        (if (eq? var (car vars))
            indx
            (scan var (cdr vars) (cdr vals)))))

  (define (get-value-by-indx! vals indx)
    (if (= indx 0)
        (car vals)
        (get-value-by-indx! (cdr vals) (- indx 1))))

  (define (define-variable! var val env)
    (let* ((frame (first-frame env))
           (get-var-indx (scan var
                               (frame-variables frame)
                               (frame-values frame) 0)))
      (if get-var-indx
          (set-value-by-indx! val (frame-values frame)
                              get-var-indx)
          (add-binding-to-frame! var val frame))))

  (define-variable! 'd 10 base-env)

  (define (set-variable-value! var val env)
    (define (env-loop env)
      (if (eq? env the-empty-environment)
          (error "Несвязанная переменная -- SET!" var)
          (let* ((frame (first-frame env))
                 (get-var-indx (scan var
                                     (frame-variables frame)
                                     (frame-values frame) 0)))
                 (if get-var-indx
                     (set-value-by-indx! val (frame-values frame)
                                         get-var-indx)
                     (env-loop (cdr env))))))
    (env-loop env))

  (set-variable-value! 'd 14 base-env)

  (define (lookup-variable-value var env)
    (define (env-loop env)
      (if (eq? env the-empty-environment)
          (error "Несвязанная переменная" var)
          (let* ((frame (first-frame env))
                (get-var-indx (scan var
                                    (frame-variables frame)
                                    (frame-values frame) 0)))
            (if get-var-indx
                (get-value-by-indx! (frame-values frame)
                                    get-var-indx)
                (env-loop (cdr env))))))
    (env-loop env))

  (lookup-variable-value 'd base-env)
#+END_SRC

~Упражнение 4.13.~
Scheme позволяет создавать новые связывания через define, но не дает
никакого способа избавиться от связывания. Реализуйте в интерпретаторе особую форму
make-unbound!, которая изымает связывание данного символа из окружения, в
котором make-unbound! выполняется.

Задача определена не до конца. Например, нужно ли удалять связывания в
других кадрах, кроме первого? Дополните спецификацию и объясните свой выбор вариантов.

Наверное, прежде чем дополнять спецификацию, стоит подумать, зачем нам
отвязывание.

Освободить имя? Но имен очень много, вряд ли возникнет ситуация, когда
нужен именно этот символ и именно для конкретных целей, а он уже занят
какой-то другой привязкой.

Я думаю, что имеет смысл отвязывать переменные ради экономии
памяти. Тогда нам нужно отвязаться переменную во всех кадрах окружения,
убедившись перед этим, что на нее нигде нет ссылок. Тогда мы
сконструируем нечто, сильно напоминающее "сборщик мусора", а это сделать
непросто.

Поэтому я сделаю промежуточную версию сборщика мусора. Если поступит
команда отвязать переменную, я буду отвязывать ее во всех кадрах текущего
окружения. Мне кажется это более безопасным с точки зрения
программирования. Если этого не сделать, то могут возникнуть
сложноотслеживаемые баги. Например, у нас есть два кадра с одной и той же
переменной. Предположим, в первом кадре мы отвязали символ от текущей
переменной и присвоили его функции. Но во втором кадре этот символ занят
все еще переменной. Через какое-то время можно легко забыть, с чем в
каком кадре связан символ и потом долго гадать, почему интерпретатор
утверждает, что мы пытаемся обратиться к переменной как к функции и
наоборот. Особенно весело будет отлаживать такие вещи в большом проекте.

Предполагается, что кадры организованы как в мане, т.е. в виде пары с
двумя подсписками: в одном все переменные, в другом их значения

Проверено через обычную схему
#+BEGIN_SRC scheme
  (define (make-frame variables values)
    (cons variables values))

  (define (frame-variables frame) (car frame))

  (define (frame-values frame) (cdr frame))

  (define (scan-and-copy-frame var old-vars-list old-vals-list
                               new-vars-list new-vals-list)
    (cond ((null? old-vars-list)
           (make-frame new-vars-list new-vals-list))
          ((eq? var (car old-vars-list))
           (make-frame (append new-vars-list (cdr old-vars-list))
                       (append new-vals-list (cdr old-vals-list))))
          (else (scan-and-copy-frame var (cdr old-vars-list) (cdr old-vals-list)
                                     (append new-vars-list (list (car old-vars-list)))
                                     (append new-vals-list (list (car old-vals-list)))))))

  (scan-and-copy-frame 'f '(a s d f) '(1 2 3 4) '() '())

  (define (make-unbound! var env)
    (define (env-loop env)
      (if (eq? env the-empty-environment)
          'ok
          (let ((frame (first-frame env)))
            (set-car! env
                  (scan-and-copy-frame var (frame-variables frame)
                                       (frame-values frame)'() '()))
            (env-loop (cdr env)))))
    (env-loop env))

  (define test-env (list (make-frame '(a s d f) '(1 2 3 4))
                         (make-frame '(g s f k) '(5 6 7 8))))

  (make-unbound! 'd test-env)
  (make-unbound! 's test-env)
  (make-unbound! 'e test-env)
#+END_SRC

~Упражнение 4.14.~
Ева Лу Атор и Хьюго Дум экспериментируют с метациклическим
интерпретатором каждый по отдельности. Ева вводит определение ~map~ и
запускает несколько тестовых программ с его использованием. Они
замечательно работают.
Хьюго, со своей стороны, ввел системную версию ~map~
как примитив метациклического интерпретатора. Когда он пытается его
выполнить, все ломается самым ужасным образом.
Объясните, почему у Хьюго map не работает, а у Евы работает.

Ответ:
Думаю дело в парсинге всего выражения. Иными словами, если
метациклический интерпретатор встретит map Хьюго, map будет воспринят как
примитив.
Значит, eval сразу передаст метациклическому ~apply~ оператор и
аргументы, чтобы ~apply~ вызвал вызвал нижележащий ~apply~ и исполнил
вызов примитива. Возможная проблема в том, что перед передачей аргументов
в apply метациклический eval попытается вычислить аргументы операции,
чтоб передать в процедуру их значения. А аргументы map - это лямбда и
список. Если список eval еще можен корректно вычислить, то как она
вычислит лямбду, то вычисление лямбды может не совпадать у
метациклического и нижележащего интерпретатора. Нам в мане говорилось,
что данные eval и apply достаточно примитивны и совершенно не отражают
всю полноту вычислений и всех нюансов, которые происходят в настоящем
интерпретаторе.

~Упражнение 4.15.~
Если даны одноаргументная процедура p и объект a, то говорят, что p
«останавливается» на a, если выражение (p a) возвращает значение
(а не печатает сообщение об ошибке или выполняется
вечно).
Покажите, что невозможно написать процедуру halts?, которая бы
точно определяла для любой процедуры p и любого объекта a, останавливается ли p на
a. Используйте следующее рассуждение: если бы имелась такая процедура
halts?, можно было бы написать следующую программу:

#+BEGIN_SRC scheme
  (define (run-forever) (run-forever))

  (define (try p)
    (if (halts? p p)
        (run-forever)
        'halted))
#+END_SRC

Теперь рассмотрите выражение (try try) и покажите, что любое возможное
завершение (остановка или вечное выполнение) нарушает требуемое поведение
halts?

Разберем код, представленный выше. Нам сказано, что ~p~ - это
одноаргументная процедура. В процедуре ~try~ мы пытаемся
выявить, останавливается ли процедура ~p~ на переданном ей параметре - той
же процедуре ~p~. Процедура здесь является и данными, и процедурой.

Теперь рассмотрим вызов (try try). При проверке условия ифа, мы вызовем
операцию ~p~ с аргументов  ~p~ - в нашем случае это превратится в вызов
(try try) снова, и так до бесконечности. То есть мы просто навечно
зациклимся внутри ~try~, а до предиката исполнение так и не дойдет. То
есть мы не можем вернуть ~false~, если вычисление не останавливается,
потому что чтоб что-то вернуть, вычисление должно остановиться.

Чтоб построить процедуру ~halts?~, нам бы понадобился многопоточный
интерпретатор, если такой вообще можно сделать. Тогда, предположим, если
один поток интерпретатора долго не отвечает, то другие потоки могут
известить прогаммиста, что вычисление в одном из потоков зациклилось.

~Упражнение 4.16.~
В этом упражнении мы реализуем только что описанный метод обработки
внутренних определений. Мы предполагаем, что интерпретатор поддерживает
let (см. упражнение 4.6).
а. Измените процедуру ~lookup-variable-value~ (раздел 4.1.3) так, чтобы
она, обнаруживая в качестве значения символ *unassigned*, сообщала об ошибке.
б. Напишите процедуру ~scan-out-defines~, которая берет тело процедуры и
возвращает его эквивалент без внутренних определений, выполняя описанное нами
преобразование.
в. Вставьте ~scan-out-defines~ в интерпретатор, либо в ~make-procedure~, либо
в ~procedure-body~. Какое из этих мест лучше? Почему?

Проверено через обычную схему
#+BEGIN_SRC scheme
  ;;преобразование, описанное в мане
  (lambda <переменные>
    (define u <e1>)
    (define v <e2>)
    <e3>)

  (lambda <переменные>
    (let ((u '*unassigned*)
          (v '*unassigned*))
      (set! u <e1>)
      (set! v <e2>)
      <e3>))

  ;; необходимые для работы функции
  (define (definition? exp)
    (tagged-list? exp 'define))

  (define (tagged-list? exp tag)
    (if (pair? exp)
        (eq? (car exp) tag)
        #f))

  ;; задание А
  (define (lookup-variable-value var env)
    (define (env-loop env)
      (define (scan vars vals)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((eq? var (car vars))
               (if (eq? (car vals) '*unassigned*)
                   (error "Значение не определено" (car vals))
                   (car vals)))
              (else (scan (cdr vars) (cdr vals)))))
      (if (eq? env the-empty-environment)
          (error "Несвязанная переменная" var)
          (let ((frame (first-frame env)))
            (scan (frame-variables frame)
                  (frame-values frame)))))
    (env-loop env))

  (define env (list (make-frame '(a b c d) '(1 2 3 *unassigned*))
                    (make-frame '(h b s f) '(3 9 5 7))))

  (lookup-variable-value 'd env)

  ;;Задание Б

  ;; принимает тело исходной лямбды
  ;; возвращает список, состоящий из трех подсписков: имена, значения имен, остальное тело
  (define (split-names-values-body body-proc names values body)
    (if (null? body-proc)
        (list names values body)
        (let ((exp (car body-proc)))
          (if (definition? exp)
              (split-names-values-body  (cdr body-proc)
                             (append names (list (cadr exp)))
                             (append values (list (caddr exp))) body)
              (split-names-values-body  (cdr body-proc) names values
                                        (append body (list exp)))))))

  ;; создает заготовку для let:
  ;; принимает список имен
  ;; возвращает список списков, где car каждого подсписка - имя, а cdr - символ '*unassigned*
  (define (make-unassigned-let names)
    (map (lambda (name)
           (list name '*unassigned*)) names))

  ;; создает "присваивания" (ничего не присваивается на самом деле, мы просто соединяем
  ;; элементы присваивания (set! имя значение) в спики
  ;; возвращаем список, где все подсписки - это формы готовые выражения для присваивания
  (define (make-sets names values sets)
    (if (null? names)
        sets
        (make-sets (cdr names) (cdr values)
                   (append sets (list (list 'set! (car names) (car values)))))))

  ;; (make-sets (car test) (cadr test) '())

  (define (scan-out-defines proc)
    (let ((names-values-body (split-names-values-body (cddr proc)
                                                      '() '() '())))
      (list 'lambda (cadr proc)
            (append (list 'let (make-unassigned-let (car names-values-body)))
                          (make-sets (car names-values-body)
                                     (cadr names-values-body) '())
                          (caddr names-values-body)))))

  (define test '(lambda (x y z)
                  (define u 4)
                  (define k 5)
                  (+ u k)
                  (define h 6)))

  (scan-out-defines test)

#+END_SRC

Я бы вставила ~scan-out-defines~ непосредственно в интерпретатор, так мы
бы смогли использовать процедуру где угодно.

~Упражнение 4.17~.
Нарисуйте диаграммы окружения, которое находится в силе в момент
выполнения выражения <e3i> из процедуры выше по тексту, и сравните его устройство при
последовательной обработке определений и при описанном выше
преобразовании.
Откуда в преобразованной программе берется дополнительный кадр?
Объясните, почему это различие никогда не отражается на поведении
корректных программ. Придумайте, как заставить интерпретатор реализовать
правило «одновременной» сферы действия для внутренних определений без создания
дополнительного кадра.

#+BEGIN_SRC scheme
  (lambda <переменные>
    (define u <e1>)
    (define v <e2>)
    <e3>)

  (lambda <переменные>
    (let ((u '*unassigned*)
          (v '*unassigned*))
      (set! u <e1>)
      (set! v <e2>)
      <e3>))

#+END_SRC

Итак, дополнительный кадр образуется из-за использования формы ~let~,
которая всегда создает свое собственное окружение, поскольку раскрывается
в лямбду. Тело letстановится телом лямбды, объявляемые переменные
становятся параметрами лямбды, а выражения, которые присваивались
переменным, становятся аргументами, которые мы передаем лямбде при ее
вызове.

Справедливости ради надо отметить, что ~define~ тоже создает свое
собственное окружение, просто оно "закрывается" раньше, что <e3> начнет
выполняться, поскольку ~define~ объявляет свою переменную "глобально" для
окружения, в котором находится, поскольку раскрывается в именованную
лямбду. Поэтому к ней можно обратиться даже за пределами ее соственного
окружения, при условии, что ссылка на имя происходит после определения.

Разичия в поведении коректных программ из-за объявления через ~define~ или
через ~let~ нет, поскольку, фактически, все что не ~define~, т.е. не
определение - это тело функции. В нашем случае тело функции заключается в
тело ~let~, внутри которого мы имеем свободный доступ к объявленным
переменным.

Чтоб нам не пришлось создавать дополнительный кадр, нужно, чтоб у нас
остались ~define~, только при объявлении мы сделаем их *unassigned*, а
затем присвоим значение, какое планировали изначально.
Таким образом у нас получится такое преобразование:

#+BEGIN_SRC scheme
  (lambda <переменные>
    (define u <e1>)
    (define v <e2>)
    <e3>)

  (lambda <переменные>
    (define u '*unassigned*)
    (define v '*unassigned*)
    (set! u <e1>)
    (set! v <e2>)
      <e3>)

#+END_SRC

~Упражнение 4.18~.
Рассмотрим альтернативную стратегию обработки определений, которая
совершает такое преобразование:

#+BEGIN_SRC scheme
  (lambda <переменные>
    (define u <e1>)
    (define v <e2>)
    <e3>)

  (lambda <переменные>
    (let ((u '*unassigned*)
          (v '*unassigned*))
      (let ((a <e1i>)
            (b <e2>))
        (set! u a)
        (set! v b))
      <e3>))
#+END_SRC

Здесь a и b представляют новые имена переменных, созданные
интерпретатором, которые не встречаются в пользовательской программе.
Рассмотрим процедуру solve из раздела 3.5.4. Будет ли эта процедура
работать, если внутренние определения преобразуются так, как предлага-
ется в этом упражнении? А если так, как в тексте раздела? Объясните.

#+BEGIN_SRC scheme
  (define (solve f y0 dt)
    (define y (integral (delay dy) y0 dt))
    (define dy (stream-map f y))
    y)
#+END_SRC

Итак, solve - это пример цикличского задержанного выражения или промисов
внутри промисов. Чтоб вычислить ~y~ нам нужно знать ~dy~ и
наоборот. Поэтому мы вычисляем оба этих потока по очереди и поэтому
вычисление ~dy~ отложено.
Посмотрим, во что раскроется это выражение согласно тому, как это
предложено в этом упражнении:

#+BEGIN_SRC scheme
  (define solve
    (lambda (f y0 dt)
      (let ((y '*unassigned*)
            (dy '*unassigned*))
        (let ((a (integral (delay dy) y0 dt))
              (b (stream-map f y)))
          (set! y a)
          (set! dy b)) y)))   ;;----------->

  (define solve
    (lambda (f y0 dt)
      ((lambda  (y dy)
         ((lambda (a b)
            (set! y a)
            (set! dy b)) (integral (delay dy) y0 dt)
            (stream-map f y))
         y)
       '*unassigned* '*unassigned*)))

#+END_SRC

Данная трансформация не сработает. До присвоение мы попытаемся вычислить
аргументы ~a~ и ~b~ во внутренней лямбде. С аргументов ~a~ у нас все
получится, поскольку вычисление ~dy~ задержано. Но вот вычисление
аргумента ~b~ не состоится, поскольку выражение ~(stream-map f y)~
использует ~y~, значение которого не определено.

Теперь рассматриваем, что будет, если выражение раскроется, как описано в тексте:
#+BEGIN_SRC scheme
  (define solve
    (lambda (f y0 dt)
      (let ((y '*unassigned*)
            (dy '*unassigned*))
        (set! y (integral (delay dy) y0 dt))
        (set! dy (stream-map f y))
        y))) ;; --------------->

  (define solve
    (lambda (f y0 dt)
      ((lambda (y dy)
        (set! y (integral (delay dy) y0 dt))
        (set! dy (stream-map f y))
        y) '*unassigned* '*unassigned*)))

#+END_SRC

При вычислении этого выражения все сработает. Сначала значение ~y~ и ~dy~
не определено, но затем мы вычисляем выражения одно за другим и вовремя
присваиваем переменным реультаты вычисления выражения.

~Упражнение 4.19.~
Бен Битобор, Лиза П. Хакер и Ева Лу Атор спорят о том, каким должен быть
результат выражения

#+BEGIN_SRC scheme
  (let ((a 1))
    (define (f x)
      (define b (+ a x))
      (define a 5)
      (+ a b))
    (f 10))
#+END_SRC

Бен говорит, что следует действовать согласно последовательному правилу
для ~define~: ~b~ равно 11, затем ~a~ определяется как 5, так что общий
результат равен 16. Лиза возражает, что взаимная рекурсия требует правила
одновременной сферы действия для внутренних определений и нет причин
рассматривать имена процедур отдельно от прочих имен. То есть она
выступает за механизм, реализованный в упражнении 4.16.
При этом ~a~ оказывается не определено в момент, когда определяется ~b~.
Следовательно, по мнению Лизы, процедура должна выдавать ошибку. Ева не согласна с
обоими. Она говорит, что если определения вправду должны считаться
одновременными, то 5 как значение ~a~ должно использоваться при вычислении
~b~. Следовательно, по мнению Евы, ~a~ должно равняться 5, ~b~ должно
быть 15, а общий результат 20.
Какую из этих точек зрения Вы поддерживаете (если у Вас нет своей
четвертой)?
Можете ли Вы придумать способ реализации внутренних определений, который
бы работал так, как предлагает Ева?

Я попробовала запустить данное выражение и столкнулась с ошибкой
"переменная а уже зарезервирована". Это понятно, потому что происходит
внутри окружения ~let~, которая объявляет переменную ~a~ и присваивает ей
значение 1.
Соответственно, мы не можем объявить переменную с таким же именем.
Теперь предположим, что нам это все-таки удалось.
Тогда в этом случае при определении ~b~ мы будем использоват ранее
объявленное значение ~a~ и тогда пойдем по сценарию Бена, особенно если
будем использовать интерпретатор, который описан в этой главе.
В нем если мы встречаем повторное объявление переменной в том же
окружении, то мы просто присваиваем ей новое значение.

Чтоб реализовать вариант Евы, мы можем использовать промисы внутри
промисов. То есть отложить вычисление ~a~ или ~b~ до тех пор, пока они не
понадобятся.

Получится что-то вроде этого:
#+BEGIN_SRC scheme
  (let ((a 1))
    (define (f x)
      (define b (cons-stream x (+ (delay a) x)))
      (define a (cons-stream 5 5))
      (cons-stream x (add-streams a (force b)))
    (f 10)))
#+END_SRC

Это несовершенный вариант (я даже не уверена, что он может сработать),
поскольку первое значение, которое вернет нам поток, не будет правильным,
придеся ждать второе, к тому времени ~b~ будет полность вычислено и мы
сможем корректно посчитать результат.

~Упражнение 4.20.~
Поскольку внутренние определения выглядят последовательными, а на самом
деле параллельны, некоторые предпочитают их вовсе избегать и вместо этого
пользуются особой формой ~letrec~.
Letrec выглядит так же, как ~let~, поэтому неудивительно, что переменные в
нем связываются одновременно и имеют одинаковую для всех сферу действия.
Можно переписать процедуру-пример ~f~ из текста без внутренних
определений, но при этом в точности с тем же
значением, так:

#+BEGIN_SRC scheme
  (define (f x)
    (define (even? n)
      (if (= n 0)
          true
          (odd? (- n 1))))
    (define (odd? n)
      (if (= n 0)
          false
          (even? (- n 1))))
    <остаток тела f>) ;; -------->

  (define (f x)
    (letrec ((even?
              (lambda (n)
                (if (= n 0)
                    true
                    (odd? (- n 1)))))
             (odd?
              (lambda (n)
                (if (= n 0)
                    false
                    (even? (- n 1))))))
      <остаток тела f>))
#+END_SRC

Letrec является вариантом let, в котором выражения <выр i>, устанавливающие
начальные значения для переменных <пер i>, вычисляются в окружении,
которое включает все связывания letrec.
Это делает возможным рекурсию между связываниями, к примеру, взаимную
рекурсию even? и odd? в последнем примере, или вычисление факториала 10
через

#+BEGIN_SRC scheme
  (letrec ((fact
            (lambda (n)
              (if (= n 1)
                  1
                  (* n (fact (- n 1)))))))
    (fact 10))
#+END_SRC

а. Реализуйте ~letrec~ как производное выражение, переводя выражение letrec
в выражение ~let~, как показано в тексте раздела или в упражнении 4.18. То есть
переменные ~letrec~ должны создаваться в ~let~, а затем получать значение через set!.

б. Хьюго Дум совсем запутался во всех этих внутренних определениях. Ему
кажется, что если кому-то не нравятся ~define~ внутри процедуры, то пусть
пользуются обычным ~let~.
Покажите, что́ в его рассуждениях неверно. Нарисуйте диаграмму, показывающую
окружение, в котором выполняется <остаток тела f> во время вычисления
выражения (f 5), если ~f~ определена как в этом упражнении.
Нарисуйте диаграмму окружений для того же вычисления, но только с ~let~
на месте ~letrec~ в определении ~f~.

Проверено через обычную схему.
Задание а:
#+BEGIN_SRC scheme
  ;;получаем список имен и список значений, с ними связанных
  (define (split-names-values letrec-binds names values)
    (if (null? letrec-binds)
        (list names values)
        (let ((cur-bind (car letrec-binds)))
          (split-names-values (cdr letrec-binds)
                              (append names (list (car cur-bind)))
                              (append values (cdr cur-bind))))))

  (split-names-values (cadr test) '() '())

  ;; создаем связывания имен с *unassigned*
  (define (make-unassigned-let names)
    (map (lambda (name)
           (list name '*unassigned*)) names))

  ;;присваиваем именам правильные значения
  (define (make-sets names values sets)
    (if (null? names)
        sets
        (make-sets (cdr names) (cdr values)
                   (append sets (list (list 'set! (car names) (car values)))))))


  ;; совершаем трансформацию
  (define (letrec->let expr)
    (let ((names-and-values (split-names-values (cadr expr) '() '())))
      (append (list 'let (make-unassigned-let (car names-and-values)))
              (make-sets (car names-and-values)
                         (cadr names-and-values) '())
              (cddr expr))))


  (define test '(letrec ((even?
                          (lambda (n)
                            (if (= n 0)
                                true
                                (odd? (- n 1)))))
                         (odd?
                          (lambda (n)
                            (if (= n 0)
                                false
                                (even? (- n 1))))))
                  '()))

  (letrec->let test)
#+END_SRC

Задание б:
Проблема в окружениях, которые создают ~let~ и ~define~. Если мы везде
используем ~let~,то все операции, которые выполняются с переменными,
объявленными через let, должны выполняться внутри тела самого ~let~. Если
мы определяем пременную через ~define~, то можем ссылаться на нее и за
пределами ее окружения - если define раскрывается в именованную лямбду.

Теперь рассмотрим наш случай: если let реализован как обычно, не как в
упр. 4.18, то связывание происходит последовательно, а не одновременно,
как в ~letrec~,поэтому в ~let~ не получится реализовать взаимную
рекурсию.

~Упражнение 4.21.~
Как ни удивительно, интуитивная догадка Хьюго (в упражнении 4.20)
оказывается верной. Действительно, можно строить рекурсивные процедуры
без использования ~letrec~ (и даже без define), только способ это сделать
намного тоньше, чем казалось Хьюго.
Следующее выражение вычисляет факториал 10 с помощью рекурсивной процедуры:

#+BEGIN_SRC scheme
  ((lambda (n)
     ((lambda (fact)
        (fact fact n))
      (lambda (ft k)
        (if (= k 1)
            1
            (* k (ft ft (- k 1)))))))
   10)
#+END_SRC

Задание а.
Проверьте, что это выражение на самом деле считает факториалы
(вычисляя его). Постройте аналогичное выражение для вычисления чисел
Фибоначчи.
Итак, выражение действительно вычисляет факториал. Вариант для Фибоначчи:

#+BEGIN_SRC scheme
  ;;исходный вариант
  (define (fib n)
    (define (fib-iter a b count )
      (if (= count 0)
          b
          (fib-iter (+ a b) a (- count 1))))
    (fib-iter 1 0 n))

  ;; переработанный
  ((lambda (n a b)
     ((lambda (fib-iter)
        (fib-iter fib-iter a b n))
      (lambda (fib-it a b count)
        (if (= count 0)
            b
            (fib-it fib-it (+ a b) a (- count 1)))))
     )
   4 1 0 )
#+END_SRC

Задаие б:
Рассмотрим следующую процедуру, включающую взаимно рекурсивные внутренние
определения:

#+BEGIN_SRC scheme
  (define (f x)
    (define (even? n)
      (if (= n 0)
          true
          (odd? (- n 1))))
    (define (odd? n)
      (if (= n 0)
          false
          (even? (- n 1))))
    (even? x))
#+END_SRC

Восстановите пропуски в выражениях:

#+BEGIN_SRC scheme
  (define (f x)
    ((lambda (even? odd?)
       (even? even? odd? x))
     (lambda (ev? od? n)
       (if (= n 0) true (od? ev? od? (- n 1))))
     (lambda (ev? od? n)
       (if (= n 0) false (ev? ev? od? (- n 1))))))

#+END_SRC

~Упражнение 4.22.~
Расширьте интерпретатор из этого раздела так, чтобы он поддерживал
let. (См. упражнение 4.6.)

Упражнение 4.6 гласит:
выражения let производны, поскольку раскрываются в лямбду.
Напишите синтаксическое преобразование ~let->combination~, которое сводит
вычисление let-выражений к вычислению комбинаций указанного вида, и добавьте
соответствующую ветку для обработки let к eval.

Значит, сейчас нам надо сейчас вставить уже имеющееся преобразование ~let~
в новый интерпретатор.
Реализация преобразования let из упражнение 4.6:

#+BEGIN_SRC scheme
  (define (make-lambda parameters body)
    (cons 'lambda (cons parameters body)))

  (define (let? exp)
    (tagged-list? exp 'let))

  (define (let->combination exp)
    (define (get-all-params exp)
      (if (null? exp)
          '()
          (cons (caar exp) (get-all-params (cdr exp)))))
    (define (get-all-exps exp)
      (if (null? exp)
          '()
          (cons (cadar exp) (get-all-exps (cdr exp)))))
    (append (list (make-lambda (get-all-params (cadr exp))
                               (cddr exp)))
            (get-all-exps (cadr exp))))

  (let ((a 1)
        (b 2))
    (+ a b))
#+END_SRC
Добавление его в интерпретатор:

#+BEGIN_SRC scheme
  (define (eval exp env)
    ((analyze exp) env))

  (define (analyze exp)
  (cond ((self-evaluating? exp)
         (analyze-self-evaluating exp))
        ((quoted? exp) (analyze-quoted exp))
        ((variable? exp) (analyze-variable exp))
        ((assignment? exp) (analyze-assignment exp))
        ((definition? exp) (analyze-definition exp))
        ((if? exp) (analyze-if exp))
        ((let? exp) (analyze (let->combination exp)))
        ((lambda? exp) (analyze-lambda exp))
        ((begin? exp) (analyze-sequence (begin-actions exp)))
        ((cond? exp) (analyze (cond->if exp)))
        ((application? exp) (analyze-application exp))
        (else
         (error "Неизвестный тип выражения -- ANALYZE" exp))))
#+END_SRC

~Упражнение 4.23~.
Лиза П. Хакер не понимает, зачем делать ~analyze-sequence~ такой
сложной. Все остальные процедуры анализа — простые трансформации
соответствующих вычисляющих процедур (или ветвей eval) из раздела 4.1.1.
Лиза ожидала, что ~analyze-sequence~ будет выглядеть так:

#+BEGIN_SRC scheme
  (define (analyze-sequence exps)
    (define (execute-sequence procs env)
      (cond ((null? (cdr procs)) ((car procs) env))
            (else ((car procs) env)
                  (execute-sequence (cdr procs) env))))
    (let ((procs (map analyze exps)))
      (if (null? procs)
          (error "Пустая последовательность -- ANALYZE"))
      (lambda (env) (execute-sequence procs env))))
#+END_SRC

Ева Лу Атор объясняет Лизе, что версия в тексте проделывает больше работы
по вычислению последовательности во время анализа. В Лизиной исполнительной процедуре
вызовы частичных исполнительных процедур, вместо того, чтобы быть встроенными,
перебираются в цикле. В результате, хотя отдельные выражения в
последовательности оказываются проанализированы, сама последовательность
анализируется во время выполнения.
Сравните две версии ~analyze-sequence~. Рассмотрите, например, обычный
случай (типичный для тел процедур), когда в последовательности только одно
выражение. Какую работу будет делать исполнительная процедура,
предложенная Лизой?
А процедура из текста раздела? Как соотносятся эти две процедуры в случае
последовательности из двух выражений?

Исходный вид ~analyze-sequence~:
#+BEGIN_SRC scheme
  ;;анализирует блоки выражений типа begin или тела процедуры
  (define (analyze-sequence exps)
    (define (sequentially proc1 proc2)
      (lambda (env) (proc1 env) (proc2 env)))
    (define (loop first-proc rest-procs)
      (if (null? rest-procs)
          first-proc
          (loop (sequentially first-proc (car rest-procs))
                (cdr rest-procs))))
    ;; получаем все исполнительные проедуры для выражения
    (let ((procs (map analyze exps)))
      (if (null? procs)
          (error "Пустая последовательность -- ANALYZE"))
      (loop (car procs) (cdr procs))))
#+END_SRC

Исходный вариант ~analyze-sequence~ сначала применит ~analyse~ к
выражению (выражениям), таким образом мы получим исполнительную процедуру
выражения. Затем вызовется ~loop~, и поскольку процедура одна, мы сразу
ее вернем. Если ~analyze-sequence~ на вход получит 2 выражения, то мы все
так же их проанализируем, затем ~loop~ соберет их в общую исполнительную
процедуру и так вернет.
Теперь посмотрим на Лизин вариант.
Мы возвращаем лямбду, внутри которой вызов ~execute-sequence~. Таким
образом у нас преобразование не закончено:
только при вызове этой лямбды мы начнем анализировать выражения дальше. К
тому же это еще и каждый раз делать придется.

~Упражнение 4.25.~
Предположим, что мы (в обычной Scheme с аппликативным порядком
вычислений) определяем ~unless~ как показано выше, а затем определяем
~factorial~ через ~unless~:

#+BEGIN_SRC scheme
  (define (unless condition usual-value exceptional-value)
    (if condition exceptional-value usual-value))

  (define (factorial n)
    (unless (= n 1)
            (* n (factorial (- n 1)))
            1))
#+END_SRC

Что произойдет, если мы попытаемся вычислить (factorial 5)? Будут ли наши
определения работать в языке с нормальным порядком вычислений?

Итак, в апликативном порядке вычислений аргументы процедуры вычисляются
до ее использования. Это значит, что все аргументы ~unless~ будут
вычислены до ее вызова, в том числе и  ~(* n (factorial (- n 1)))~,
попытавшись вычислить эото аргумент ~unless~, мы входим в бесконечную
рекурсию. Почему? Пока ~unless~ не вычислит все свои аргументы, она не
запуститcя, а до вычисления своего третьего аргумента она дойти никак не
может: вычисляя второй аргумент мы "проваливаемся" в вызов факториала,
затем снова пытаемся вычислить аргументы ~unless~ и так до тех пор, пока
стек не кончится.

В нормальном порядке вычислений этого не произошло бы, поскольку там
аргументы вычисляются только по требованию, когда они нужны. ~unless~
спокойно бы запустилась, мы бы проверили условие и в зависимости от того,
как оно сработало, мы бы вычислили остальные аргументы. Бесконечной
рекурссии бы не было.

~Упражнение 4.26.~
Бен Битобор и Лиза П. Хакер расходятся во мнениях о важности ленивых
вычислений для реализации конструкций вроде ~unless~.  Бен указывает, что
при аппликативном порядке ~unless~ можно реализовать как особую форму.
Лиза отвечает, что в таком случае ~unless~ будет просто синтаксисом, а не
процедурой, которую можно использовать в сочетании с процедурами высших
порядков. Проясните детали в обеих позициях. Покажите, как реализовать
~unless~ в виде производного выражения (вроде cond или let), и приведите
пример ситуации, когда имеет смысл, чтобы ~unless~ была процедурой,
а не особой формой.

Трансформация ~unless~ в соответствующее ему условное выражение.
#+BEGIN_SRC scheme
  (define (unless->if exp)
    (let ((condition (cadr exp))
          (usual-value (caddr exp))
          (exceptional-value (cadddr exp)))
      (list 'if condition exceptional-value usual-value)))


  (unless->if '(unless (= n 1)
                      (* n (factorial (- n 1)))
                      1))
#+END_SRC

Если использовать ~unless~ как особую форму при аппликативном порядке,
как предлагает Бен, то все будет работать правильно, поскольку в ифе
будут вычисляться только те ветки, которые будут соответствовать условию,
а не все подряд. С другой стороны, ~unless~  просто станет синтаксическим
сахаром для ифа.

Может возникнуть ситуация, когда нам не нужно будет вычислять аргументы
~unless~, то есть ~unless~ должна стать нестрогой процедурой по своим
аргументам. Например, если ~unless~ понадобится для работы над
структурами данных, хотя я не очень представляю, зачем нам может быть
нужна ~unless~ в этом случае.

~Упражнение 4.27.~
Допустим, мы вводим в ленивый интерпретатор следующее выражение:

#+BEGIN_SRC scheme
  (define count 0)

  (define (id x)
    (set! count (+ count 1))
    x)
#+END_SRC

Вставьте пропущенные значения в данной ниже последовательности действий и
объясните свои ответы:

#+BEGIN_SRC scheme
  (define w (id (id 10)))

  ;;; Ввод L-Eval:
  count
  ;;; Значение L-Eval:
  <вывод>
  ;;; Ввод L-Eval:
  w
  ;;; Значение L-Eval:
  <вывод>
  ;;; Ввод L-Eval:
  count
  ;;; Значение L-Eval:
  <вывод>

#+END_SRC

Рассмотрим, что произойдет при вводе ~(define w (id (id 10)))~.
Вызов  ~(id 10)~, переданный как аргумент, вычислен не будет, станет
санком. Так что при вызове ~id~ с таким аргументом, мы его же и вернем,
не вычисляя.

Так что:
#+BEGIN_SRC scheme
  (define w (id (id 10)))

  ;;Ввод:
  count
  ;; Вывод, поскольку санк вычислен не будет, присовение count стработает только 1 раз
  1

  ;; Ввод:
  w
  ;; Вывод, поскольку при вызове w санк, который она собой представляет, вычислится
  10

  ;;; Ввод:
  count
  ;; Вывод, поскольку раз вычислился и санк, то присваивание внутри id сработало второй раз.
  2

#+END_SRC

~Упражнение 4.28.~
~Eval~, передавая оператор в ~apply~, вычисляет его не при помощи ~eval~, а
через ~actual-value~, чтобы вынудить. Приведите пример, который показывает, что такое
вынуждение необходимо.

Оператор мы вычисляем сразу, чтоб понять, составная это процедура или
примитив. При этом нигде не сказано, что оператор не может быть санком. А
попытка применить аргументы к невычисленному санку обернется ошибкой.

Эта ситуация может возникнуть, есть оператор - это евычесленный аргумент
какой-то процедуры, который аон вернула.

Например:
#+BEGIN_SRC scheme
  (cons (lambda (x)
          (* x x))
        (lambda (y)
          (+ y y )) ......)
#+END_SRC

Если cons у нас нестрогая и интерпретатор у нас ленивый, то cons вообще не
нужно вычислять свои аргументы, чтоб составить из них список. Тем более,
что с точки зрения интерпретатора любое выражение - это список. То есть
для cons вообще нет никакой разницы, что представляет собой список на
самом деле: вызов процедуры, список чисел и т.д.

Теперь представляем себе, что полученный список процедур мы будем
применять к разным аргументам. А по факту у нас не список процедур, а
список санков и вычисление санка нужно вынудить. А еще при вычислении
санка мы можем получить новый санк, так что нужно будет вынудить все
санки до того, как мы получим оператор, который можно применить к
аргументам.

~Упражнение 4.29~.
Придумайте пример программы, которая, по Вашему мнению, будет работать
намного медленнее без мемоизации, чем с мемоизацией.

Рассмотрим, помимо
этого, следующую последовательность действий, в которой процедура ~id~
определена как в упражнении 4.27, а счетчик ~count~ начинает с 0.
Укажите, как будет выглядеть вывод в случае с мемоизирующим
интерпретатором и с немемоизирующим.

#+BEGIN_SRC scheme
  ;;меморизирующий
  (define (square x)
    (* x x))

  ;; Ввод L-Eval:
  (square (id 10))
  ;;; Значение L-Eval:
  100
  ;;; Ввод L-Eval:
  count
  ;;; Значение L-Eval:
  1 ;; потому что санк вычисляет один раз, соответственно, присваивание срабатывает 1 раз

#+END_SRC

При немеморизирующих санках вычисление ~(id 10)~, переданного как
аргумент ~square~, произойдет дважды, поэтому ~count~ будет = 2.

А вообще меморизация окажется дико полезна в циклах, где мы вычисляем
одно и то же с незначительными вариациями. К примеру:

#+BEGIN_SRC scheme
  (define (square x)
    (* x x))

  (define (test n arg)
    (if (< n 0)
        'ok
        (begin
        (display (square arg))
        (newline)
        (test (- n 1) arg))))

  (test 10 (id 10))
#+END_SRC

Без меморизации ~(id 10)~ будет вычислено 20 раз вместо одного. И это у
цикла только 10 итераций и процедура ~id~ сравнительно простая.

~Упражнение 4.30~
Пабло Э. Фект, бывший программист на языке C, беспокоится, что ленивый
интерпретатор не вынуждает выражения в последовательности, и оттого некоторые побочные
эффекты могут никогда не произойти. Поскольку ни у одного выражения
в последовательности, помимо конечного, значение не используется
(выражение стоит там только ради своего эффекта, например, чтобы
присвоить значение переменной или что-нибудь напечатать), у значения
такого выражения не может впоследствии быть применения, для которого его потребуется
вынудить (например, в качестве аргумента элементарной процедуры). Поэтому
П.Э. Фект считает, что при выполнении последовательности нужно все
выражения, кроме последнего, вынуждать. Он предлагает изменить
~eval-sequence~ из раздела 4.1.1 так, чтобы она вместо eval использовала actual-value:

#+BEGIN_SRC scheme
  (define (eval-sequence exps env)
    (cond ((last-exp? exps) (eval (first-exp exps) env))
          (else (actual-value (first-exp exps) env)
                (eval-sequence (rest-exps exps) env))))
#+END_SRC

а. Бен Битобор считает, что Пабло неправ. Он показывает ему процедуру
for-each из упражнения 2.23 — важный пример последовательности с
побочными эффектами:

#+BEGIN_SRC scheme
  (define (for-each proc items)
    (if (null? items)
        'done
         (begin (proc (car items))
                (for-each proc (cdr items)))))
#+END_SRC
Он утверждает, что интерпретатор из текста (с исходным eval-sequence)
правильно работает с этой процедурой:

#+BEGIN_SRC scheme
  (for-each (lambda (x) (newline) (display x))
            (list 57 321 88))

#+END_SRC

Объясните, почему Бен прав насчет поведения for-each.
Итак, побочные эффекты - это любое измениене окружения, объекта или файла
из-за вызова процедуры. Например, присваивание глобальной переменной
какое-то значение внутри процедуры - это побочный эффект процедуры.

Исходный вид ~eval-sequaence~:
#+BEGIN_SRC scheme
  (define (eval-sequence exps env)
    (cond ((last-exp? exps) (eval (first-exp exps) env))
          (else (eval (first-exp exps) env)
                (eval-sequence (rest-exps exps) env))))
#+END_SRC

Бен прав, потому что ~display~ внутри лямбды является примитивной процедурой,
следовательно, ее аргументы будут вычислены до вызова. В ленивом
интерпретаторе примитивы - строгие процедуры.

б. Пабло соглашается с Беном по поводу примера с for-each, но говорит,
что, предлагая изменить eval-sequence, он имел в виду другой тип
программ. Он определяет в ленивом интерпретаторе следующие две процедуры:

#+BEGIN_SRC scheme
  (define (p1 x)
    (set! x (cons x '(2)))
    x)

  (define (p2 x)
    (define (p e)
      e
      x)
    (p (set! x (cons x '(2)))))
#+END_SRC

Какие значения вернут (p1 1) и (p2 1) с исходной eval-sequence? Каковы
будут значения с изменением, которое предлагает Пабло?

C исходной ~eval-sequence~:
~(p1 1)~ вернет (1 2)
~(p2 1)~ вернет 1. Процедура ~p~ принимает аргумент ~e~, мы ей в
качестве аргумента передаем выражение ~(set! x (cons x '(2)))~, которое
является санком, поскольку интерпретатор ленивый, и  вычисляется не
сразу, а только внутри процедуры ~p~, когда мы возвращаем ~e~. Только вот
~eval~ санки вычислять не умеет, соответственно, присваивание не
сработает И ЗНАЧЕНИЕ ~x~ останется прежним.

С версией Пабло:
~(p1 1)~ вернет (1 2)
~(p2 1)~ вернет (1 2).
Внутри ~eval-sequence~ верссии Пабло вызывается
~actual-value~, которая вызывает процедуру ~force-it~ - она вынуждает
санк. Соответственно присваивание будет вычислено.

в. в. Пабло указывает также, что изменение eval-sequence, которое он
предлагает, не влияет на поведение примера из части a. Объясните, почему
это так.

Потому что внутри лямбды у нас используются примитивы, следовательно, их
аргументы в любом случае были бы вычислены. Теперь мы просто вычисляем
их, потому что они санки, а не потому что они аргументы примитивов.

г. Как, по-Вашему, нужно работать с последовательностями в ленивом
интерпретаторе? Что Вам нравится больше: подход Пабло, подход,
приведенный в тексте, или что-нибудь третье?

Подход пабло хорош, потому что используя ленивый интерпретатор, мы будем
постоянно натыкаться на санки и в последовательностях тоже, так что их
нужно вынуждать, чтоб они вычислились.

~Упражнение 4.31. разобраться~
Подход, принятый в этом разделе, нехорош тем, что вносит изменение в
Scheme, не сохраняя ее семантику. Было бы приятнее реализовать ленивые вычисления как
совместимое расширение (upward-compatible extension), то есть так, чтобы
обычные программы на Scheme работали как прежде.
Например, определение

#+BEGIN_SRC scheme
  (define (f a (b lazy) c (d lazy-memo))
    ...)
#+END_SRC

делало бы f процедурой от четырех аргументов, причем первый и третий
вычисляются при вызове процедуры, второй задерживается, а четвертый
задерживается и мемоизируется.
Таким образом, обыкновенные определения процедур будут задавать такое же
поведение, как в обычной Scheme, а добавление декларации ~lazy-memo~ к
каждому параметру каждой составной процедуры приведет к поведению, как у
ленивого интерпретатора, описанного в этом разделе. Разработайте и реализуйте
изменения, с помощью которых можно получить такое расширение Scheme. Вам
придется реализовать новые синтаксические процедуры для нового синтаксиса
~define~.
Кроме того, надо будет добиться, чтобы eval и apply определяли,
когда надо задерживать аргументы, и соответствующим образом задерживали и
вынуждали их. Наконец, придется обеспечить,чтобы вынуждение было с
мемоизацией или без оной, смотря по обстоятельствам.

Итак, если раньше мы отдельано реализовывали аппликативный порядок
вычислений и отдельно нормальный, то теперь нас просят реализовать
гибрид.

Главный финт - это вычислить сразу все аргументы, кроме тех, что
отложены. А те, что отложены, вычислить только перед их непосредственным
применением.
Значит, мы вычислим с помощью ~eval~ все, что не задержано и передадим
процедуру с аргументами, среди которых могут оказаться санки, в
~apply~. А apply перед применением процедуры к аргументам должна пройтись
по аргументам и вынудить те, что являются санками и только после этого
исполнить процедуру.

К тому же, у нас санки могут быть меморизированные, а могут быть и нет.
Процедура вынуждения для не меморизированного санка:

#+BEGIN_SRC scheme
  (define (force-it-not-memo obj)
    (if (thunk? obj)
        (actual-value (thunk-exp obj) (thunk-env obj))
        obj))
#+END_SRC

Механизм вынуждения санка с меморизацией:

#+BEGIN_SRC scheme
  (define (evaluated-thunk? obj)
    (tagged-list? obj 'evaluated-thunk))

  (define (thunk-value evaluated-thunk) (cadr evaluated-thunk))

  (define (force-it-memo obj)
    (cond ((thunk? obj)
           (let ((result (actual-value
                          (thunk-exp obj)
                          (thunk-env obj))))
             (set-car! obj 'evaluated-thunk)
             (set-car! (cdr obj) result)
                                          ; заменить exp на его значение
             (set-cdr! (cdr obj) '()) ; забыть ненужное env
             result))
          ((evaluated-thunk? obj)
           (thunk-value obj))
          (else obj)))
#+END_SRC

В мане обе процедуры вынуждения имеют название force-it, но поскольку
нужны нам обе, то воизбежание переопределения назовем их по-разному и
будем вызывать каждую в зависимости от ситуации.

Создадим предикаты и процедуры, который будут превращать аргументы в
санки того или иногт вида.

#+BEGIN_SRC scheme
  (define (tagged-list? exp tag)
    (if (pair? exp)
        (eq? (car exp) tag)
        false))

  ;; создает санк с меморизацией или без, в зависимости от аргумта tag
  (define (delay-it exp env tag)
    (list tag exp env))

  ;;проверяет, является ли санк меморизированным
  (define (memo-thunk? obj)
    (tagged-list? obj 'lazy-memo))

  ;; проверяет, является ли санк не меморизированным
  (define (not-memo-thunk? obj)
    (tagged-list? obj 'lazy))

  ;; задерживает аргумент, если пользователь хочет его задержать и возвращает как есть,
  ;; если пользователь задерживать аргумент не планирует
  (define (delay-arg? arg env)
    (cond ((not (pair? arg))
           arg)
           ((memo-thunk? (last-pair arg))
            (delay-it exp env 'lazy-memo))
           ((not-memo-thunk? (last-pair arg))
            (delay-it exp env 'lazy))
          (else arg)))

  ;; тесты
  (delay-arg? '((lambda (x)
                  (+ x x)) lazy) '(some-env))

  (delay-arg? '(lambda (x)
                 (+ x x)) '(some-env))

  (delay-arg? 1 '(some-env))
#+END_SRC

~delay-arg~ устроена таким образом, что если последняя пара переданного
аргумента - это символ lazt или lazy-memo, мы считаем, что пользователь
хочет задержать данный аргумент. В остальном случае мы возвращаем
аргумент в том виде, в котором его получили.

Данная процедура не рассматривает 2 аспекта:
- символами lazy и lazy-memo могут быть названы переменные (ну,
  вдруг). Надо бы проверять окружение на наличие этих символов, чтоб
  обедиться, что игде нет таких переменных, и если есть, выдывать
  ошибку.
- мы не учитываем, что пользователь может передать какой-то другой тэг
  для аргумента или написать опечататься.

Но поскольку у нас примитивная модель интерпретатора думаю, эти проблемы
можно опустить, и представить, что наши юзеры всегда точно знают, что
делают.

Теперь нам нужно встроить механизм упаковки аргументов в санки (если
этого хочет пользователь) в ~eval~.

Для этого мы изменим процедуру ~list-of-values~, которая собирает все
аргументы вызова процедуры в список перед тем, как будет вызван
apply. Мы не просто объединим все аргументы в список, а проверим, не
хочет ли пользователь задержать какие-то из них. И если да, то мы сначала
упакуем данные аргументы санки и только потом вклчим их в общий список
аргументов.

Пишем определение дефайна.
eval получает на вход определение. Срабатывает ветка ~definition?~ в
cond, вызывается ~eval-definition~ , которая должна вычислить определение:

#+BEGIN_SRC scheme
  (define (eval-definition exp env)
    (define-variable! (definition-variable exp)
      (eval (definition-value exp) env)
      env)
    'ok)
#+END_SRC

Мы берем имя. полученное из переданного выражения, и вычисляем значение
выражения и упаковываем все это вместе с окружением в новую
переменную. Если мы определяем процедуру,то имени присваивается лямбда с
указанными в определении аргументами.

#+BEGIN_SRC scheme
  (define (definition-value exp)
    (if (symbol? (cadr exp))
        (caddr exp)
        (make-lambda (cdadr exp)
                     (cddr exp))))
#+END_SRC

То есть определение раскроется так:

#+BEGIN_SRC scheme
  (define (f a (b lazy) c (d lazy-memo))
    ...)

  (define f
    (lambda (a (b lazy) c (d lazy-memo))
      <тело>))


  (define (f a (b lazy) c (d lazy-memo))
    ...)

  (define f
    (lambda (a b  c d))
      <тело>))
#+END_SRC

 Теперь надо понять, устраивает нас такое раскрытие или нет. По идее,
 должно быть как-то так:

#+BEGIN_SRC scheme
  (define (f a (b lazy) c (d lazy-memo))
    ...)

  (define f
    (lambda (a b c d))
      <тело>)

  ;; не сработает, потому что b и d сначала вычислятся, только потом вызовется лямбда,
  ;; и только после этого они станут санками. А если один из них бесконечный поток данных?
  ;; зациклимся до конца стека
  (define f
    (lambda (a b c d))
    (b lazy)
    (d lazy-memo)
    <тело>)

#+END_SRC

И при этом где-то надо хранить информацию, что перед вызовом лямбды
аргументы b и dнадо задержать указанными способами и передать в лямбду уже санками.



#+BEGIN_SRC scheme
  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((if? exp) (eval-if exp env))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((application? exp)
           (apply (eval (operator exp) env)
                  (list-of-values (operands exp) env)))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))

  (define (apply procedure arguments)
    (cond ((primitive-procedure? procedure)
           (apply-primitive-procedure procedure arguments))
          ((compound-procedure? procedure)
           (eval-sequence
            (procedure-body procedure)
            (extend-environment
             (procedure-parameters procedure)
             arguments
             (procedure-environment procedure))))
          (else
           (error
            "Неизвестный тип процедуры -- APPLY" procedure))))
#+END_SRC

Разберемся с изначальным синтаксисом ~define~. Он у нас различный, в зависимости от
того, объявляем мы процедуру или переменную.
Синтаксис для объявления переменной:
Обяъвление представляет собой список, который наинчается с define. Затем
идет символ, обозначающий имя переменной, затем выраение или число,
значение которых станет значеним переменной.
Синтексис для процедуры:
Тоже список, начинается с define. Затем идет подсписок, где первый
символ - имя процедуры, а остальные элементы - аргументы. Следующий
подсписок - это тело объявляемой процедуры.

Значит, мы модем определить, что если за символом define следует список -
мы объявляем процедуру. А иначе - переменную. В обоих случаях нам надо
будет определить,

~Упражнение 4.32.~
Приведите несколько примеров, которые показывают разницу между потоками
из главы 3.5.4 и «более ленивыми» списками, описанными в этом разделе. Как можно
воспользоваться этой дополнительной ленивостью?

Итак, у ранее описанных ленивых потоков задерживался только ~cdr~. Теперь
у них задерживает и ~car~, и ~cdr~, более того, то, что мы "вынудим"
какой-то элемент потока, совершенно не значит, что его значение
вычислится. Оно может быть обернуто в санк и будет вычисляться только
когда в нем возникнет прямая необходимость.

У нас было упражнение 3.80, в котором требовалось построить/симулировать
работу RLC-цепи. Так выглядело опрееление процедуры с потоками из главы
3:

#+BEGIN_SRC scheme
  (define (RLC R L C dt)
    (lambda (vC0 iL0)
      (define Li (integral (delay diL) iL0 dt))
      (define vC (integral (delay dvC) vC0 dt))
      (define dvC (scale-stream Li (exact->inexact (/ -1 C))))
      (define diL (add-streams (scale-stream Li (exact->inexact (/  (/ R -1) L)))
                               (scale-stream vC (exact->inexact (/ 1 L)))))
      (cons Li vC)
      ))
#+END_SRC

 А вот так будет выглядеть сейчас:

#+BEGIN_SRC scheme
  (define (RLC R L C dt)
    (lambda (vC0 iL0)
      (define Li (integral diL iL0 dt))
      (define vC (integral dvC vC0 dt))
      (define dvC (scale-stream Li (exact->inexact (/ -1 C))))
      (define diL (add-streams (scale-stream Li (exact->inexact (/  (/ R -1) L)))
                               (scale-stream vC (exact->inexact (/ 1 L)))))
      (cons Li vC)
      ))
#+END_SRC

Похожие изменения будут в упражнении 3.79.

Ранее нам было показано, что деление на процедуры и данные может быть
достаточно условным, и что процедуры можно представлять как
данные. Предположим, что у нас поток состоит из вызовов процедур. Внутри
этих процедур у нас динамически выделяется память, а так же предположим,
что они обладают побочными эффектами, например, меняют окружение из-за
присваивания. Если мы пользуемся потоками, показаными в главе три, то при
вычислении ~car~ потока мы уже не можем отсрочить выполнение вызова
процедуры, хотя, предположим, нам нужно само выражение, а не результат
его вызова. Тогда придется его дополнительно задерживать или же оформлять
вызовы процедур в виде заковчнных списков.

~Упражнение 4.33.~
Бен Битобор проверяет вышеописанную реализацию при помощи выражения
~(car '(a b c))~

К его большому удивлению, в ответ выдается ошибка. После некоторого
размышления он понимает, что «списки». которые получаются при чтении
кавычек, отличаются от списков, управляемых новыми определениями cons,
car и cdr.
Измените работу интерпретатора с закавыченными выражениями так, чтобы при
вводе списковых выражений в цикле управления получались настоящие
ленивые списки.

Новые определения cons, car и cdr:
#+BEGIN_SRC scheme
  (define (cons x y)
    (lambda (m) (m x y)))

  (define (car z)
    (z (lambda (p q) p)))

  ;;((lambda (m) (m x y)) (lambda (p q) p))

  (define (cdr z)
    (z (lambda (p q) q)))

  ;; эксперимент
  (define f (cons 1 2))
  (car f)
  (cdr f)

  (define (list-ref items n)
    (if (= n 0)
        (car items)
        (list-ref (cdr items) (- n 1))))

  (define (map proc items)
    (if (null? items)
        '()
         (cons (proc (car items))
               (map proc (cdr items)))))

  (define (scale-list items factor)
    (map (lambda (x) (* x factor))
         items))

  (define (add-lists list1 list2)
    (cond ((null? list1) list2)
          ((null? list2) list1)
          (else (cons (+ (car list1) (car list2))
                      (add-lists (cdr list1) (cdr list2))))))

  (define ones (cons 1 ones))

  (define integers (cons 1 (add-lists ones integers)))
#+END_SRC

Итак, проблема у Бена возникает потому, что новая версия cons возвращает
не список: она возвращает лямбду, которая принимает процедуру ~m~. И вот
уже в зависимости от процедуры мы увидим тот или иной результат. Поэтому
новый ~car~ на месте заковыченного списка ожидает увидеть на самом деле
лямбду, соответственно, все ломается.

Итак, при встрече заковыченного выражения в ~eval~ срабатывает ветка
~quoted?~ и вызывается вот эта процедура:

#+BEGIN_SRC scheme
  (define (text-of-quotation exp) (cadr exp))
#+END_SRC

Как мы видим, она просто возвращает выражение без ковычки. А нам нужно,
чтоб вызывался новый cons, да еще и неоднократно, если в выражении больше
двух элементов.

Немножно изменим eval так, чтоб при вызове text-of-quatation  в нее
передавалось и окружение. Это нужно, чтоб обратиться к eval если
переданное закавыченное выражение состоит из подпар (ну, вдруг).

Сначала мы составляем выражение, которое представляет собой вызов
вложенных друг в друга cons и только затем вычисляем его.

Есть очень важное дополнение: мы переопределили car, cons и cdr внутри
ленивого интерпретатора, т.е. внутри driver-loop. То есть в встроенном,
изначальном интерпретаторе у нас cons, car и cdr
стандартные. Соответственно, мы можем их использовать, чтоб проходиться
по списку, пока мы строим выражение, которое, будучи пропущенное через
eval и apply внутри ленивого интерпретатора, построит новое представление
списка. То есть у нас параллельно в двух интерпретаторах существуют два
разных представления cons, car и cdr и не пересекаются они потому, что у
каждого интерпретатора свое базовое окружение.

#+BEGIN_SRC scheme
  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp env))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((if? exp) (eval-if exp env))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((application? exp)
           (apply (actual-value (operator exp) env)
                  (operands exp)
                  env))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))

  (define (text-of-quotation exp env)
    (let ((result (cadr exp)))
      (if (pair? result)
          (eval (make-lst result) env)
          result)))

  (define (make-lst s)
    (if (null? s)
        '()
        (list 'cons
              (list 'quote (car s))
                          (make-lst (cdr s)))))
#+END_SRC

~Упражнение 4.34.~
Измените управляющий цикл интерпретатора так, чтобы ленивые пары и списки
печатались каким-либо разумным образом. (Как Вы собираетесь работать с бесконечными
списками)? Вероятно, понадобится также изменить представление ленивых
пар, чтобы при печати интерпретатор их распознавал и печатал особым образом.

Итак, нам нужно научить цикл печатать ленивые пары (пары, в которых cdr -
промис), списки (которые сейчас фактически являются вложенными лямбдами)
и бесконечные списки.

Основная проблема состоит в том, что с точки зрения driver-loop список -
это такая же процедура (лямбда), как и другие процедуры. Соответственно,
надо как-то указать, что вот эта процедура на самом деле список, а вот
эта - не список.


В мане нам сказано, что благодаря ленивому вычислению списки и
потоки-данных, которые мы проходили в главе 3, теперь одно и то же. И
благодаря переопределенным cons, car и cdr мы можем больше не делать
между ними разницы. Соответственно, любая пара теперь ленивая, поскольку
мы не вычисляем ее car и cdr до тех пор, пока они не понадобятся и любой
список у нас потенциально бесконечный, поскольку пока мы не вычислим cdr,
мы не узнаем, что в нем.

Основная проблема состоит в том, что с точки зрения driver-loop список -
это такая же процедура (лямбда), как и другие процедуры. Соответственно,
мы изменим представление пары. Данные функции надо вгрузить в стандартный
интерпретатор (если вгрузить внутри драфвер лупа, то list не
распознается), заnем обновить окружение ленивого интерпретатора.

#+BEGIN_SRC scheme
  (define (new-cons x y)
    (cons 'pair (lambda (m) (m x y))))

  (define (new-car z)
    ((cadr z) (lambda (p q) p)))

  (define (new-cdr z)
    ((cadr z) (lambda (p q) q)))

  (define (new-pair? exp)
    (tagged-list? exp 'pair))

  (define primitive-procedures
    (list (list 'cons cons)
          (list 'car new-car)
          (list 'cdr new-cdr)
          (list 'pair? new-pair?)
          (list 'null? null?)
          (list '= =)
          (list '/ /)
          (list '* *)
          (list 'display display)
          (list '+ +)
          (list '- -)
          ))

  (define the-global-environment (setup-environment))
#+END_SRC


#+BEGIN_SRC scheme
  (define (user-print object)
    (cond ((pair? object)
           (let ((pair (cadr object)))
           (display (list 'pair
                          (list (new-car pair))
                          '<promise>))))
          ((compound-procedure? object)
           (display (list 'compound-procedure
                          (procedure-parameters object)
                          (procedure-body object)
                          '<procedure-env>)))
          (else (display object))))


#+END_SRC

Не понимаю, почему не работает.

~Упражнение 4.35.~
Напишите процедуру ~an-integer-between~, которая возвращает целое число,
лежащее между двумя заданными границами. С ее помощью можно следующим образом
реализовать процедуру для поиска Пифагоровых троек, то есть троек чисел
(i, j, k) между заданными границами, таких, что i ≤ j и i^2 + j^2 = k^2 :

#+BEGIN_SRC scheme
  (define (a-pythagorean-triple-between low high)
    (let ((i (an-integer-between low high)))
      (let ((j (an-integer-between i high)))
        (let ((k (an-integer-between j high)))
          (require (= (+ (* i i) (* j j)) (* k k)))
          (list i j k)))))
#+END_SRC

Итак, новый интерпретатор (который нам пока не показали)
реализует поиск в глубину следующим образом:
при возможных вариантах выбора мы всегда выбираем самый первый вариант.
Если этот выбор приводит к неудаче, мы возвращаемся к точке
выбора  и выбираем второй вариант и т.д., пока либо мы не исчерпаем
варианты, либо не вернем какое-то выражение. Надо учитывать, что один
выбор может приводить к другим точкам выбора.

Пока что мы знаем о процедуре ~amb~ 2 вещи:
1. она инициирует поиск выборов в глубину, описанный выше
2. принимает 2 параметра: первый выбор и остальные.

Так что мы будем создавать всех возможных начений от нижней до верхней
границы, нижнюю границу будем передавать как первый выбор, а cdr
полученного списка значений как остальные возможные выборы.

#+BEGIN_SRC scheme
  (define (an-integer-between min max)
    (define (make-integers min max)
      (if (> min max)
          '()
          (cons min (make-integers (+ min 1) max))))
    (let ((integers (make-integers min max)))
      (amb (car integers) (cdr integers))))
#+END_SRC


~Упражнение 4.36.~
В упражнении 3.69 рассматривалась задача порождения потока всех
Пифагоровых троек, без всякой верхней границы диапазона целых чисел, в котором надо
искать. Объясните, почему простая замена ~an-integer-between~ на
~an-integer-starting-from~ в процедуре из упражнения 4.35
не является адекватным способом порождения произвольных Пифагоровых
троек.
Напишите процедуру, которая решает эту задачу. (Это значит, что Вам нужно написать
процедуру, для которой многократный запрос try-again в принципе способен
породить все Пифагоровы тройки.)

Отсутствие верхней границы означает, что нам нужны бесконечные потоки
чисел. То есть списки становятся потоками (не очень поняла, является ли
данный интерпретатор ленивым.. На всякий случай будем
считать, что нет)

В упражнении 3.69 мы создавали 3 бесконечных потока и перемешивали их таким образом,
чтоб тройки выходили "случайными": если бы мы пытались перемешать их
обычным способом, пытаясь поставить в пару каждым элементом первого
потока каждый элемент второго, то зависли бы навечно, поскольку первый
поток никогда не кончился бы. Здесь будет та же проблема, поскольку мы
будем двигаться по потокам "параллельно", поскольку всегда рассматриваем
все первые варианты как верные, затем вторые и т.д.
Так что нам надо не только породить 3 потока чисел, но и перемешать их между
собой. И вот уже оттуда выбирать чила.

#+BEGIN_SRC scheme
  ;; функция для перемешивания потоков
  (define (interleave s1 s2)
    (if (stream-null? s1)
        s2
        (cons-stream (stream-car s1)
                     (interleave s2 (stream-cdr s1)))))

  (define ones (cons-stream 1 ones))

  (define (add-streams s1 s2)
    (stream-map + s1 s2))

  (define integers (cons-stream 1 (add-streams ones integers)))

  ;; перемешиваем 3 потока в один
  (define interleave-integers
    (interleave (stream-cdr integers)
                (interleave integers (stream-cdr integers))))

  ;; получаем число "рандомно"
  (define (an-integer)
    (amb (stream-car interleave-integers)
         (stream-cdr interleave-integers)))

  ;; вид собранной процедуры
  (define (a-pythagorean-triple-between)
    ;; получили 3 числа
    (let* ((i (an-integer))
           (j (an-integer))
           (k (an-integer)))
      ;; добавили новое условие, что i <= j
      (require (and (<= i j)
                    (= (+ (* i i) (* j j)) (* k k))))
      (list i j k)))
#+END_SRC

~Упражнение 4.37~.
Бен Битобор утверждает, что следующий метод порождения Пифагоровых троек
эффективнее, чем приведенный в упражнении 4.35. Прав ли он?
(Подсказка: найдите, сколько вариантов требуется рассмотреть.)

#+BEGIN_SRC scheme
  (define (a-pythagorean-triple-between low high)
    ;; получаем числов внутри диапазона
    (let ((i (an-integer-between low high))
          ;; получаем максимально большой возможный квадрат числа в данном диапазоне
          (hsq (* high high)))
      (let ((j (an-integer-between i high)))
        ;; получаем сумму квадратом i и j
        (let ((ksq (+ (* i i) (* j j))))
          (require (>= hsq ksq))
          (let ((k (sqrt ksq)))
            (require (integer? k))
            (list i j k))))))
#+END_SRC

Да, Бен однозначно прав. Мы знаем, что пифагоровы тройки - это тройки,
где: i ≤ j и i^2 + j^2 = k^2, ищем мы эти тройки в заданных границах.
Мы знаем, что максимальное значение k^2 - это верхняя граница диапазона в
квадрате. Соответственно, сразу установив ее, мы можем сразу отмести
варианты i и j, суммы квадратов которых больше верхней границы в
квадрате. Если это условие совпадает -   k мы не ищем среди всех
возможных вариантов, а определяем как квадрат суммы уже известных i и j.
Таким образом мы ведем поиск в глубину по двум элементам i и j, вместо
трех: i, j и k.

~Упражнение 4.38.~
Измените процедуру ~multiple-dwelling~, отказавшись от требования, что Смит
и Флетчер живут не на соседних этажах. Сколько решений имеется у
измененной загадки?

Текст загадки:
Бейкер, Купер, Флетчер, Миллер и Смит живут на разных этажах пятиэтаж-
ного дома. Бейкер живет не на верхнем этаже. Купер живет не на первом
этаже. Флетчер не живет ни на верхнем, ни на нижнем этаже. Миллер жи-
вет выше Купера. Смит живет не на соседнем с Флетчером этаже. Флетчер
живет не на соседнем с Купером этаже. Кто где живет?

#+BEGIN_SRC scheme
  (define (distinct? items)
    (cond ((null? items) true)
          ((null? (cdr items)) true)
          ((member (car items) (cdr items)) false)
          (else (distinct? (cdr items)))))

  (define (multiple-dwelling)
    (let ((baker (amb 1 2 3 4 5))
          (cooper (amb 1 2 3 4 5))
          (fletcher (amb 1 2 3 4 5))
          (miller (amb 1 2 3 4 5))
          (smith (amb 1 2 3 4 5)))
      (require
       (distinct? (list baker cooper fletcher miller smith)))
      (require (not (= baker 5)))
      (require (not (= cooper 1)))
      (require (not (= fletcher 5)))
      (require (not (= fletcher 1)))
      (require (> miller cooper))
      ;; (require (not (= (abs (- smith fletcher)) 1)))  - убрали условие
      (require (not (= (abs (- fletcher cooper)) 1)))
      (list (list 'baker baker)
            (list 'cooper cooper)
            (list 'fletcher fletcher)
            (list 'miller miller)
            (list 'smith smith))))

  ;; все возможные варианты:
  ((baker 1) (cooper 2) (fletcher 4) (miller 3) (smith 5))
  ((baker 1) (cooper 2) (fletcher 4) (miller 5) (smith 3))
  ((baker 1) (cooper 4) (fletcher 2) (miller 5) (smith 3))
  ((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1))
  ((baker 3) (cooper 4) (fletcher 2) (miller 5) (smith 1)))
#+END_SRC

~Упражнение 4.39.~
Влияет ли порядок ограничений в процедуре multiple-dwelling на ответ?
Влияет ли он на время, необходимое для поиска ответа? Если Вы считаете, что он имеет
значение, то покажите, как можно ускорить программу, переупорядочив
ограничения. Если Вы считаете, что порядок значения не имеет, объясните,
почему.

Я думаю, что порядок ограничений не меняет ответа задачи, поскольку нам
нужно проверить их все, поэтому если какое-то из ограничений мы не
соблюли, мы об этом узнаем.
Но да, я думаю, что порядок ограничений может влиять на скорость.
Мы знаем, что каждый раз в ситуации выбора будем выбирать первый
указанный вариант, надеясь, что он верный. Если он таковым не окажется,
мы вернемся в точку выбора и выберем следующий. Соответственно, имеет
смысл первыми выставить ограничения, которые сообщают нам, что первый
выбор - не верный. В данном случае это "флетчер не живет на первом
этаже" и "купер не живет на первом этаже". Встретив два эти ограничения
сразу, мы должны будем тут же вернуться в точку выбора. Таким образом
сэкономим время.
Затем я бы поставила ограничение "миллер живет выше купера" и "смит и
флетчер живут не на соседних этажах" и "флетчер и купер живут не на
соседних этажах" и только после этого "бейкер не живет на верхнем этаже",
"флетчер не живет на верхнем этаже", поскольку они наименее вероятные,
поскольку чтоб их достигнуть, надо перебрать все остальные.

Получилось бы так:
#+BEGIN_SRC scheme
  (define (multiple-dwelling)
    (let ((baker (amb 1 2 3 4 5))
          (cooper (amb 1 2 3 4 5))
          (fletcher (amb 1 2 3 4 5))
          (miller (amb 1 2 3 4 5))
          (smith (amb 1 2 3 4 5)))
      (require
       (distinct? (list baker cooper fletcher miller smith)))
      (require (not (= cooper 1)))
      (require (not (= fletcher 1)))
      (require (> miller cooper))
      (require (not (= (abs (- smith fletcher)) 1)))
      (require (not (= (abs (- fletcher cooper)) 1)))
      (require (not (= baker 5)))
      (require (not (= fletcher 5)))
      (list (list 'baker baker)
            (list 'cooper cooper)
            (list 'fletcher fletcher)
            (list 'miller miller)
            (list 'smith smith))))
#+END_SRC

~Упражнение 4.40.~
Сколько возможных соответствий между людьми и этажами имеется в задаче о
проживании, если учитывать требование, что все живут на разных этажах, и если его не
учитывать? Крайне неэффективно порождать все возможные соответствия между
людьми и этажами, а затем полагаться на то, что поиск с возвратом отсечет
лишнее.
Например, большая часть ограничений зависит только от одной или двух
переменных, соответствующих людям, и их можно было бы проверять
раньше, чем этажи выбраны для всех действующих лиц. Напишите и
продемонстрируйте значительно более эффективную недетерминистскую
процедуру, которая бы решала задачу, порождая только те варианты, которые
еще не исключены благодаря предыдущим ограничениям. (Подсказка:
потребуется набор вложенных выражений let.)

Если у нас нет условия, что все жильцы проживают на разных этажах, то
число возможных комбинаций резко увеличивается.

Новый вариант будет выглядеть так:
#+BEGIN_SRC scheme
  (define (multiple-dwelling)
    (let ((baker (amb 1 2 3 4 5)))
      (require (not (= baker 5)))
      (let ((cooper (amb 1 2 3 4 5)))
        (require (not (= cooper 1)))
        (let ((fletcher (amb 1 2 3 4 5)))
          (require (not (= fletcher 1)))
          (require (not (= fletcher 5)))
          (let ((miller (amb 1 2 3 4 5)))
            (require (> miller cooper))
            (let ((smith (amb 1 2 3 4 5)))
              (require
               (distinct? (list baker cooper fletcher miller smith)))
              (require (> miller cooper))
              (require (not (= (abs (- smith fletcher)) 1)))
              (require (not (= (abs (- fletcher cooper)) 1)))
              (list (list 'baker baker)
                    (list 'cooper cooper)
                    (list 'fletcher fletcher)
                    (list 'miller miller)
                    (list 'smith smith))))))))
#+END_SRC

Второй вариант.
Есть идея, что если мы знаем ограничения заранее (а мы их знаем из текста
задачи), то некоторые варианты можно и не предлагать. Например, не имеет
смысла предлагать варианты всех этажей для Флетчера и затем проверять их с
первого по пятый, если мы знаем, что Флетчер не живет ни на первом, ни на
пятом.
УБрав некоторые варианты, мы уже можем не кодировать некоторые
ограничения.
#+BEGIN_SRC scheme
  (define (multiple-dwelling)
    ;; Купер не живет на 1 этаже
    (let ((cooper (amb 2 3 4 5))
          ;; а Миллер может быть только выше Купера
          (miller (amb 3 4 5)))
      (require (> miller cooper))
      ;; флетчер не живет ни на 1 ни на 5
      (let ((fletcher (amb 2 3 4))
            ;; Смит живет на любом этаже
            (smith (amb 1 2 3 4 5))
            ;; Бэйкер не живет на последнем
            (baker (amb 1 2 3 4)))
        ;; теперь вставляем оставшиеся ограничения
        (require
         (distinct? (list baker cooper fletcher miller smith)))
        (require (not (= (abs (- smith fletcher)) 1)))
        (require (not (= (abs (- fletcher cooper)) 1)))
          (list (list 'baker baker)
                        (list 'cooper cooper)
                        (list 'fletcher fletcher)
                        (list 'miller miller)
                        (list 'smith smith)))))
#+END_SRC

~Упражнение 4.41.~
Напишите процедуру для решения задачи о проживании на обычной Scheme

Текст загадки:
Бейкер, Купер, Флетчер, Миллер и Смит живут на разных этажах пятиэтаж-
ного дома. Бейкер живет не на верхнем этаже. Купер живет не на первом
этаже. Флетчер не живет ни на верхнем, ни на нижнем этаже. Миллер жи-
вет выше Купера. Смит живет не на соседнем с Флетчером этаже. Флетчер
живет не на соседнем с Купером этаже. Кто где живет?

Тут начинаешь понимать прелести недетерминистского
интерпретатора. Программа проучилась неэффективной.
#+BEGIN_SRC scheme
  (define (distinct? items)
    (cond ((null? items) true)
          ((null? (cdr items)) true)
          ((member (car items) (cdr items)) false)
          (else (distinct? (cdr items)))))

  (define (multiple-dwelling)
    (define (iter baker cooper fletcher miller smith)
      (display baker) (display cooper) (display fletcher)
      (display miller) (display smith) (newline)
      (cond ((<= cooper 1) (iter baker (+ cooper 1) fletcher miller smith))
            ((< smith 1) (iter baker cooper fletcher miller (+ smith 1)))
            ((< baker 1) (iter (+ baker 1) cooper fletcher miller smith))
            ((<= fletcher 1) (iter baker cooper (+ fletcher 1) miller smith))
            ((>= baker 5) (iter (- baker 1) cooper fletcher miller smith))
            ((>= fletcher 5) (iter baker cooper (- fletcher 1) miller smith))
            ((> miller 5) (iter baker cooper fletcher (- miller 1) smith))
            ((<= miller cooper) (iter baker (- cooper 1) fletcher (+ miller 1) smith))
            ((= (abs (- smith fletcher)) 1)
             (iter baker cooper (random  5) miller (random  6)))
            ((= (abs (- fletcher cooper)) 1)
             (iter baker (random  6) (random  5) miller smith))
            ((distinct? (list baker cooper fletcher miller smith))
             (list (list 'baker baker)
                   (list 'cooper cooper)
                   (list 'fletcher fletcher)
                   (list 'miller miller)
                   (list 'smith smith)))
            (else (iter (random  5) (random  6) (random  5) (random  6) (random  6)))))
    (iter (random  5) (random  6) (random  5) (random  6) (random  6)))
#+END_SRC
~Упражнение 4.42.~

Решите задачу «Лгуньи» (из Phillips 1934):
Пять школьниц писали экзаменационную работу. Им показалось, что их
родители чересчур интересовались результатом, и поэтому они решили, что каждая
девочка должна написать домой о результатах экзамена и при этом сделать одно
верное и одно неверное утверждение. Вот соответствующие выдержки из их писем:
Бетти: «Китти была на экзамене второй, а я только третьей».
Этель: «Вам будет приятно узнать, что я написала лучше всех. Второй была
Джоан».
Джоан: «Я была третьей, а бедная Этель последней».
Китти: «Я оказалась второй. Мэри была только четвертой».
Мэри: «Я была четвертой. Первое место заняла Бетти».

В каком порядке на самом деле расположились отметки девочек?

Нам известно:
- каждая девочка написала 2 утверждения
- одно из этих утверждения ложно, другое правдиво
- позиции девочек в рейтинге не повторяются

?:
- результат должен быть независим от порядка утверждений девочек в
  задачке

В качестве данных у нас утверждения.
#+BEGIN_SRC scheme
  (define (xor a b)
    ;; или первое утверждение НЕ правда, а второе тогда правда,
    ;; или второе утверждение НЕ правда, а первое тогда правда
    ;;( мы знаем, что одно из утверждений всегда true, а другое всегда false)
    (or (and (not a) b)
        (and (not b) a)))

  ;; если бетти не третья, то китти вторая (и наоборот)
  (define (betty-statement betty kitty)
    (xor (= betty 3) (= kitty 2)))

  ;; если этель не первая, то джоан - вторая (и наоборот)
  (define (ethel-statement ethel joan)
    (xor (= ethel 1) (= joan 2)))

  ;; если джоан не третья, то этель - пятая (и наоборот)
  (define (joan-statement joan ethel)
    (xor (= joan 3) (= ethel 5)))

  ;; если китти не вторая, то мэри - четвертая (и наоборот)
  (define (kitty-statement kitty mary)
    (xor (= kitty 2) (= mary 4)))

  ;; если мэри не четвертая, то бетти - первая
  (define (mary-statement mary betty)
    (xor (= mary 4) (= betty 1)))

#+END_SRC

Теперь у нас есть 5 утверждений, каждое из которых принимает 2 числовых
значения от 1 до 5.
Если в ~betty-statement~ будет передано 1 и 2 (Бетти первая, а Джоан -
вторая), то ~xor~ вернет #t - нам достаточно, чтоб только один операнд
~or~ дал #t. Таким образом получится, что утверждение "Джоан - вторая"
верно. Принцип сохранится для всех утверждений.

Теперь надо собрать все утверждения, прогнать через них разные значения,
собрать результаты и объединить их в список.

С недетерминистским интерпретатором:
#+BEGIN_SRC scheme
  (define (liers)
    (let ((betty (amb 1 2 3 4 5))
          (ethel (amb 1 2 3 4 5))
          (joan (amb 1 2 3 4 5))
          (kitty (amb 1 2 3 4 5))
          (mary (amb 1 2 3 4 5)))
      (require (distinct? (list betty ethel joan kitty mary)))
      (require (betty-statement betty kitty))
      (require (ethel-statement ethel joan))
      (require (joan-statement joan ethel))
      (require (kitty-statement kitty mary))
      (require (mary-statement mary betty))
      (list (list 'betty betty)
            (list 'ethel ethel)
            (list 'joan joan)
            (list 'kitty kitty)
            (list 'mary mary))))
#+END_SRC

Через обычную scheme:
#+BEGIN_SRC scheme
  (define prev-n #f)

  ;; создадим функцию, которая генерит случайные числа в заданном интервали
  ;; при этом мы следим, чтоб не выпадало подряд дважды одно и то же число
  (define (generate-number-interval min max)
    (let ((n (random (+ max 1))))
      (cond ((eq? prev-n n) (if (< n max)
                                (begin (set! prev-n (+ prev-n 1))
                                       (+ n 1))
                                (begin (set! prev-n (- prev-n 1))
                                       (- n 1))))
            ((< n min) (begin (set! prev-n min) min))
            (else (begin (begin (set! prev-n n) n))))))

  (define (liers)
    (define (iter betty ethel joan kitty mary)
      (if  (and (distinct? (list betty ethel joan kitty mary))
                (and (betty-statement betty kitty)
                     (ethel-statement ethel joan)
                     (joan-statement joan ethel)
                     (kitty-statement kitty mary)
                     (mary-statement mary betty)))
           (list (list 'betty betty)
                 (list 'ethel ethel)
                 (list 'joan joan)
                 (list 'kitty kitty)
                 (list 'mary mary))
           (iter (generate-number-interval 1 5)
                 (generate-number-interval 1 5)
                 (generate-number-interval 1 5)
                 (generate-number-interval 1 5)
                 (generate-number-interval 1 5))))
    (iter 1 2 3 4 5))
#+END_SRC


~Упражнение 4.43.~
Решите с помощью amb-интерпретатора следующую задачу:
У отца Мэри Энн Мур есть яхта, и у каждого из четверых его друзей
тоже. Эти четверо друзей — полковник Даунинг, мистер Холл, сэр Барнакл Худ и доктор
Паркер. У каждого из них тоже есть по дочери, и каждый из них назвал свою
яхту в честь дочери одного из своих друзей. Яхта сэра Барнакла называется
Габриэлла, яхта мистера Мура — Лорна, а у мистера Холла яхта Розалинда. Мелисса, яхта
полковника Даунинга, названа в честь дочери сэра Барнакла. Отец Габриэллы владеет
яхтой, названной в честь дочери доктора Паркера. Кто отец Лорны?

Попытайтесь написать программу так, чтобы она работала эффективно
(см. упражнение 4.40).
Кроме того, определите, сколько будет решений, если не указывается, что
фамилия Мэри Энн — Мур.

Итак, у нас есть 5 друзей: Даунинг, Холл, Худ, Мур и Паркер. У каждого из
них есть яхта, и имя яхты - это имя дочери кого-то из его друзей.
Известно:
- дочь Мура - Мэри, яхта - Лорна.
- яхта Даунинга - Мелисса
- дочь Худа - Мелисса, яхта - Габриэлла,
- яхта Холла - Розалинда
- отец Габриэллы владеет яхтой, которая названа в честь дочери Паркера

Неизвестены:
- отец Габриэллы
- отец Розалинды
- отец Лорны
- яхта и дочь Паркера

?:
- дочь Паркера - Розалинда, яхта - Мэри
- дочь Холла - Габриэлла
- дочь Даунинга - Лорна.

Отец Габриэллы - Холл, поскольку:
- имя его дочери мы не знаем
- Даунинг - не отец Габриэллы, поскольку сказано, что его яхта назыана в
  честь дочери Худа, а не Паркера
- имена дочерей остальных известны, кроме имени дочери Паркера.

Про реазизацию:
- На выходе мы должны получить списки из 3х имен, где первым будет идти
  имя одного из друзей, затем имя его дочери и потом имя его яхты
- исходные данные: каждому женскому имени присваиваем пару отец-хозяин
  яхты

Требования (негласные):
- имя дочери и имя яхты не повторяется у одного и того же друга:
  у отца Габриэллы яхта НЕ называется Габриэлла
- имена дочерей НЕ повторяются
- имена яхт НЕ повторяются

Реализация осуществлена согласно идее из второго варианта решения упр. 4.40
Исходим из идеи, что мы предлагаем ~amb~ только действительно возможные
варианты. Например, если нам известно, что дочь Мура - Мэри, а яхта -
Лорна, то мы сразу это установить и таким образом не писать явным образом
это ограничение + уберем лишние исследования вариантов для
интерпретатора.

#+BEGIN_SRC scheme
  (define (distinct? items)
    (cond ((null? items) true)
          ((null? (cdr items)) true)
          ((member (car items) (cdr items)) false)
          (else (distinct? (cdr items)))))

  (define (map fn args-list)
    (define (iter fn args-list result-list)
      (if (null? args-list)
          result-list
          (iter fn (cdr args-list) (append result-list (list (fn (car args-list)))))))
  (iter fn args-list'()))

  (define (require p)
    (if (not p) (amb)))

  (define daughter first)

  (define boat second)


  (define (daughters-and-boats)
    ;; дочь и яхта Мура известны, варианты ни к чему
    ;; теперь мы помним, что имя Мэри занято для дочери, а Лорна - для яхты
    (let ((moor (list 'mary 'lorna))
          ;; известна яхта Холла
          (hall (list (amb 'lorna 'gabrielle 'melissa)
                      'rosalinda))
          ;; известна яхта Даунинга
          (downing (list (amb 'lorna 'gabrielle 'rosalinda)
                         'melissa)))
      ;; яхта Худа известна, а имя дочери = яхта Даунингаа
      (let ((hood (list (second downing) 'gabrielle))
            ;; дочь и яхта Паркера неизвесты, но:
            ;; для яхт заняты все имена кроме Мэри
            (parcker (list (amb 'lorna 'gabrielle 'rosalinda)
                           'mary)))
        (let ((gabrielle-father (amb hall downing parcker))
              (lorna-father (amb hall downing parcker)))
        ;; -- осуществляем все оставшиеся ограничения--
        ;; имена дочерей у мужчин не повторяются
        (require
         (distinct? (map (lambda (x)
                           (daughter x)) (list downing moor hood parcker hall))))
        ;; имена яхт не повторяются
        (require
         (distinct? (map (lambda (x)
                           (boat x)) (list downing moor hood parcker hall))))
        (require (eq? (daughter gabrielle-father) 'gabrielle))
        (require (eq? (daughter lorna-father) 'lorna))
        (require (distinct? lorna-father))
        (require (distinct? gabrielle-father))
        (require (eq? (daughter parcker)
                      (boat gabrielle-father)))

        (list (list 'moor's 'daughter: (daughter moor) 'boat: (boat moor))
              (list 'hall's 'daughter: (daughter hall) 'boat: (boat hall))
              (list 'downing's 'daughter: (daughter downing) 'boat: (boat downing))
              (list 'hood's 'daughter: (daughter hood) 'boat: (boat hood))
              (list 'parcker's 'daughter: (daughter parcker) 'boat: (boat parcker)))
        ))))

#+END_SRC

Если не говорить, что Мур - отец Мэри, то у Даунинга, Паркера и Холла
появляется одно имя для Дочери, а у Мура - сразу 4 возможных. При этом
количество возможных комбинаций вырастает больше, чем
экспоненциально. Думаю, если раньше это был !3, то теперь это !4.

~Упражнение 4.44.~
В упражнении 2.42 описывалась «задача о восьми ферзях», в которой
требуется расставить на шахматной доске восемь ферзей так, чтобы ни один
не бил другого. Напишите недетерминистскую программу для решения этой задачи.

Один из способов решать эту задачу состоит в том, чтобы идти поперек
доски, устанавливая по ферзю в каждой вертикали. После того, как k − 1
ферзя мы уже разместили, нужно разместить k-го в таком месте, где он не
бьет ни одного из тех, которые уже находятся на доске. Этот подход можно
сформулировать рекурсивно: предположим, что мы уже породили
последовательность из всех возможных способов разместить k − 1 ферзей на
первых k − 1 вертикалях доски. Для каждого из этих способов мы порождаем
расширенный набор позиций, добавляя ферзя на каждую горизонталь k-й
вертикали. Затем эти позиции нужно отфильтровать, оставляя только те, где
ферзь на k-й вертикали не бьется ни одним из остальных. Продолжая этот
процесс, мы породим не просто одно решение, а все решения этой задачи.

Воспользумся наработками из упражнения 2.42
#+BEGIN_SRC scheme
  (define (queens board-size)
    (define (queen-cols k)
      (if (= k 0)
          (list empty-board)
          (map (lambda (rest-of-queens)
                 ;; произвольным образом выбираем номер от 1 до максимума и прсоединяем его
                 ;; к остальным взможным вариантам
                 (let ((new-board (adjoin-position (an-element-of
                                                    (enumerate-interval 1 board-size))
                                                   rest-of-queens)))
                   ;; проверяем, пересекается ли k с каким-либо из вариантов
                   (require (safe? new-board))
                   ;; если нет, возвращаем полученные варианты
                   ;; иначе amb вернется назад и будет пробовать остальные варианты
                   new-board))
               (queen-cols (- k 1)))))
    (queen-cols board-size))

  (define (adjoin-position new-row rest-of-queens)
    (cons new-row rest-of-queens))

  (define empty-board
    (list))

  ;; проверяем, занимает ли какой-то ферзь дигональ или вертикаль других ферзей
  (define (safe? k positions)
    (not (or (= k (car positions)) (= k (cdr positions)))))
#+END_SRC


~Упражнение 4.45.~
Согласно заданной выше грамматике, следующее предложение можно
проанализировать пятью различными способами: The professor lectures to
the student in the class with the cat («Профессор читает лекцию студенту
в аудитории с кошкой»). Покажите эти пять разборов и объясните разницу
в оттенках значения между ними.

Заданная грамматика:
#+BEGIN_SRC scheme
  (define nouns '(noun student professor cat class))
  (define verbs '(verb studies lectures eats sleeps))
  (define articles '(article the a))
  (define prepositions '(prep for to in by with))
  ;;сюда зпишем весь ввод
  (define *unparsed* '())

  ;; запускает парсинг ввода и возвращает результат парсинга
  (define (parse input)
    (set! *unparsed* input)
    (let ((sent (parse-sentence)))
      (require (null? *unparsed*))
      sent))

  ;; принимает список слов и ищет среди этого списка первое слово из нераспарсенных
  (define (parse-word word-list)
    (require (not (null? *unparsed*)))
    (require (memq (car *unparsed*) (cdr word-list)))
    ;; если нашел, то выкидывает это слово из списка нераспарсенных
    (let ((found-word (car *unparsed*)))
      (set! *unparsed* (cdr *unparsed*))
      ;; соединяет слово с тегом (какая это часть речи) и возвращает
      (list (car word-list) found-word)))

  ;; парсим словосочетание предлог + существительное
  (define (parse-prepositional-phrase)
    (display "parse-prepositional-phrase")
    (newline)
    (list 'prep-phrase
           (parse-word prepositions)
           (parse-noun-phrase)))

  ;; парсим предложение подлежащие + сказуемое
  (define (parse-sentence)
    (list 'sentence
           (parse-noun-phrase)
           (parse-verb-phrase)))

  ;; парсим глагол (может оказаться как одним словом, так и с предлогом)
  (define (parse-verb-phrase)
    (define (maybe-extend verb-phrase)
      (display "parse-verb-phrase")
      (newline)
      (display verb-phrase)
      (newline)
      (amb verb-phrase
           (maybe-extend (list 'verb-phrase
                                verb-phrase
                                (parse-prepositional-phrase)))))
    (maybe-extend (parse-word verbs)))

  ;; парсинг существительных с артиклями
  (define (parse-simple-noun-phrase)
    (list 'simple-noun-phrase
           (parse-word articles)
           (parse-word nouns)))

  ;; парсинг существительных в связке с другими существительными и предлогами
  (define (parse-noun-phrase)
    (define (maybe-extend noun-phrase)
      (display "parse-noun-phrase")
      (newline)
      (display noun-phrase)
      (newline)
      (amb noun-phrase
           (maybe-extend (list 'noun-phrase
                               noun-phrase
                               (parse-prepositional-phrase)))))
    (maybe-extend (parse-simple-noun-phrase)))
#+END_SRC

"The professor lectures to the student in the class with the cat"
Все это предложение попадает в  *unparsed*, затем мы вызываем
~parse-sentence~. ~parse-sentence~ представляет из себя вызов ~parse-noun-phrase~
и ~parse-verb-phrase~. ~parse-noun-phrase~ распарсит все существительные
с их предлогами, а ~parse-verb-phrase~ распарсит все глаголы с их
предлогами.

#+BEGIN_SRC scheme
  ;; профессор с кошкой читают лекцию студенту в классе
  (sentence (simple-noun-phrase (article the)
                                (noun professor))
            (verb-phrase
             (verb-phrase
              (verb-phrase
               (verb lectures)
               (prep-phrase (prep to)
                            (simple-noun-phrase (article the) (noun student))))
              (prep-phrase (prep in) (simple-noun-phrase (article the) (noun class))))
             (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))))

  ;; профессор читает лекцию  в классе кошкой студенту
  (sentence (simple-noun-phrase (article the) (noun professor))
            (verb-phrase
             (verb-phrase
              (verb lectures)
              (prep-phrase (prep to)
                           (simple-noun-phrase (article the) (noun student))))
             (prep-phrase (prep in)
                          (noun-phrase
                           (simple-noun-phrase (article the) (noun class))
                           (prep-phrase (prep with)
                                        (simple-noun-phrase (article the) (noun cat)))))))

  ;; профессор с кошккой (типа на руках) читает лекцию студенту в классе
  (sentence (simple-noun-phrase (article the) (noun professor))
            (verb-phrase
             (verb-phrase
              (verb lectures)
              (prep-phrase (prep to)
                           (noun-phrase
                            (simple-noun-phrase (article the) (noun student))
                            (prep-phrase (prep in)
                                         (simple-noun-phrase (article the) (noun class))))))
             (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))))

  ;; профессор читает лекцию студенту  с кошкой (типа кошка на руках у студента) в классе
  (sentence (simple-noun-phrase (article the) (noun professor))
            (verb-phrase
             (verb lectures)
             (prep-phrase (prep to)
                          (noun-phrase
                           (noun-phrase
                            (simple-noun-phrase (article the) (noun student))
                            (prep-phrase (prep in)
                                         (simple-noun-phrase (article the) (noun class))))
                           (prep-phrase (prep with)
                                        (simple-noun-phrase (article the) (noun cat)))))))

  ;; профессор читает лекцию студенту в классе, где есть кошка
  (sentence (simple-noun-phrase (article the) (noun professor))
            (verb-phrase
             (verb lectures)
             (prep-phrase (prep to)
                          (noun-phrase
                           (simple-noun-phrase (article the) (noun student))
                           (prep-phrase (prep in)
                                        (noun-phrase
                                         (simple-noun-phrase (article the)
                                                             (noun class))
                                         (prep-phrase (prep with)
                                                      (simple-noun-phrase (article the)
                                                                          (noun cat)))))))))
#+END_SRC

~Упражнение 4.46.~
Интерпретаторы в разделах 4.1 и 4.2 не определяют, в каком порядке
вычисляются операнды при вызове процедуры. Мы увидим, что
amb-интерпретатор вычисляет их слева направо. Объясните,
почему программа разбора не стала бы работать, если бы операнды
вычислялись в каком-нибудь другом порядке.

Нам в предложении важен порядок слов (особенно в английском
языке), поэтому и парсить слова следует в том порядке, в котором их
ввели.
К тому же, различные функции парсинга ожидают увидеть определенные
части речи в определенном месте разбираемого предложения. Если мы анализируем
аргументы в другом порядке, то нужных частей речи может просто не
оказаться на месте, соответственно, мы не распарсим предложение.

К примеру, если у нас целиком не распарсено 'the cat sleeps', а мы
сначала вызываем вот эту функцию:

#+BEGIN_SRC scheme
  (define (parse-sentence)
    (list 'sentence
           (parse-noun-phrase)
           (parse-verb-phrase)))
#+END_SRC

и сначала сработает парсиинг глагола, то мы ничего не найдем: the -
значится в списке артиклей, попытка найти его в списке глаголов сфейлится
и мы ничего не распарсим.
Кстати говоря, данная программа, даже используя вычисление слева направо,
не распарсит предложение а-ля мастер Йода "чувствую силу в тебе я",
программа ожидает увидеть в начале предложения подлежащее, как в любом
нормальном предложении английского языка.


~Упражнение 4.47.~
Хьюго Дум говорит, что поскольку глагольная группа — это либо глагол,
либо глагольная группа плюс предложная группа, было бы намного
естественнее  определить процедуру parse-verb-phrase так
(и то же сделать для именных групп):
#+BEGIN_SRC scheme
  (define (parse-verb-phrase)
    (amb (parse-word verbs)
         (list 'verb-phrase
                (parse-verb-phrase)
                (parse-prepositional-phrase))))

#+END_SRC

Работает ли этот вариант? Изменится ли поведение программы, если мы
поменяем местами выражения в amb?

Исходный вид parse-verb-phrase:
#+BEGIN_SRC scheme
  (define (parse-verb-phrase)
    (define (maybe-extend verb-phrase)
      ;; аmb получает на вход первый глагол из распарсенных и
      ;; список, который вернет рекурсивный вызов
      (amb verb-phrase
           (maybe-extend (list 'verb-phrase
                                verb-phrase
                                (parse-prepositional-phrase)))))
    ;; пытаемся распарсить первое слово из оставшихся и думаем, что это слово - глагол
    ;; затем полученный глагол как параметр
    (maybe-extend (parse-word verbs)))

  (define (parse-word word-list)
    (require (not (null? *unparsed*)))
    (require (memq (car *unparsed*) (cdr word-list)))
    (let ((found-word (car *unparsed*)))
      (set! *unparsed* (cdr *unparsed*))
      (list (car word-list) found-word)))
#+END_SRC

Я думаю, что вариант Хьюго будет работать не совсем
правильно. parse-word вызванный с verbs (списком глаголов) будет пытаться
найти текущее слово в списке глаголов. Если оно там есть, то мы получим
на выходе ('verb какой-то глагол). Один вызов ~parse-word~ = один найденный
(или нет) глагол. В исходном виде ~parse-verb-phrase~ ~parse-word~ будет
вызвана 1 раз и результат ее вызова - найденный глагол - будет передан в
~maybe-extend~ как параметр, соответственно, если в ходе аналища мы
придем к выводу, что распарсенный глагол - это глагол с предлогом и его
надо парсить дальше, мы будем парсить тот же самый глагол, поскольку он
является нашим параметром ~verb-phrase~.

Теперь смотрим, что делает Хьюго. Он обходится без внутренней функции,
если первый вариант, переданный ~amb~ не сработает - результат
~parse-word~ - то мы вызовем
рекурсивно ~parse-verb-phrase~. Что происходит внутри рекурсивного
вызова? Правильно, еще один вызов amb, первым вариантом выбора которого
становится результат вызова ~parse-word~ . Это уже второй вызов, а
значит, мы проанализировали уже следующий нераспарсенный глагол. Таким
образом первый мы так и не распарсили правильно. Более того, мы не сможем
распарсить ни один глагол с препозицией правильно, пока не достигнем дна
от рекурсивного вызова ~parse-verb-phrase~, то есть нам надо, чтоб у нас
как минимум кочились все нераспарсенные слова. А среди нераспарсенных у
нас и предлоги к первому глаголу, которых, естесвенно, не будет в списке
глаголов, то есть весь парсинг провалится.

Если поменять местами выражения в вызове ~amb~, т.е. по умолчанию
считать, что все глаголы с препозициями, а если нет - без них, ситуация
несколько улучшится, но только при условии, что мы парсим глагол с
препозицией. Если нет, то отработка остальных вариантов повлечет за собой
новые рекурсивные вызовы ~parse-verb-phrase~ и дальше мы легко можем
попасть в сценарий, описанный выше, когда не можем распарсить ничего.

К тому же способ Хьюго не учитывает, что у нас может быть не один глагол
или же могут быть больше одной связги глагола с чем-либо. Мы не будем
рекурсивно проходить по этоя глаголольной связке, пока не наткнемся на
существительное.

~To Do! Упражнение 4.48.~
Дополните описанную выше грамматику так, чтобы она могла работать с более
сложными предложениями. Например, можно позволить именным и глагольным
группам включать прилагательные и наречия, или же можно обрабатывать
сложные предложения.

Дополним грамматику прилагательными и наречиями.

- добавляем список прилагательных
- добавляем функцию парсинга словосочетания прилагательное +
  существительное ~parse-adj-phrase~. ~parse-adj-phrase~ пробует
  распарсить первое слово как прилагательное и если за ним больше ничего
  не следует, то так его и вернет. Такое может получиться, если у нас
  предложение звучит как "Sky is blue". Если же этот вариант не подошел,
  ищем дальше. У нас может быть более одного прилагательного, например.

#+BEGIN_SRC scheme
  ; добавлем список прилагательных
  (define adjectives '(adj big small white))

  (set! *unparsed* (cdr *unparsed*))

  (set! *unparsed* '(big small white cat))

  (set! *unparsed* '(lectures sleeps))
  (set! *unparsed* '())
  ;; добавляем функцию парсинга для прилагательного в связке с существительным
  (define (parse-adj-phrase)
    (define (maybe-extend adj-phrase)
      ;; (display adj-phrase)
      ;; (newline)
      (amb adj-phrase
           (maybe-extend (list 'adj-noun-phrase
                                adj-phrase
                                (parse-simple-adj-noun)
                               ))))
    (maybe-extend (parse-word adjectives)))

  ;; усовершенствуем парсинг простой именной группы так, чтоб в связке с существительным
  ;; могло идти прилагательное
  (define (parse-simple-noun-phrase)
    (list 'simple-noun-phrase
          (parse-word articles)
          (parse-adj-phrase)))

  (define (parse-simple-noun-phrase)
    (list 'simple-noun-phrase
          (parse-word articles)
          (parse-simple-adj-noun)))

  ;; парсинг прилагательное + существительное
  (define (parse-simple-adj-noun)
    (list 'simple-adj-noun-phrase
          (parse-word adjectives)
          (parse-word nouns)))

  (define (parse-sentence)
    (list 'sentence
          (parse-noun-phrase)
          (parse-verb-phrase)))


  (define (parse-adj-phrase)
      (list 'adj-noun-phrase
            (parse-simple-adj-noun))

                               (parse-simple-adj-noun)
                               ))))
    (maybe-extend (parse-word adjectives)))
#+END_SRC

Теперь добавляем наречия. Рассчитываем, что наречие может идти либо сразу
после глагола, либо не идет вообще.

То есть "профессор говорит громко" наша система распознает, а "профессор
сказал студенту громко" - уже нет.

К тому же нам надо соединить это с поиском дальнейших связок
- вводим список наречий
- вводим функцию парсинга наречия ~parse-adverb~
Она может распознавать как единичные наречия, так и наречия с дальнейшими
"продолжениями", т. е. "профессор сказал громко студенту....", т.е. после
нахождения наречия возможен поиск предлогов и обстоятельств.
- изменим ~parse-verb-phrase~, чтоб включить в нее ~parse-adverb~, так мы
  будем искать не только обстоятельства, но и наречия в связке с
  глаголами.

#+BEGIN_SRC scheme
  ; добавлем список наречий
  (define adverbs '(adv slowly loudly))


  ;; добавляем функцию наречия (возможно с дальнейшими связками)
  (define (parse-adverb)
    (define (maybe-adverb-with-prep adverb-phrase)
      (amb adverb-phrase
           (maybe-adverb-with-prep
            (list 'adverb-phrase
                  adverb-phrase
                  (parse-prepositional-phrase)))))
    (maybe-adverb-with-prep (parse-word adverbs)))

    (define (maybe-extend adj-phrase)
      (amb verb-phrase
           (maybe-extend (list 'verb-phrase
                               verb-phrase
                               (parse-word nouns)
                               ))))
    (maybe-extend (parse-word verbs)))

  (define (parse-verb-phrase)
    (define (maybe-extend verb-phrase)
      (amb verb-phrase
           (maybe-extend (list 'verb-phrase
                               verb-phrase
                               (parse-adverb)))))
    (maybe-extend (parse-word verbs)))
#+END_SRC

~Упражнение 4.49.~
Лизу П. Хакер больше интересует не анализ предложений, а их
порождение. Она замечает, что если изменить процедуру ~parse-word~ так,
чтобы она игнорировала «входное предложение», всегда заканчивалась
успехом и порождала подходящее слово, мы сможем использовать те же
программы, которые мы написали для анализа, для порождения
предложений. Реализуйте идею Лизы и покажите первые пять-шесть
порожденных предложений.

Это требует иного подхода, фактически это означает, что мы не анализируем
входное предложение, а предлагаем свои варианты. Подозреваю, что походим
образом работают подсказки при вводе в Т9 или переводчиках, погда
пользователю предлагаются разные слова на выбор после того, как он ввел
текущее слово. ТО есть пока юзер вводит слово "быстро", Т9 уже предлагает
ему варинты "бегать" "прыгать" "ходить".

Соответственно, нам надо сформулировать новые правила
грамматики для такой процедуры.
К примеру:
- предложение всегда начинается с артикля
- после артикля всегда следует существительное
- после существительного всегда следует глагол.

Возьмем этот мини-вариант, который будет наиболее просто реализовать.
Чтоб слова каждый раз выбирались рандомно, а не генерилось постоянно одно
и то же предложение, мы будем обращаться к элементам списков с частями
речи по индексу, а индекс будем псевдорандомно генерить.

Проверено через обычную схему.
~generate-number-interval~ взята из упражнения "Лгуньи".
#+BEGIN_SRC scheme
  (define nouns '(noun student professor girl dog cat class))
  (define verbs '(verb studies lectures eats sleeps))
  (define articles '(article the a an))

  ;; доступ к элементу списка по его индексу
  (define (nth n lst)
    (if (= n 0)
        (car lst)
        (nth (- n 1) (cdr lst))))

  (define prev-n #f)

  ;; создадим функцию, которая генерит случайные числа в заданном интервали
  ;; при этом мы следим, чтоб не выпадало подряд дважды одно и то же число
  (define (generate-number-interval min max)
    (let ((n (random (+ 1 max))))
      (cond ((eq? prev-n n) (if (< n max)
                                (begin (set! prev-n (+ prev-n 1))
                                       (+ n 1))
                                (begin (set! prev-n (- prev-n 1))
                                       (- n 1))))
            ((< n min) (begin (set! prev-n min) min))
            (else (begin (begin (set! prev-n n) n))))))

  (define (parse-word)
    (define (make-phrase phrase)
      (cond ((null? phrase) (make-phrase (list (list 'article
                                                     (nth (generate-number-interval 0 2)
                                                          (cdr articles))))))
            ((eq? (caar (last-pair phrase)) 'article)
             (make-phrase (append phrase (list (list 'noun
                                                     (nth (generate-number-interval 0 5)
                                                                 (cdr nouns)))))))
            ((eq? (caar (last-pair phrase)) 'noun)
             (make-phrase (append phrase
                                  (list (list 'verb
                                              (nth (generate-number-interval 0 4)
                                                   (cdr verbs)))))))
            (else phrase)))
    (make-phrase '()))


  ;; (parse-word)
#+END_SRC

 ~amb-интерпретатор~

Заливаем все из метациклического и анализирующего интерпретаторов + код
ниже

Некоторые вещи из прошлых интерпретаторов нам не понадобятся или они
переопределяются, но проще залить все, чем выиискивать, что действительно
нужно.

#+BEGIN_SRC scheme
  ;; это выражение для amb-процедуры?
  (define (amb? exp) (tagged-list? exp 'amb))

  ;; список возможных выборов
  (define (amb-choices exp) (cdr exp))

#+END_SRC

#+BEGIN_SRC scheme
  ;; анализирует полученное выражение и применяет получившуюся в результате анализа
  ;; исполнительную процедуру к окружению и двум продолжениям
  (define (ambeval exp env succeed fail)
    ((analyze exp) env succeed fail))

  (define (analyze exp)
    (cond ((self-evaluating? exp)
           (analyze-self-evaluating exp))
          ((quoted? exp) (analyze-quoted exp))
          ((variable? exp) (analyze-variable exp))
          ((assignment? exp) (analyze-assignment exp))
          ((definition? exp) (analyze-definition exp))
          ((let? exp) (analyze (let->combination exp)))
          ((if? exp) (analyze-if exp))
          ((lambda? exp) (analyze-lambda exp))
          ((begin? exp) (analyze-sequence (begin-actions exp)))
          ((cond? exp) (analyze (cond->if exp)))
          ;; добавляем анализ для amb
          ((amb? exp) (analyze-amb exp))
          ((application? exp) (analyze-application exp))
          (else
           (error "Неизвестный тип выражения -- ANALYZE" exp))))

  (define (let? exp)
    (tagged-list? exp 'let))

  (define (let->combination exp)
    (define (get-all-params exp)
      (if (null? exp)
          '()
          (cons (caar exp) (get-all-params (cdr exp)))))
    (define (get-all-exps exp)
      (if (null? exp)
          '()
          (cons (cadar exp) (get-all-exps (cdr exp)))))
    (append (list (make-lambda (get-all-params (cadr exp))
                               (cddr exp)))
            (get-all-exps (cadr exp))))

  (define (distinct? items)
    (cond ((null? items) true)
          ((null? (cdr items)) true)
          ((member (car items) (cdr items)) false)
          (else (distinct? (cdr items)))))

  (define (map fn args-list)
    (define (iter fn args-list result-list)
      (if (null? args-list)
          result-list
          (iter fn (cdr args-list) (append result-list (list (fn (car args-list)))))))
    (iter fn args-list'()))

  (define (require p)
    (if (not p) (amb)))

  (define (analyze-or exp)
    (lambda (env)
      (display "analyze-or")
      (newline)
      (display exp)
      (newline)
      (eval-or exp env)))

  (define (analyze-and exp)
    (lambda (env)
      (eval-and exp env)))

  ;; анализ самовычисляющегося выражения
  ;; передаем успешному продолжению выражение и продолжение неудачи и вычисляем
  ;; продолжения успеха в имеющемся окружении
  (define (analyze-self-evaluating exp)
    (lambda (env succeed fail)
      (succeed exp fail)))

  ;; анализ заковыченного выражения
  ;; аналогично самовычисляющемуся, только мы передаем не само заковыченное выражение, а
  ;; только его "текст"
  (define (analyze-quoted exp)
    (let ((qval (text-of-quotation exp)))
      (lambda (env succeed fail)
        (succeed qval fail))))

  ;; анализ поиска переменной
  ;; передаем в успешное продолжение результат от вызова lookup-variable-value, которая
  ;; должна найти нам переменную. Если не найдет, то получим ошибку и никакие другие варианты
  ;; рассматривать больше не будем - прогер ошибся и использует несуществующую переменную
  (define (analyze-variable exp)
    (lambda (env succeed fail)
      (succeed (lookup-variable-value exp env)
               fail)))

  ;; анализ лямбд
  (define (analyze-lambda exp)
    ;; получаем параметры
    (let ((vars (lambda-parameters exp))
          ;; запускаем анализ тела лямбды
          (bproc (analyze-sequence (lambda-body exp))))
      (lambda (env succeed fail)
        ;; передаем в успешное продолжение созданную процедуру и продолжение неудачи
        (succeed (make-procedure vars bproc env)
                 fail))))

  (define (analyze-if exp)
    ;; анализируем предикат и ветки
    (let ((pproc (analyze (if-predicate exp)))
          (cproc (analyze (if-consequent exp)))
          (aproc (analyze (if-alternative exp))))
      ;; пинимает на вход окружение и 2 продолжения
      (lambda (env succeed fail)
        ;; передаем предикату окружение и новые продолжения
        (pproc env
               ;; новое продолжение успеха
               ;; получает на вход значение предиката и второе продолжение неудачи
               (lambda (pred-value fail2)
                 ;; если предикат true
                 (if (true? pred-value)
                     ;; передаем ветке true изначальное продолжение успеха
                     ;; и новое продолжение неудачи
                     (cproc env succeed fail2)
                     ;; передаем ветке false то же самое
                     (aproc env succeed fail2)))
               ;; продолжение неудачи при вычислении предиката
               fail))))

  ;; анализируем последовательности
  (define (analyze-sequence exps)
    ;; исполняет выражение b, если выражение a исполнилось успешно
    (define (sequentially a b)
      (lambda (env succeed fail)
        (a env
           ;; продолжение успеха при вызове a
           (lambda (a-value fail2)
             (b env succeed fail2))
           ;; продолжение неудачи при вызове a
           fail)))
    ;; цикл анализирования и выражений одного за другим, пока они не кончатся
    (define (loop first-proc rest-procs)
      (if (null? rest-procs)
          first-proc
          (loop (sequentially first-proc (car rest-procs))
                (cdr rest-procs))))
    ;; получаем исполнительные процедуры выражений
    (let ((procs (map analyze exps)))
      (if (null? procs)
          (error "Пустая последовательность -- ANALYZE"))
      (loop (car procs) (cdr procs))))

  ;; анализ определения
  (define (analyze-definition exp)
    ;; получаем имя определения
    (let ((var (definition-variable exp))
          ;; получаем исполнительную процедуру выражения
          (vproc (analyze (definition-value exp))))
      (display var)
      (newline)
      (display vproc)
      (newline)
      (lambda (env succeed fail)
        ;; если выполнение присваевомого значения успешно
        (vproc env
               (lambda (val fail2)
                 ;; определяем переменную
                 (define-variable! var val env)
                 (succeed 'ok fail2))
               ;; иначе вызываем продолжеие неудачи
               fail))))

  ;; анализ присваивания
  ;; основная проблема присваивания в данном интерпретаторе - это возможная необходимость
  ;; откатить назад присваивание, присвоив переменной прежнее значение, если общее
  ;; вычисление зашло в тупик или потерпело иную неудачу и нам необходимо вернуться в
  ;; предыдущую точку выбора
  (define (analyze-assignment exp)
    ;; сначала поступаем как при определении
    (let ((var (assignment-variable exp))
          (vproc (analyze (assignment-value exp))))
      ;; принимает окружение и 2 продолжения
      (lambda (env succeed fail)
        (display "succeed")
        (display succeed)
        (newline)
        (display "fail")
        (display fail)
        (newline)
        ;; если присваевымое выражение исполнилось успешно
        (vproc env
               ;; вызываем продолжение успеха
               (lambda (val fail2)
                 ;; сохраняем прежнее значение переменной
                 (let ((old-value
                        (lookup-variable-value var env)))
                   ;; присваеваем ей новое значение
                   (set-variable-value! var val env)
                   ;; если все успех распространился дальше, возвращаем 'ok
                   (succeed 'ok
                             ;; если где-то потерпели неудачу
                             (lambda ()
                               ;; присваиваем переменной старое значение
                               (set-variable-value! var
                                                    old-value
                                                    env)
                               ;; вызываем продолжение неудачи
                               (fail2)))))
               fail))))
  ;; анализ вызова процедур
  (define (analyze-application exp)
    ;; получаем исполнительную процедуру операнда
    (let ((fproc (analyze (operator exp)))
          ;; получаем исполнительные процедуры операндов
          (aprocs (map analyze (operands exp))))
      (lambda (env succeed fail)
        ;; если операнд вычислился успешно
        (fproc env
               ;; исполняем продолжение успеха
               (lambda (proc fail2)
                 ;; получаем список аргументов для оператора
                 (get-args aprocs
                           env
                           ;; если список успешно получен
                           (lambda (args fail3)
                             ;; применяем оператор к аргументам
                             (execute-application
                              proc args succeed fail3))
                           ;; иначе исполняем продолжение неудачи
                           fail2))
               fail))))

  ;; исполняет исполнительные процедуры аргументов вызываемой процедры и возвращает
  ;; список их значений
  (define (get-args aprocs env succeed fail)
    (if (null? aprocs)
        (succeed '() fail)
        ;; если первая исполнительная процедура выполнилась успешно
        ((car aprocs) env
         ;; продолжение успеха для этой aproc
         (lambda (arg fail2)
           ;; продолжаем исполнять остальные процедуры аргументов
           (get-args (cdr aprocs)
                     env
                     ;; и если все исполнительные процедуры были вычислены
                     ;; продолжение успеха для
                     ;; рекурсивного вызова get-args
                     (lambda (args fail3)
                       ;; соединяем их значения в список
                       (succeed (cons arg args)
                                fail3))
                     fail2))
         fail)))

  ;; исполнение вызова процедуры
  (define (execute-application proc args succeed fail)
    ;; если процедцура примитивная
    (cond ((primitive-procedure? proc)
           ;; то передаем успешному продолжению значение ее вызова и продолжение неудачи
           (succeed (apply-primitive-procedure proc args)
                    fail))
          ;; если процедура непримитив
          ((compound-procedure? proc)
           ;; получаем тело процедуры
           ;; и передаем ему (?)
           ((procedure-body proc)
            ;; новый кадр окружения
            (extend-environment (procedure-parameters proc)
                                args
                                (procedure-environment proc))
            ;; продолжения успеха и неудачи
            succeed
            fail))
          (else
           (error
            "Неизвестный тип процедуры -- EXECUTE-APPLICATION"
            proc))))

  ;; анализируем выражение amb
  (define (analyze-amb exp)
    ;; получаем исполнительные процедуры выборов amb
    (let ((cprocs (map analyze (amb-choices exp))))
      (lambda (env succeed fail)
        (define (try-next choices)
          ;; если выборы кончились - неудача
          (if (null? choices)
              (fail)
              ;; иначе первому выбору передаем окружение, продолжение успеха и неудачи
              ((car choices) env
               succeed
               ;; продолжение неудачи - это перебор остальных вариантов
               (lambda ()
                 (try-next (cdr choices))))))
        (try-next cprocs))))
#+END_SRC


управляющий цикл:
#+BEGIN_SRC scheme
  (define input-prompt ";;; Ввод Amb-Eval:")

  (define output-prompt ";;; Значение Amb-Eval:")

  (define (announce-output string)
    (newline) (display string) (newline))

  (define (user-print object)
    (if (compound-procedure? object)
        (display (list 'compound-procedure
                       (procedure-parameters object)
                       (procedure-body object)
                       '<procedure-env>))
        (display object)))

  (define (setup-environment)
    (let ((initial-env
           (extend-environment (primitive-procedure-names)
                               (primitive-procedure-objects)
                               the-empty-environment)))
      (define-variable! 'true true initial-env)
      (define-variable! 'false false initial-env)
      initial-env))

  (define the-global-environment (setup-environment))

  (define the-empty-environment '())

  (define primitive-procedures
    (list (list 'car car)
          (list 'cdr cdr)
          (list 'cons cons)
          (list 'null? null?)
          (list 'list list)
          (list '= =)
          (list '/ /)
          (list '* *)
          (list 'display display)
          (list '+ +)
          (list '- -)

          ))

  (define (driver-loop)
    (define (internal-loop try-again)
      ;; печатаем приглашение к вводу
      (prompt-for-input input-prompt)
      ;; считываем ввод
      (let ((input (read)))
        ;; если пользователь хочет попробовать вычислить данное выражение еще раз
        ;; (перебрать другие варианты), пробуем вычислить еще раз
        (if (eq? input 'try-again)
            (try-again)
            ;; иначе
            (begin
              ;; считаем, что у юзера новая задача
              (newline)
              (display ";;; Начало новой задачи ")
              ;; передадим введенному выражению глобальное окружение и 2 продолжения
              (ambeval input
                       the-global-environment
                       ;; успех ambeval
                       (lambda (val next-alternative)
                         ;; печатаем уведомление о значении
                         (announce-output output-prompt)
                         ;; печатаем само значение
                         (user-print val)
                         ;; вычисляем следующую альтернативу
                         (internal-loop next-alternative))
                       ;; неудача ambeval
                       (lambda ()
                         (announce-output
                          ";;; Нет больше значений")
                         (user-print input)
                         (driver-loop)))))))
    (internal-loop
     ;; печать ошибки, если пользователь пытается вычислить альтернативы, не
     ;; поставив задачу
     (lambda ()
       (newline)
       (display ";;; Задача не задана")
       (driver-loop))))
#+END_SRC
~Упражнение 4.50.~
Реализуйте новую особую форму ramb, которая подобна amb, однако
перебирает варианты не слева направо, а в случайном порядке.
Покажите, как такая форма может пригодиться в Лизиной задаче из упражнения 4.49

Итак, для случайного выбора выражений мы воспользуемся ранее
определенными процедурами:

#+BEGIN_SRC scheme
  (define prev-n #f)

  ;; создадим функцию, которая генерит случайные числа в заданном интервали
  ;; при этом мы следим, чтоб не выпадало подряд дважды одно и то же число
  (define (generate-number-interval min max)
    (let ((n (random (+ 1 max))))
      (cond ((eq? prev-n n) (if (< n max)
                                (begin (set! prev-n (+ prev-n 1))
                                       (+ n 1))
                                (begin (set! prev-n (- prev-n 1))
                                       (- n 1))))
            ((< n min) (begin (set! prev-n min) min))
            (else (begin (begin (set! prev-n n) n))))))
#+END_SRC

Мы будем случайным образом генерировать индекс выражения в списке и
выбирать его.

Теперьнапишем процедуру ramb.
#+BEGIN_SRC scheme

  ;; принимает индекс и список выражений
  ;; поднимает выражение с заданным индексом в car списка
  ;; возвращает новый список
  (define (bubble-exp indx exps-list)
    (define (iter indx exps-list new-exps-list)
      (if (= indx 0)
          (append (list (car exps-list))
                  (append new-exps-list (cdr exps-list)))
          (iter (- indx 1) (cdr exps-list) (append new-exps-list
                (list (car exps-list))))))
    (if (>= indx (length exps-list))
        #f
        (iter indx exps-list '())))

  (define (ramb? exp)
    (tagged-list? exp 'ramb))

  (define (ramb-choices exp)
    (cdr exp))

  (define (analyze-ramb exp)
    ;; получаем исполнительные процедуры выборов amb
    (let ((cprocs (map analyze (ramb-choices exp))))
      (lambda (env succeed fail)
        (define (try-next choices)
          ;; если выборы кончились - неудача
          (if (null? choices)
              (fail)
              ;; иначе рандомно генерируем индекс и "поднимаем" выражение с таким индексом
              ;; в car списка
              (let* ((choices-length (length choices))
                     (bubbled-choices
                      (if (= choices-length 1)
                          (list (car choices))
                          (bubble-exp (generate-number-interval 0 (- (length choices) 1))
                                      choices))))

                (set! choices bubbled-choices)
                ;; (display choices)
                ;; (display newline)
                ((car choices) env succeed
                 ;; продолжение неудачи - это перебор остальных вариантов
                 (lambda ()
                   (try-next (cdr choices)))))))
          (try-next cprocs))))

  (define (analyze exp)
    (cond ((self-evaluating? exp)
           (analyze-self-evaluating exp))
          ((require? exp) (analyze-require exp))
          ((quoted? exp) (analyze-quoted exp))
          ((variable? exp) (analyze-variable exp))
          ((assignment? exp) (analyze-assignment exp))
          ((permanent-assignment? exp) (analyze-permanent-assignment exp))
          ((definition? exp) (analyze-definition exp))
          ((let? exp) (analyze (let->combination exp)))
          ((if? exp) (analyze-if exp))
          ((if-fail? exp) (analyze-if-fail exp))
          ((lambda? exp) (analyze-lambda exp))
          ((begin? exp) (analyze-sequence (begin-actions exp)))
          ((cond? exp) (analyze (cond->if exp)))
          ((amb? exp) (analyze-amb exp))
          ((ramb? exp) (analyze-ramb exp))
          ((application? exp) (analyze-application exp))
          (else
           (error "Неизвестный тип выражения -- ANALYZE" exp))))

  ;;(list (ramb 1 2 3 4) (ramb 1 2 3 4))
#+END_SRC

#+BEGIN_SRC scheme
  (define (parse-word)
    (define (make-phrase phrase)
      (cond ((null? phrase) (make-phrase (list (list 'article
                                                     (ramb 'the 'a 'an)))))
            ((eq? (caar (last-pair phrase)) 'article)
             (make-phrase (append phrase (list (list 'noun (ramb 'student 'professor
                                                                 'girl 'dog
                                                                 'cat 'class))))))
            ((eq? (caar (last-pair phrase)) 'noun)
             (make-phrase (append phrase
                                  (list (list 'verb (ramb 'studies 'lectures
                                                          'eats 'sleeps))))))
            (else phrase)))
    (make-phrase '()))


  ;; (parse-word)
#+END_SRC


~Упражнение 4.51.~
Реализуйте новую разновидность присваивания permanent-set! —
присваивание, которое не отменяется при неудачах. Например, можно выбрать
два различных элемента в списке и посчитать, сколько для этого
потребовалось попыток,
следующим образом:

#+BEGIN_SRC scheme
  (define count 0)

  (define (an-element-of items)
    (require (not (null? items)))
    (amb (car items) (an-element-of (cdr items))))

  (let ((x (an-element-of '(a b c)))
        (y (an-element-of '(a b c))))
    (permanent-set! count (+ count 1))
    (require (not (eq? x y)))
    (list x y count))

  ;;; Начало новой задачи
  ;;; Значение Amb-Eval:
  (a b 2)
  ;;; Ввод Amb-Eval:
  try-again
  ;;; Значение Amb-Eval:
  (a c 3)
#+END_SRC

Какие значения были бы напечатаны, если бы мы вместо ~permanent-set!~
использовали здесь обычный ~set!~?

Итак, у нас есть ~analyse-assigment~, которая анализирует присваивания.
Она возвращает исполнительную процедуру присваивания, которое можно
откатить назад. Значит, нам просто нужно убрать этот "откат", т.е. не
сохранять прежнее значение переменной и при неудаче не откатывать ее
назад.

заливаем в обычную схему и тестим с выражением выше:
#+BEGIN_SRC scheme
  (define (analyze exp)
    (cond ((self-evaluating? exp)
           (analyze-self-evaluating exp))
          ((quoted? exp) (analyze-quoted exp))
          ((variable? exp) (analyze-variable exp))
          ((assignment? exp) (analyze-assignment exp))
          ((permanent-assignment? exp) (analyze-permanent-assignment exp))
          ((definition? exp) (analyze-definition exp))
          ((let? exp) (analyze (let->combination exp)))
          ((if? exp) (analyze-if exp))
          ((lambda? exp) (analyze-lambda exp))
          ((begin? exp) (analyze-sequence (begin-actions exp)))
          ((cond? exp) (analyze (cond->if exp)))
          ;; добавляем анализ для amb
          ((amb? exp) (analyze-amb exp))
          ((application? exp) (analyze-application exp))
          (else
           (error "Неизвестный тип выражения -- ANALYZE" exp))))

  (define (permanent-assignment? exp)
    (tagged-list? exp 'permanent-set!))

  (define (analyze-permanent-assignment exp)
    ;; сначала поступаем как при определении
    (let ((var (assignment-variable exp))
          (vproc (analyze (assignment-value exp))))
      ;; принимает окружение и 2 продолжения
      (lambda (env succeed fail)
        ;; если присваевымое выражение исполнилось успешно
        (vproc env
               ;; вызываем продолжение успеха
               (lambda (val fail2)
                   ;; присваеваем новое значение
                   (set-variable-value! var val env)
                   ;; если все успех распространился дальше, возвращаем 'ok
                   (succeed 'ok (lambda () (fail2))))
               fail))))

#+END_SRC


Если мы будем испольновать set! в указанном выше выражении, то count = 1,
поскольку если попытка неудачная, она как бы "не считается", при откате
назад мы будем откатывать и значение переменной, следовательно, зачтется
только удачная попытка.

~Упражнение 4.52.~
Реализуйте новую конструкцию if-fail, которая позволяет пользователю
перехватить неудачу при выполнении выражения.
If-fail принимает два выражения. Первое она выполняет как
обычно и, если вычисление успешно, возвращает его результат. Однако если
вычисление неудачно, то возвращается значение второго выражения,
как в следующем примере:

#+BEGIN_SRC scheme
  ;;; Ввод Amb-Eval:
  (if-fail (let ((x (an-element-of '(1 3 5))))
             (require (even? x))
             x)
           'all-odd)

  ;;; Начало новой задачи
  ;;; Значение Amb-Eval:
  all-odd
  ;;; Ввод Amb-Eval:

  (if-fail (let ((x (an-element-of '(1 3 5 8))))
             (require (even? x))
             x)
           'all-odd)
  ;;; Начало новой задачи
  ;;; Значение Amb-Eval:
  8
#+END_SRC

Фактически это аналог обычного ~if~, только этот ~if~ оперирует
выражениями и продолжениями.

Принимает 2 выражения. При этом второе будет являться продолжением
неудачи. А продолжение успеха - это значение первого выражения.
#+BEGIN_SRC scheme
  (define (if-fail? exp)
    (tagged-list? exp 'if-fail))

  (define (if-fail-exp exp)
    (cadr exp))

  (define (if-fail-case-false exp)
    (caddr exp))

  (define (analyze-if-fail exp)
    (let ((vproc-exp (analyze (if-fail-exp exp)))
          (vproc-false (analyze (if-fail-case-false exp))))
      (display vproc-exp)
      (newline)
      (display vproc-false)
      (newline)
      (lambda (env succeed fail)
        (vproc-exp env
                   (lambda (val fail2)
                     (succeed val (lambda ()
                                    (fail2))))
                   (lambda ()
                     (vproc-false env succeed fail))))))

  (define (analyze exp)
    (cond ((self-evaluating? exp)
           (analyze-self-evaluating exp))
          ((quoted? exp) (analyze-quoted exp))
          ((variable? exp) (analyze-variable exp))
          ((assignment? exp) (analyze-assignment exp))
          ((permanent-assignment? exp) (analyze-permanent-assignment exp))
          ((definition? exp) (analyze-definition exp))
          ((let? exp) (analyze (let->combination exp)))
          ((if? exp) (analyze-if exp))
          ((if-fail? exp) (analyze-if-fail exp))
          ((lambda? exp) (analyze-lambda exp))
          ((begin? exp) (analyze-sequence (begin-actions exp)))
          ((cond? exp) (analyze (cond->if exp)))
          ;; добавляем анализ для amb
          ((amb? exp) (analyze-amb exp))
          ((application? exp) (analyze-application exp))
          (else
           (error "Неизвестный тип выражения -- ANALYZE" exp))))

#+END_SRC

~Упражнение 4.53.~
Если у нас есть permanent-set!, описанное в упражнении 4.51, и if-fail из
упражнения 4.52, то каков будет результат вычисления

#+BEGIN_SRC scheme

  (define (smallest-divisor n)
    (find-divisor n 2))

  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor n (+ test-divisor 1)))))

  (define (divides? a b)
    (= (remainder b a) 0))

  (define (prime? n)
    (= n (smallest-divisor n)))

  (define (square x)
    (* x x))

  (define (an-element-of items)
    (require (not (null? items)))
    (amb (car items) (an-element-of (cdr items))))

  (define (prime-sum-pair list1 list2)
    (let ((a (an-element-of list1))
          (b (an-element-of list2)))
      (require (prime? (+ a b)))
      (list a b)))

  (let ((pairs '()))
    (if-fail (let ((p (prime-sum-pair '(1 3 5 8) '(20 35 110))))
               (permanent-set! pairs (cons p pairs))
               (amb))
             pairs))
#+END_SRC

Вывод: ~((8 35) (3 110) (3 20))~

~Упражнение 4.54.~
Если бы мы не догадались, что конструкцию require можно реализовать как
обычную процедуру с помощью amb, так что пользователь сам может
определить ее в своей недетерминистской программе, то нам пришлось бы
задать эту конструкцию в виде особой формы. Допишите следующие процедуры:

#+BEGIN_SRC scheme
  (define (require? exp) (tagged-list? exp 'require))

  (define (require-predicate exp) (cadr exp))

  (define (analyze-require exp)
    (let ((pproc (analyze (require-predicate exp))))
      (lambda (env succeed fail)
        (pproc env
               (lambda (pred-value fail2)
                 (if (not (true? pred-value))
                     (fail2)
                     (succeed 'ok fail2)))
               fail))))

  (define (analyze exp)
    (cond ((self-evaluating? exp)
           (analyze-self-evaluating exp))
          ((require? exp) (analyze-require exp))
          ((quoted? exp) (analyze-quoted exp))
          ((variable? exp) (analyze-variable exp))
          ((assignment? exp) (analyze-assignment exp))
          ((permanent-assignment? exp) (analyze-permanent-assignment exp))
          ((definition? exp) (analyze-definition exp))
          ((let? exp) (analyze (let->combination exp)))
          ((if? exp) (analyze-if exp))
          ((if-fail? exp) (analyze-if-fail exp))
          ((lambda? exp) (analyze-lambda exp))
          ((begin? exp) (analyze-sequence (begin-actions exp)))
          ((cond? exp) (analyze (cond->if exp)))
          ;; добавляем анализ для amb
          ((amb? exp) (analyze-amb exp))
          ((application? exp) (analyze-application exp))
          (else
           (error "Неизвестный тип выражения -- ANALYZE" exp))))


  (require (< (+ 3 4) (+ 1 2)))
  (require (+ (+ 3 4) (+ 1 2)))
#+END_SRC

*** Логическое программирование

~реализация запросной системы~

#+BEGIN_SRC scheme
  (define (insert! key value table)
    (let ((record (assoc key (cdr table))))
      (if record
          (set-cdr! record value)
          (set-cdr! table
                    (cons (cons key value) (cdr table)))))
    'ok)

  (define (make-table)
    (list '*table*))
#+END_SRC


#+BEGIN_SRC scheme
   (define input-prompt ";;; Ввод запроса:")
  (define output-prompt ";;; Результаты запроса:")

  (define (query-driver-loop)
    (prompt-for-input input-prompt)
    (let ((q (query-syntax-process (read))))
      (cond ((assertion-to-be-added? q)
             (add-rule-or-assertion! (add-assertion-body q))
             (newline)
             (display "Утверждение добавлено в базу данных.")
             (query-driver-loop))
            (else
             (newline)
             (display output-prompt)
             (display-stream
              (stream-map
               (lambda (frame)
                 (instantiate q
                              frame
                              (lambda (v f)
                                (contract-question-mark v))))
               (qeval q (singleton-stream '()))))
             (query-driver-loop)))))

  (define (instantiate exp frame unbound-var-handler)
    (define (copy exp)
      (cond ((var? exp)
             (let ((binding (binding-in-frame exp frame)))
               (if binding
                   (copy (binding-value binding))
                   (unbound-var-handler exp frame))))
            ((pair? exp)
             (cons (copy (car exp)) (copy (cdr exp))))
            (else exp)))
    (copy exp))

  (define (qeval query frame-stream)
    (let ((qproc (get (type query) 'qeval)))
      (if qproc
          (qproc (contents query) frame-stream)
          (simple-query query frame-stream))))

  (define (simple-query query-pattern frame-stream)
    (stream-flatmap
     (lambda (frame)
       (stream-append-delayed
        (find-assertions query-pattern frame)
        (delay (apply-rules query-pattern frame))))
     frame-stream))

  (define (conjoin conjuncts frame-stream)
    (if (empty-conjunction? conjuncts)
        frame-stream
        (conjoin (rest-conjuncts conjuncts)
                 (qeval (first-conjunct conjuncts)
                        frame-stream))))

  (define (disjoin disjuncts frame-stream)
    (if (empty-disjunction? disjuncts)
        the-empty-stream
        (interleave-delayed
         (qeval (first-disjunct disjuncts) frame-stream)
         (delay (disjoin (rest-disjuncts disjuncts)
                         frame-stream)))))

  (put 'and 'qeval conjoin)
  (put 'or 'qeval disjoin)

  (define (negate operands frame-stream)
    (stream-flatmap
     (lambda (frame)
       (if (stream-null? (qeval (negated-query operands)
                                (singleton-stream frame)))
           (singleton-stream frame)
           the-empty-stream))
     frame-stream))

  (put 'not 'qeval negate)

  (define (lisp-value call frame-stream)
    (stream-flatmap
     (lambda (frame)
       (if (execute
            (instantiate
             call
             frame
             (lambda (v f)
               (error "Неизвестная переменная -- LISP-VALUE" v))))
           (singleton-stream frame)
           the-empty-stream))
     frame-stream))

  (put 'lisp-value 'qeval lisp-value)

  (define (execute exp)
    (apply (eval (predicate exp) user-initial-environment)
           (args exp)))

  (define (always-true ignore frame-stream) frame-stream)
  (put 'always-true 'qeval always-true)

  (define (find-assertions pattern frame)
    (stream-flatmap (lambda (datum)
                      (check-an-assertion datum pattern frame))
                    (fetch-assertions pattern frame)))

  (define (check-an-assertion assertion query-pat query-frame)
    (let ((match-result
           (pattern-match query-pat assertion query-frame)))
      (if (eq? match-result 'failed)
          the-empty-stream
          (singleton-stream match-result))))

  (define (pattern-match pat dat frame)
    (cond ((eq? frame 'failed) 'failed)
          ((equal? pat dat) frame)
          ((var? pat) (extend-if-consistent pat dat frame))
          ((and (pair? pat) (pair? dat))
           (pattern-match (cdr pat)
                          (cdr dat)
                          (pattern-match (car pat)
                                         (car dat)
                                         frame)))
          (else 'failed)))

  (define (extend-if-consistent var dat frame)
    (let ((binding (binding-in-frame var frame)))
      (if binding
          (pattern-match (binding-value binding) dat frame)
          (extend var dat frame))))

  (define (apply-rules pattern frame)
    (stream-flatmap (lambda (rule)
                      (apply-a-rule rule pattern frame))
                    (fetch-rules pattern frame)))

  (define (apply-a-rule rule query-pattern query-frame)
    (let ((clean-rule (rename-variables-in rule)))
      (let ((unify-result
             (unify-match query-pattern
                          (conclusion clean-rule)
                          query-frame)))
        (if (eq? unify-result 'failed)
            the-empty-stream
            (qeval (rule-body clean-rule)
                   (singleton-stream unify-result))))))

  (define (rename-variables-in rule)
    (let ((rule-application-id (new-rule-application-id)))
      (define (tree-walk exp)
        (cond ((var? exp)
               (make-new-variable exp rule-application-id))
              ((pair? exp)
               (cons (tree-walk (car exp))
                     (tree-walk (cdr exp))))
              (else exp)))
      (tree-walk rule)))

  (define (unify-match p1 p2 frame)
    (cond ((eq? frame 'failed) 'failed)
          ((equal? p1 p2) frame)
          ((var? p1) (extend-if-possible p1 p2 frame))
          ((var? p2) (extend-if-possible p2 p1 frame))
          ((and (pair? p1) (pair? p2))
           (unify-match (cdr p1)
                        (cdr p2)
                        (unify-match (car p1)
                                     (car p2)
                                     frame)))
          (else 'failed)))

  (define (extend-if-possible var val frame)
    (let ((binding (binding-in-frame var frame)))
      (cond (binding
             (unify-match
              (binding-value binding) val frame))
            ((var? val)
                                          ; ***
             (let ((binding (binding-in-frame val frame)))
               (if binding
                   (unify-match
                    var (binding-value binding) frame)
                   (extend var val frame))))
            ((depends-on? val var frame)
                                          ; ***
             'failed)
            (else (extend var val frame)))))

  (define (depends-on? exp var frame)
    (define (tree-walk e)
      (cond ((var? e)
             (if (equal? var e)
                 true
                 (let ((b (binding-in-frame e frame)))
                   (if b
                       (tree-walk (binding-value b))
                       false))))
            ((pair? e)
             (or (tree-walk (car e))
                 (tree-walk (cdr e))))
            (else false)))
    (tree-walk exp))

  (define THE-ASSERTIONS the-empty-stream)

  (define (fetch-assertions pattern frame)
    (if (use-index? pattern)
        (get-indexed-assertions pattern)
        (get-all-assertions)))

  (define (get-all-assertions) THE-ASSERTIONS)

  (define (get-indexed-assertions pattern)
    (get-stream (index-key-of pattern) 'assertion-stream))

  (define (get-stream key1 key2)
    (let ((s (get key1 key2)))
      (if s s the-empty-stream)))

  (define THE-RULES the-empty-stream)

  (define (fetch-rules pattern frame)
    (if (use-index? pattern)
        (get-indexed-rules pattern)
        (get-all-rules)))

  (define (get-all-rules) THE-RULES)

  (define (get-indexed-rules pattern)
    (stream-append
     (get-stream (index-key-of pattern) 'rule-stream)
     (get-stream '? 'rule-stream)))

  (define (add-rule-or-assertion! assertion)
    (if (rule? assertion)
        (add-rule! assertion)
        (add-assertion! assertion)))

  (define (add-assertion! assertion)
    (store-assertion-in-index assertion)
    (let ((old-assertions THE-ASSERTIONS))
      (set! THE-ASSERTIONS
            (cons-stream assertion old-assertions))
      'ok))

  (define (add-rule! rule)
    (store-rule-in-index rule)
    (let ((old-rules THE-RULES))
      (set! THE-RULES (cons-stream rule old-rules))
      'ok))

  (define (store-assertion-in-index assertion)
    (if (indexable? assertion)
        (let ((key (index-key-of assertion)))
          (let ((current-assertion-stream
                 (get-stream key 'assertion-stream)))
            (put key
                 'assertion-stream
                  (cons-stream assertion
                               current-assertion-stream))))))

  (define (store-rule-in-index rule)
    (let ((pattern (conclusion rule)))
      (if (indexable? pattern)
          (let ((key (index-key-of pattern)))
            (let ((current-rule-stream
                   (get-stream key 'rule-stream)))
              (put key
                   'rule-stream
                    (cons-stream rule
                                 current-rule-stream)))))))

  (define (indexable? pat)
    (or (constant-symbol? (car pat))
        (var? (car pat))))

  (define (index-key-of pat)
    (let ((key (car pat)))
      (if (var? key) '? key)))

  (define (use-index? pat)
    (constant-symbol? (car pat)))

  (define (stream-append-delayed s1 delayed-s2)
    (if (stream-null? s1)
        (force delayed-s2)
        (cons-stream
         (stream-car s1)
         (stream-append-delayed (stream-cdr s1) delayed-s2))))

  (define (interleave-delayed s1 delayed-s2)
    (if (stream-null? s1)
        (force delayed-s2)
        (cons-stream
         (stream-car s1)
         (interleave-delayed (force delayed-s2)
                             (delay (stream-cdr s1))))))

  (define (stream-flatmap proc s)
    (flatten-stream (stream-map proc s)))

  (define (flatten-stream stream)
    (if (stream-null? stream)
        the-empty-stream
        (interleave-delayed
         (stream-car stream)
         (delay (flatten-stream (stream-cdr stream))))))

  (define (singleton-stream x)
    (cons-stream x the-empty-stream))

  (define (type exp)
    (if (pair? exp)
        (car exp)
        (error "Неизвестное выражение TYPE" exp)))

  (define (contents exp)
    (if (pair? exp)
        (cdr exp)
        (error "Неизвестное выражение CONTENTS" exp)))

  (define (assertion-to-be-added? exp)
    (eq? (type exp) 'assert!))

  (define (add-assertion-body exp)
    (car (contents exp)))

  (define (empty-conjunction? exps) (null? exps))

  (define (first-conjunct exps) (car exps))

  (define (rest-conjuncts exps) (cdr exps))

  (define (empty-disjunction? exps) (null? exps))

  (define (first-disjunct exps) (car exps))

  (define (rest-disjuncts exps) (cdr exps))

  (define (negated-query exps) (car exps))

  (define (predicate exps) (car exps))

  (define (args exps) (cdr exps))

  (define (rule? statement)
    (tagged-list? statement 'rule))

  (define (conclusion rule) (cadr rule))

  (define (rule-body rule)
    (if (null? (cddr rule))
        '(always-true)
        (caddr rule)))

  (define (query-syntax-process exp)
    (map-over-symbols expand-question-mark exp))

  (define (map-over-symbols proc exp)
    (cond ((pair? exp)
           (cons (map-over-symbols proc (car exp))
                 (map-over-symbols proc (cdr exp))))
          ((symbol? exp) (proc exp))
          (else exp)))

  (define (expand-question-mark symbol)
    (let ((chars (symbol->string symbol)))
      (if (string=? (substring chars 0 1) "?")
          (list '?
                 (string->symbol
                  (substring chars 1 (string-length chars))))
          symbol)))

  (define (var? exp)
    (tagged-list? exp '?))

  (define (constant-symbol? exp) (symbol? exp))

  (define (new-rule-application-id)
    (set! rule-counter (+ 1 rule-counter))
    rule-counter)

  (define (make-new-variable var rule-application-id)
    (cons '? (cons rule-application-id (cdr var))))

  (define (contract-question-mark variable)
    (string->symbol
     (string-append "?"
                    (if (number? (cadr variable))
                        (string-append (symbol->string (caddr variable))
                                       "-"
                                       (number->string (cadr variable)))
                        (symbol->string (cadr variable))))))

  (define (make-binding variable value)
    (cons variable value))

  (define (binding-variable binding)
    (car binding))

  (define (binding-value binding)
    (cdr binding))

  (define (binding-in-frame variable frame)
    (assoc variable frame))

  (define (extend variable value frame)
    (cons (make-binding variable value) frame))
#+END_SRC

Следующие ниже упражнения делались без проверки через систему запросов
(она описана в мане ниже и на данный момент я не знаю, как заполнять БД)

~Упражнение 4.55.~
Постройте простые запросы, которые извлекают из базы данных следующую
информацию:
а. Все сотрудники, начальником которых является Бен Битобор.
б. Имена и должности всех работников бухгалтерии.
в. Имена и адреса всех сотрудников, живущих в Сламервилле.

#+BEGIN_SRC scheme
  ;; а
  (начальник ?x (Бен Битобор))

  ;; б
  (должность ?x (бухгалтерия . ?type))

  ;; в

  (адрес ?x (Сламервилл . ?type))
#+END_SRC

~Упражнение 4.56.~
Сформулируйте составные запросы для получения следующей информации:

а. имена всех сотрудников, у которых начальником Бен Битобор, и их
адреса;
б. все сотрудники, чья зарплата ниже, чем у Бена Битобора, вместе с их
зарплатой и зарплатой
Бена;
в. все сотрудники, у которых начальник не относится к компьютерному
отделу, вместе с именем
и должностью их начальника.

#+BEGIN_SRC scheme
  ;; а
  (and (начальник ?x (Бен Битобор))
       (адрес ?x))

  ;; б
  (and (зарплата Бен Битобор ?x)
       (lisp-value > (зарплата Бен Битобор ?x) (зарплата ?y ?x))
       (зарплата ?y ?x))

  ;; в

  (and (начальник ?x (not (должность ?person (компьютеры . ?type))))
       (начальник ?x) (должность (начальник ?x)))

#+END_SRC

~Упражнение 4.57.~

Определите правило, которое говорит, что служащий 1 может заменить
служащего 2, если либо служащий 1 имеет ту же должность, что и служащий
2, либо человек с должностью служащего 1 может выполнять работу служащего
2, и при этом служащие 1 и 2 — разные люди.
Используя это правило, составьте запросы, которые находят следующую информацию:
а. все служащие, которые могут заменить П.Э. Фекта.
б. все служащие, которые могут заменить кого-то, кто получает больше их
самих, с указанием
двух зарплат.

#+BEGIN_SRC scheme
  ;; сотрудник 1 замещает сотрудника 2, если:
  (rule (может-замещать ?person1 ?person2)
        ;; это не один и тот же сотрудник
        (and (not same ?person1 ?person2)
             ;; у них либо одна должность
             (or (same (должность ?person1)
                       (должность ?person2))
                 ;; либо ложность первого может замещать должность второго
                 ;; (сеньеор может легко заменить мидла)
                 (может-замещать (должность ?person1)
                                 (должность ?person2)))))

  ;; кто может замещать Фекта
  (может-замещать ?person1 П.Э. Фект)

  ;; сотрудник 1 может замещать сотрудника 2
  (and (может-замещать ?person1 ?person2)
       ;; выводим из зп
       (зарплата ?person1)
       (зарплата ?person2)
       ;; при этом зп сотрудника 1 больше зп сотрудника 2
       (lisp-value > (зарплата ?person1)
                     (зарплата ?person2)))
#+END_SRC

~Упражнение 4.58.~
Определите правило, которое говорит, что человек «независим» в своем
отделе, если он работает в этом отделе, но у него нет начальника,
который работает в том же отделе.

В переводе на русский язык нужно создать правило "работник независим,
если он и его начальники работают в разных отделах"

#+BEGIN_SRC scheme
  (rule (независим ?person1 ?office)
        (and (not same ((начальник ?person1) ?office)
                  (?person1 ?office))))
#+END_SRC

~Упражнение 4.59.~

Бен Битобор пропускает слишком много совещаний. Опасаясь потерять из-за
этой глупой привычки работу, он решает, что с ней надо что-то делать.
Он добавляет данные обо всех еженедельных совещаниях в базу данных
«Микрошафт» в виде следующих утверждений:

(совещание бухгалтерия (понедельник 9))
(совещание администрация (понедельник 10))
(совещание компьютеры (среда 15))
(совещание администрация (пятница 13))

Все эти утверждения сообщают о совещаниях отделов. Кроме того, Бен вводит
утверждение о совещании всей компании, которое относится ко всем отделам. Все
сотрудники компании должны ходить на это совещание.

(совещание вся-компания (среда 16))

a. В пятницу утром Бен хочет спросить у базы данных, какие совещания
происходят в этот день. Как ему надо составить запрос?

ответ: (совещание ?office (пятница))

б. Лиза П. Хакер недовольна. Она считает, что намного полезнее было бы,
если бы можно было спрашивать о совещаниях, указывая свое имя.
Она пишет правило, гласящее, что совещания, куда служащему надо ходить,
это совещания всей компании и совещания отдела, где он работает.
Допишите тело Лизиного правила.

#+BEGIN_SRC scheme
  (rule (время-совещания ?person ?day-and-time)
        (and (совещание вся-компания ?day-and-time)
             (совещание (?person ?office) ?day-and-time)))
#+END_SRC

в. Лиза приходит на работу в среду и хочет узнать, на какие совещания ей
нужно идти в этот день. Если имеется правило время-совещания, то какой
запрос ей надо подать?

ответ:
(время-совещания (Лиза. П. Хакер) (среда))

~Упражнение 4.60.~
Подав запрос ~(живет-около ?person (Хакер Лиза П))~
Лиза П. Хакер может найти людей, которые живут с ней рядом, и с которыми
она вместе может ездить на работу. С другой стороны, когда она пытается
найти все пары людей, живущих друг около друга, при помощи запроса

~(живет-около ?person-1 ?person-2)~

она видит, что каждая подходящая пара людей попадается в выводе дважды,
например

~(живет-около (Хакер Лиза П) (Фект Пабло Э))~
~(живет-около (Фект Пабло Э) (Хакер Лиза П))~

Почему так происходит? Можно ли получить список людей, живущих рядом друг
с другом, в котором каждая пара появлялась бы по одному разу? Ответ объясните.

Так происходит, потому что система сама делает некоторые логические
выводы. В данном случае система сделала вывод, что если Лиза живет рядом
с Пабло, то и Пабло живет рядом с Лизой. А система выдает все варианты,
при которых утверждение будет правильным.

Формально, можно было бы дополнить правило, создав уточнение, что выводы
"ЛИза живет рядом с Пабло" и "Пабло живет рядом с Лизой" - это 2 вида
одного и того же утверждения, соответственно, если мы вывели один
вариант, то второй показывать не нужно.

~Упражнение 4.61.~
Следующие правила определяют отношение next-to, которое находит в списке
соседние элементы:

~(rule (?x next-to ?y in (?x ?y . ?u)))~
~(rule (?x next-to ?y in (?v . ?z))~
~(?x next-to ?y in ?z))~

Каков будет ответ на следующие запросы?
~(?x next-to ?y in (1 (2 3) 4))~
~(?x next-to 1 in (2 1 3 1))~

Сначала расшифруем, как сформулировано правило.
Мы последовательно проходимся по выражению и спрашиваем, стоит ли искомый
элемент рядом с другим элементом в данном выражении. И так мы проходим до
конца выражения.

В первом запросе оба элемента не указаны. Соответственно, мы должны найти
все соседние элементы:
- 1 (2 3)
- (2 3) 4

Во втором запросе один из элементов конкретизирован. Соответственно, надо
найти элементы, соседние с 1.
- 2 1
- 3 1

~Упражнение 4.62.~
Определите правила, которые реализуют операцию last-pair из упражнения
2.17, которая возвращает последнюю пару непустого списка.

Проверьте Ваши правила на таких запросах, как
(last-pair (3) ?x), (last-pair (1 2 3) ?x) и (last-pair (2 ?x)
(3)). Правильно ли Ваши правила работают с запросами вида (last-pair ?x (3))?

Итак, нам нужен проход по списку и перед тем, как он кончится, мы должны
вернуть последний элемент.

#+BEGIN_SRC scheme
  ;; заключение: последняя пара от (?x) - это (?x)
  (rule (last-pair (?x) (?x)))

  ;; ?x -  последняя пара (?y . ?v)
  (rule (last-pair (?y . ?v) ?x)
        ;; если ?x - последняя пара (?v)
        (last-pair (?v) ?x))
#+END_SRC

~Упражнение 4.63~.
Следующая база данных (см. книгу Бытия, 4) содержит генеалогию сыновей
Ады вплоть до Адама, через Каина:
(сын Адам Каин)
(сын Каин Енох)
(сын Енох Ирад)
(сын Ирад Мехиаель)
(сын Мехиаель Мафусал)
(сын Мафусал Ламех)
(жена Ламех Ада)
(сын Ада Иавал)
(сын Ада Иувал)

Сформулируйте правила, такие как «Если S сын F , а F сын G, то S внук G»
и «Если W жена M , а S сын W , то S также сын M » (предполагается, что в библейские
времена это в большей степени соответствовало истине, чем теперь).
Эти правила должны позволить системе найти внука Каина; сыновей Ламеха;
внуков Мафусала. (В упражнении 4.69 можно найти правила, с помощью
которых выводятся более сложные родственные связи.)

#+BEGIN_SRC scheme
  ;; S - сын G
  (rule (внук ?s ?g)
        ;; если S - сын F
        (and (сын ?s ?f)
             ;; если F - cын G
             (сын ?f ?g)))
  ;; s - сын m
  (rule (сын ?s ?m)
        ;; если S - сын w
        (and (сын ?s ?w)
             ;; если w - жена m
             (жена ?w ?m)))
#+END_SRC

~Упражнение 4.64.~
Хьюго Дум по ошибке уничтожил в базе данных правило подчиняется (раздел
4.4.1). Обнаружив это, он быстро набивает правило заново, только, к
сожалению, по ходу дела вносит небольшое изменение:

#+BEGIN_SRC scheme
  (rule (подчиняется ?staff-person ?boss)
        (or (начальник ?staff-person ?boss)
            (and (подчиняется ?middle-manager ?boss)
                 (начальник ?staff-person ?middle-manager))))
#+END_SRC

Сразу после того, как Хьюго ввел информацию в систему, Кон Фиден хочет
посмотреть, кому подчиняется Бен Битобор. Он вводит запрос

~(подчиняется (Битобор Бен) ?who)~

После ответа система проваливается в бесконечный цикл. Объясните, почему.

Прежняя версия правила "подчиняется"
#+BEGIN_SRC scheme
  (rule (подчиняется ?staff-person ?boss)
        (or (начальник ?staff-prerson ?boss)
            (and (начальник ?staff-person ?middle-manager)
                 (подчиняется ?middle-manager ?boss))))
#+END_SRC

Правило направлено выяснить не только прямое подчинение, но и оксвенное:
к примеру, Бен сам себе начальник в своем отделе, но отдел в целом
подчиняется среднему менеджеру, а тот уже другому начальнику. Вот мы
хотим выяснить самого главного начальника.

Итак, запускается запрос ~(подчиняется (Битобор Бен) ?who)~. Переменная
~?staff-person~ связывается с ~(Битобор Бен)~, переменная ~?who~
связывается с  ~?boss~. Выполняем первое  выражение ~or~ (начальник
?staff-person ?boss). Но у нас boss неизвестен, или, предположим, Бен
пдчиняется не этому боссу.
Тогда выполняется второе выражение ~or~ :

(and (подчиняется ?middle-manager ?boss)
                 (начальник ?staff-person ?middle-manager))

В исходном виде правила выражения and имеют другой порядок. Таким
образом, мы сначала выясняем, кто средний менеджер у текущего работника, а затем
проверяем, подчиняется ли средний менеджер данному боссу. В верссии Хьюго
все наоборот. Мы еще не знаем значение переменной ~?boss~ ( сейчас оно
свзязано с ?who, чье значение неопределено), но и значение переменной
~?middle-meneger~ неизвестно, это фактически может быть любое имя из базы
данных. В результате мы породим огромное количество кадров (окружений)
для каждой комбинации начальник-подчиненный, и эти ветки не
смерживаются.

~Упражнение 4.65.~
П.Э. Фект, ожидая собственного продвижения по иерархии, дает запрос,
который находит всех шишек (используя правило шишка из раздела 4.4.1):
(шишка ?who)
К его удивлению, система отвечает

;;; Результаты запроса:
(шишка (Уорбак Оливер))
(шишка (Битобор Бен))
(шишка (Уорбак Оливер))
(шишка (Уорбак Оливер))
(шишка (Уорбак Оливер))

Почему система упоминает Оливера Уорбака четыре раза?

так выглядит правило "шишка":
#+BEGIN_SRC scheme
  (rule (шишка ?person)
        (and (начальник ?middle-manager ?person)
             (начальник ?x ?middle-manager)))
#+END_SRC

Шишкой считается человек, который является начальником среднего
менеджера, а менеджер является начальников для кого-то еще. То есть
шишка - это начальник начальника.

Соответственно, мы находим Оливера 4 раза, поскольку он является боссом
чьего-то босса 4 раза, а система выдает нам все ответы, соответствующие
запросу. С ее точки зрения Оливер - это просто значение переменной, она
не понимает, что это одно и то же значение и выводить его не нужно больше
1 раза.

~Упражнение 4.66~.
Бен работал над обобщением системы запросов так, чтобы можно было
собирать статистику о компании. Например, чтобы найти сумму зарплат всех
программистов, можно было бы сказать

#+BEGIN_SRC scheme
  (sum ?amount
       (and (должность ?x (компьютеры программист))
            (зарплата ?x ?amount)))
#+END_SRC

В общем случае новая система Бена допускает запросы вида:
(accumulation-function <переменная> <запрос-образец>)

где в виде ~accumulation-function~ могут выступать ~sum~ (сумма), ~average~
(среднее) или ~maximum~ (максимум). Бен думает, что реализовать это расширение будет
проще простого. Он просто скормит образец-запрос функции ~qeval~ и
получит поток кадров.
Затем он пропустит поток через функцию-отображение, которая из каждого кадра извлечет
значение указанной переменной, и получившийся поток значений отдаст
функции-накопителю.
Когда Бен заканчивает свою реализацию и собирается ее опробовать, мимо
проходит Пабло, все еще смущенный результатом запроса из упражнения
4.65. Когда Пабло показывает Бену полученный им от системы ответ, Бен
хватается за голову: «Моя простая схема накопления не будет работать!»

Что понял Бен? Опишите, как он мог бы исправить ситуацию.

Думаю, что Бен понял, что одни и те же результаты могут встречаться
несколько раз, а вернее столько, сколько система сочтет их подходящими
запросу. К примеру, если есть 2 записи о Бене, что он занимает должность
тестировщка и джуниора, то система вернет его зп дважды, хотя формально
она будет одна. Еще возможен вариант, что в разных кадрах фигурируют одни
и те же переменные, к примеру, данные о Бене. Соответственно, мы
посчитаем его зп столько раз, сколько встретим эти данные во всех
кадрах.

Чтоб исправить ситуацию, надо сделать так, чтоб одни и те же результаты
не выводились дважды. К примеру, можно было бы составить таблицу, куда бы
мы вносили все неповторяющиеся данные из кадров. Но это не очень рабочий
вариант, поскольку перед внесением каждой записи пришлось бы сравнивать
ее на идентичность со всеми предыдущими. Это крайне затратный способ для
больших баз данных.

~Упражнение 4.67.~
Придумайте, как в запросную систему можно вставить детектор циклов,
который избегает простых зацикливаний, вроде показанных в тексте и в
упражнении 4.64. Общая идея состоит в том, что система должна хранить в
каком-то виде историю текущей цепи рассуждений и не начинать
обработку запроса, если она уже над ним работает. Опишите, информация
какого вида (образцы и кадры) включается в историю и как можно проводить проверку. (После
того, как Вы изучите в деталях реализацию запросной системы из раздела
4.4.4, Вы можете захотеть изменить систему и включить в нее свой детектор циклов.)

~шпаргалка по запросной системе~
Итак, освежим общий механизм работы запросной системы.
У нас есть:
- запрос - то что мы хоти найти
- образец - запись из базы.
- сопоставитель - сопоставляет запрос с образцом. Принимает на вход
  запрос, образец и кадр. Если запрос совпадает с образцом в кадре,
  т.е. не противоречит уже существующим в кадре связваниям, то
  сопостаитель порождает расширение кадра, куда включаются связывания для
  переменных запроса с переменными образца. Иначе возвращается
  специальный символ, который говорит, что сопоставление в данном кадре
  не найдено.
- поток кадров - тут все понятно. Мы получаем на вход поток имеющихся
  кадров, и либо генерим новый поток с новыми кадрами, либо просто идем
  дальше. Результат запроса - это тоже поток кадров, который содержит в
  себе все возможные кадры, для которых сопоставление образца и запроса
  прошло успешно.
- унификация - это процесс, благодаря которому у нас возможно
  сопоставление, по-другому это сопоставление в широком смысле слова.
  Унификатор берет два образеца (в теории, любых) и проверяет, возможно
  ли просвоить их переменным такие значения, чтоб образцы стали
  одинаковыми.

Запрос получает на вход поток кадров. В каждом кадре сопоставитель
просматривает данные из базы, и либо генерирует специальный символ,
указывающий, что текущая запись не подходит под заданный запрос, либо
генерирует расширение кадра, в котором связывает переменные из запроса с
значениями из записей. Этот процесс происходит до тех пор, пока для всех
каров не будут просмотрены все записи в базе. На выходе мы получим поток
кадров, в каждом из которых есть сопоставление между запросом и
найденными записями.

Ответ на задание:
По идее, у нас уже есть история поиска - это наш поток кадров и
расширения для каждого кадра, которые генерирует сопоставитель. Прежде
чем добавить новый кадр в поток, мы могли бы проверить все кадры до
него. Если у нас уже есть точно такой же кадр с точно такими же
связываниями для запроса, то мы можем считать, что вошли в цикл и
аварийно завершить вычисления, вернув юзеру сообщение об ошибке.

~Упражнение 4.68.~
Определите правила, с помощью которых реализуется операция reverse из
упражнения 2.18, возвращающая список, элементы которого те же, что и в
исходном, но идут в обратном порядке.
(Подсказка: используйте append-to-form.) Могут ли Ваши правила ответить и на запрос
(reverse (1 2 3) ?x), и на (reverse ?x (1 2 3))?

Так выглядит правило append-to-form:
#+BEGIN_SRC scheme
  (rule (append-to-form () ?y ?y))

  (rule (append-to-form (?u . ?v) ?y (?u . ?z))
        (append-to-form ?v ?y ?z))
#+END_SRC

Словами это переводится как: apprnd от пустого списка и y = y. И для
любых u, y, v и z справедливо правило, что append от (cons u v) и y =
(cons u z), если append от v и y = z.

То есть:  append от (cons '(a) '(b)) и  '(c) = (cons '(a) '(b c)), если
append от '(b) и '(с) = '(b c)

Так выглядит reverse из упражнения 2.18
#+BEGIN_SRC scheme
  (define (reverse lst)
    (define (iter lst new-lst)
      (if (null? lst)
          new-lst
          (iter (cdr lst) (cons (car lst) new-lst))))
    (iter lst (list)))
#+END_SRC

Сформируем словами правила для reverse:
1. reverse от пустого списка = пустой списо
2. reserse от ?x = y?, если append-to-form от (reverse cdr ?x) и (car ?x)
   = ?y

#+BEGIN_SRC scheme
  (rule (reverse () ?y ()))

  (rule (reverse (u? . ?v) ?y)
        (and (reverse ?v ?reversed)
             (append-to-form ?reversed ?u ?y)))

#+END_SRC

Система не может отвечать и на (reverse (1 2 3) ?x), и на
(reverse ?x (1 2 3)), поскольку система ожидает, первым будет идти
список, а не "неизвестное", в который этот список должен превратиться.

~Упражнение 4.69~.
Начав с базы данных и правил, сформулированных Вами в упражнении 4.63,
постройте правила для добавления приставок «пра» в отношение
внук. Система должна уметь понять, что Ирад — правнук Адама, а Иавал и
Иувал приходятся Адаму прапрапрапраправнуками. (Подсказка: представляйте,
например, утверждение об Ираде как ((пра внук) Адам Ирад). Напишите правила,
которые определяют, заканчивается ли список словом внук. С помощью этого
определите правило, которое позволяет вывести отношение
((пра . ?rel) ?x ?y), где список ?rel оканчивается на внук.) Проверьте
свои правила на запросах ((пра внук) ?g ?ggs) и (?relationship Адам Ирад).

~Правла и база данных из упр. 4.63~

(сын Адам Каин)
(сын Каин Енох)
(сын Енох Ирад)
(сын Ирад Мехиаель)
(сын Мехиаель Мафусал)
(сын Мафусал Ламех)
(жена Ламех Ада)
(сын Ада Иавал)
(сын Ада Иувал)

#+BEGIN_SRC scheme
  ;; S - сын G
  (rule (внук ?s ?g)
        ;; если S - сын F
        (and (сын ?s ?f)
             ;; если F - cын G
             (сын ?f ?g)))
  ;; s - сын m
  (rule (сын ?s ?m)
        ;; если S - сын w
        (and (сын ?s ?w)
             ;; если w - жена m
             (жена ?w ?m)))
#+END_SRC

Напишем правила, которые определяют, заканчивается ли список словом
"внук". У правил будет меия grandson-end?

#+BEGIN_SRC scheme
  (rule (grandson-end? (grandson)))

  ;; рекурсивный проход по списку
  (rule (grandson-end? (?x . ?rest))
        (grandson-end? ?rest))

  (rule ((grandson) ?x ?y)
               (grandson ?x ?y))
#+END_SRC

Теперь пишем правило, которое определяет, является ли "а" правнуком "б"

#+BEGIN_SRC scheme
  (rule ((great . ?rel) ?x ?y)
        (and (grandson-end? ?rel)
             (son ?x ?z)
                         (?rel ?z ?y)))
#+END_SRC

~Разбор кода реализации запросной системы~

Для реализации системы необходимо использовать код, связанный с таблицами
из главы 3.

Все для создания таблиц:
#+BEGIN_SRC scheme
  (define (lookup key table)
    (let ((record (assoc key (cdr table))))
      (if record
          (cdr record)
          false)))

  (define (assoc key records)
    (cond ((null? records) false)
          ((equal? key (caar records)) (car records))
          (else (assoc key (cdr records)))))

  (define (insert! key value table)
    (let ((record (assoc key (cdr table))))
      (if record
          (set-cdr! record value)
          (set-cdr! table
                    (cons (cons key value) (cdr table)))))
    'ok)

  (define (make-table)
    (list '*table*))

  (define (lookup key-1 key-2 table)
    (let ((subtable (assoc key-1 (cdr table))))
      (if subtable
          (let ((record (assoc key-2 (cdr subtable))))
            (if record
                (cdr record)
                false))
          false)))

  (define (insert! key-1 key-2 value table)
    (let ((subtable (assoc key-1 (cdr table))))
      (if subtable
          (let ((record (assoc key-2 (cdr subtable))))
            (if record
                (set-cdr! record value)
                (set-cdr! subtable
                          (cons (cons key-2 value)
                                (cdr subtable)))))
          (set-cdr! table
                    (cons (list key-1
                                (cons key-2 value))
                          (cdr table)))))
    'ok)

  (define (make-table)
    (let ((local-table (list '*table*)))
      (define (lookup key-1 key-2)
        (let ((subtable (assoc key-1 (cdr local-table))))
          (if subtable
              (let ((record (assoc key-2 (cdr subtable))))
                (if record
                    (cdr record)
                    false))
              false)))

      (define (insert! key-1 key-2 value)
        (let ((subtable (assoc key-1 (cdr local-table))))
          (if subtable
              (let ((record (assoc key-2 (cdr subtable))))
                (if record
                    (set-cdr! record value)
                    (set-cdr! subtable
                              (cons (cons key-2 value)
                                    (cdr subtable)))))
              (set-cdr! local-table
                        (cons (list key-1
                                    (cons key-2 value))
                              (cdr local-table)))))
        'ok)

      (define (dispatch m)
        (cond ((eq? m 'lookup-proc) lookup)
              ((eq? m 'insert-proc!) insert!)
              (else (error "Неизвестная операция -- TABLE" m))))
      dispatch))


  (define operation-table (make-table))
  (define get (operation-table 'lookup-proc))
  (define put (operation-table 'insert-proc!))
#+END_SRC

~Управляющий цикл, вычислитель, сопоставитель, унификатор~
#+BEGIN_SRC scheme
  ;; УПРАВЛЯЮЩИЙ ЦИКЛ
  (define (prompt-for-input string)
    (newline) (newline) (display string) (newline))

  (define (announce-output string)
    (newline) (display string) (newline))

  (define input-prompt ";;; Ввод запроса:")

  (define output-prompt ";;; Результаты запроса:")

  ;; управляющий цикл
  ;; считаем запросом все, что не утверждение или правило
  (define (query-driver-loop)
    (prompt-for-input input-prompt)
    (let ((q (query-syntax-process (read))))
      (cond ((assertion-to-be-added? q)
             (add-rule-or-assertion! (add-assertion-body q))
             (newline)
             (display "Утверждение добавлено в базу данных.")
             (query-driver-loop))
            (else
             (newline)
             (display output-prompt)
             (display-stream
              (stream-map
               (lambda (frame)
                 ;; (display "query-driver-loop frame \n")
                 (instantiate q
                              frame
                              (lambda (v f)
                                (contract-question-mark v))))
               (qeval q (singleton-stream '()))))
             (query-driver-loop)))))

  ;;выполняется если переменные из запроса не удается конкретизировать (связать со значением)
  (define (instantiate exp frame unbound-var-handler)
    (define (copy exp)
      (cond ((var? exp)
             (let ((binding (binding-in-frame exp frame)))
               (if binding
                   (copy (binding-value binding))
                   (unbound-var-handler exp frame))))
            ((pair? exp)
             (cons (copy (car exp)) (copy (cdr exp))))
            (else exp)))
    (copy exp))

  ;; ВЫЧИСЛИТЕЛЬ

  ;; вычислитель запросной системы
  ;; принимает на вход запрос и поток кадров, возвращает поток расширенных кадров
  (define (qeval query frame-stream)
    ;; (display "\n qeval \n")
    ;; (display-stream frame-stream)
    ;; (newline)
    ;; получить нужный вычислитель, соответствующий типу запроса из таблицы
    (let ((qproc (get (type query) 'qeval)))
      ;; если такой вычислитель есть
      (if qproc
          ;; применить его к содержимому запроса
          (begin
            ;; (display "\n qproc \n")
            ;; (display qproc)
            (qproc (contents query) frame-stream))
          ;; иначе считаем запрос простым и исполняем его по-другому
          (simple-query query frame-stream))))

  ;; обрабатывает простые запросы
  ;; принимает на вход простой запрос и поток кадров, возвращает поток расширенных кадров
  (define (simple-query query-pattern frame-stream)
    ;; соединяет все полученные потоки в один, который показывает все способы, которыми
    ;; можно расширить все полученные кадры для успешного (?) сопоставления с запросом
    ;; (display " \n simple-query \n")
    ;; (display-stream frame-stream)
    ;; (newline)

    ;; (display " \n query-pattern ")
    ;; (display query-pattern)
    ;; (newline)

    (stream-flatmap
     (lambda (frame)
       ;; сливаем потоки от find-assertions и apply-rules, получаем поток, перечисляющий все
       ;; способы, которыми можно удовлетворить данный запрос в текущем кадре
       (stream-append-delayed
        ;; сопоставление запроса со всеми подходящими утверждениями из БД в каждом кадре
        (find-assertions query-pattern frame)
        ;; применяем все подходящие правила из БД в каждом кадре
        (delay (apply-rules query-pattern frame))))
     frame-stream))

  ;; обрабатывает составные запросы с формой and
  ;; сначала вычисляет первый запрос, получая поток расширенных кадров для него
  ;; затем используя этот поток вычисляет остальные запросы
  ;; видимо, все запросы после первого выступают в роли фильтров по отношению к потоку кадров
  ;; который полчается в результате вычисления первого запроса
  (define (conjoin conjuncts frame-stream)
    ;; (display " \n conjoin \n ")
    ;; (display " \n frame-stream \n ")
    ;; (display-stream frame-stream)
    (if (empty-conjunction? conjuncts)
        frame-stream
        (conjoin (rest-conjuncts conjuncts)
                 (qeval (first-conjunct conjuncts)
                        frame-stream))))

  ;; если qeval встретит запрос с and, он вызове conjoin
  (put 'and 'qeval conjoin)

  ;; обрабатывает составные запросы с формой or
  (define (disjoin disjuncts frame-stream)
    (if (empty-disjunction? disjuncts)
        the-empty-stream
        (interleave-delayed
         (qeval (first-disjunct disjuncts) frame-stream)
         (delay (disjoin (rest-disjuncts disjuncts)
                         frame-stream)))))

  (put 'or 'qeval disjoin)

  ;; обрабатывает запросы с not
  ;; сначала пытаемся расширить каждый кадр так, чтоб удовлетворить отрицаемый запрос
  ;; и вот если это не вышло, включаем данный кадр в поток-результат
  (define (negate operands frame-stream)
    (stream-flatmap
     (lambda (frame)
       (if (stream-null? (qeval (negated-query operands)
                                (singleton-stream frame)))
           (singleton-stream frame)
           the-empty-stream))
     frame-stream))

  (put 'not 'qeval negate)

  ;; работает как фильтр, похож на not
  ;; заданный предикат применяется к каждому кадру.
  ;; кадры, для которых предикат выдает ложь, исключаются из потока
  (define (lisp-value call frame-stream)
    (stream-flatmap
     (lambda (frame)
       (if (execute
            (instantiate
             call
             frame
             ;; ошибка если встретили неизвестную пременную
             (lambda (v f)
               (error "Неизвестная переменная -- LISP-VALUE" v))))
           (singleton-stream frame)
           the-empty-stream))
     frame-stream))

  (put 'lisp-value 'qeval lisp-value)

  ;; применяет предикат к выражению
  ;; apply из нижележащего лиспа применяет предикат,
  ;; вычисляя его через eval нижележащего лиспа,
  (define (execute exp)
    (apply (eval (predicate exp) user-initial-environment)
           (args exp)))

  ;; порождает запрос, который всегда удовлетворяется, пропуская через себя все входные кадры
  (define (always-true ignore frame-stream) frame-stream)

  (put 'always-true 'qeval always-true)

  ;; принимает на вход образец и кадр
  ;; возвращает поток расширенных кадров, которые получаются от сопоставления образца с
  ;; каждой подходящей записью базы
  ;; видимо, 1 успешное сопоставление = 1 новый кадр
  (define (find-assertions pattern frame)
    (stream-flatmap (lambda (datum)
                      ;; произвести сопоставление утверждения и образца в текущем кадре
                      (check-an-assertion datum pattern frame))
                    ;; находим все устверждения базы, которые стоит проверять
                    ;; на сопоставление с образцом
                    (fetch-assertions pattern frame)))

  ;; СОПОСТАВИТЕЛЬ
  ;; принимает на вход образец, запись базы и кадр
  ;; возвращет поток из одного кадра в случае успеха и пустой поток в случае провала
  (define (check-an-assertion assertion query-pat query-frame)
    (let ((match-result
           (pattern-match query-pat assertion query-frame)))
      (if (eq? match-result 'failed)
          the-empty-stream
          (singleton-stream match-result))))

  ;; проверяет образец и запись на совпадение
  (define (pattern-match pat dat frame)
    ;; сопоставление провалено
    (cond ((eq? frame 'failed) 'failed)
          ;; сопоставление успешно, вернуть кадр
          ((equal? pat dat) frame)
          ;; если образец - переменная, расширить имеющийся кадр, связать переменную с
          ;; данными, если это не проиворечит связываниям в кадре
          ((var? pat) (extend-if-consistent pat dat frame))
          ;; если образец и запись - пары
          ;; рекурсивно элементы обоих образцов, при каждом сравнении порождая новый кадр
          ;; и производя ноыое сопоставление уже в нем
          ;; так мы можем убедиться, что новое связывание не противоречит предыдущим
          ((and (pair? pat) (pair? dat))
           (pattern-match (cdr pat)
                          (cdr dat)
                          (pattern-match (car pat)
                                         (car dat)
                                         frame)))
          ;; в противном случае сопоставление провалено
          (else 'failed)))

  ;; расширяет кадр, добавляя к нему новое связывание, если это не противоречит остальным
  ;; связываниям
  (define (extend-if-consistent var dat frame)
    ;; пытаемся получить связывание для переменной
    (let ((binding (binding-in-frame var frame)))
      ;; если получили
      (if binding
          ;; вызываем сопоставитель с данным вязыванием
          ;; видимо, чтоб проверить, не противоречит ли оно уже имеющимся связываниям в кадре
          (pattern-match (binding-value binding) dat frame)
          ;; иначе добавляем новое связывание в кадр для переменной
          (extend var dat frame))))

  ;; ПРАВИЛА И УНИФИКАЦИЯ

  ;; принимает на вход образец и кадр
  ;; порождает поток расширенных кадров, применяя правила из БД к образцу
  (define (apply-rules pattern frame)
    ;; (display "apply-rules\n")
    ;; (display-stream (fetch-rules pattern frame))
    ;; (display "end\n")
    (stream-flatmap (lambda (rule)
                      ;; (display "lambda\n")
                      (apply-a-rule rule pattern frame))
                    (fetch-rules pattern frame)))

  ;; применяет правило к образцу в кадре, если унификация образца с правилом прошла успешно
  (define (apply-a-rule rule query-pattern query-frame)
    ;; переименовывает все переменные в правиле, чтоб переменные из разных применений одного
    ;; правила перекрывали друг друга
    (let ((clean-rule (rename-variables-in rule)))
      (display "clean-rule\n")
      (display clean-rule)
      (newline)
      ;; пытаемся унифицировать образец и правило
      (let ((unify-result
             (unify-match query-pattern
                          (conclusion clean-rule)
                          query-frame)))
        ;; в случае провала
        (if (eq? unify-result 'failed)
            ;; возвращаем пустой поток
            the-empty-stream
            ;; иначе применяем тело правила к результату унификации
            (qeval (rule-body clean-rule)
                   (singleton-stream unify-result))))))

  (define (apply-a-rule rule query-pattern query-frame)
    ;; переименовывает все переменные в правиле, чтоб переменные из разных применений одного
    ;; правила перекрывали друг друга
    (let ((clean-rule rule))
      (display "clean-rule\n")
      (display clean-rule)
      (newline)
      ;; пытаемся унифицировать образец и правило
      (let ((unify-result
             (unify-match query-pattern
                          (conclusion clean-rule)
                          query-frame)))
        ;; в случае провала
        (if (eq? unify-result 'failed)
            ;; возвращаем пустой поток
            the-empty-stream
            ;; иначе применяем тело правила к результату унификации
            (qeval (rule-body clean-rule)
                   (singleton-stream unify-result))))))

  ;; переименовывает все переменные в правиле
  ;; каждому применеию правила присваивается идентификацинный уникальный номер, а затем
  ;; этот же номер добавляется к исходным именам переменных в правиле
  (define (rename-variables-in rule)
    ;; получили идентификатор
    (let ((rule-application-id (new-rule-application-id)))
      ;; обход правила
      (define (tree-walk exp)
        ;; если выражение = переменная
        (cond ((var? exp)
               ;; генерим для нее новое имя
               (make-new-variable exp rule-application-id))
              ;; иначе рекурсивно обходим выражение, пока не доберемся до каждой переменной
              ((pair? exp)
               (cons (tree-walk (car exp))
                     (tree-walk (cdr exp))))
              (else exp)))
      (tree-walk rule)))

  ;; алгоритм унификации
  ;; принимает 2 образца и кадр. Возвращает расширенный кадр в случае успеха и failed в
  ;; случае неудачи
  (define (unify-match p1 p2 frame)
    (display "unify-match\n")
    (display p1)
    (newline)
    (display p2)
    (newline)
    (display frame)
    (newline)
    ;; если провал - вернуть failed
    (cond ((eq? frame 'failed) 'failed)
          ;; образны равны, вернуть кадр
          ((equal? p1 p2) frame)
          ;; если образец1 переменная - попробовать расширить данный кадр связыванием для
          ;; этой переменной
          ((var? p1) (extend-if-possible p1 p2 frame))
          ;; аналогично для второго образца
          ((var? p2) (extend-if-possible p2 p1 frame))
          ;; если образцы - пары
          ;; то попробовать последовательно унифицировать каждый элемент
          ((and (pair? p1) (pair? p2))
           (unify-match (cdr p1)
                        (cdr p2)
                        (unify-match (car p1)
                                     (car p2)
                                     frame)))
          (else 'failed)))

  ;; расширяет кадр при унификации, если это возможно
  (define (extend-if-possible var val frame)
    ;; пытаемся получить связывание для переменной в кадре
    (let ((binding (binding-in-frame var frame)))
      ;; если получили, то пробуем унифицировать образец, имея данное связывание
      ;; (display "extend-if-possible \n")
      ;; (display var)
      ;; (newline)
      ;; (display val)
      ;; (newline)
      ;; (display binding)
      ;; (newline)
      (cond (binding
             (unify-match
              (binding-value binding) val frame))
            ;; если предполагаемое значение само является переменной
            ((var? val)
             ;; то пробуем получить связывание для него
             (let ((binding (binding-in-frame val frame)))
               ;; и если удалось, пробуем унифицировать образец с ним
               (if binding
                   (unify-match
                    var (binding-value binding) frame)
                   (extend var val frame))))
            ;; если мы осуществляем попытку связать переменную с образцом, который сам ее
            ;; содержит и от нее зависит, то мы отвергаем такое связывание
            ((depends-on? val var frame)
             'failed)
            ;; если никаких связываний не нашлось, то мы просто связываем var и val
            ;; и создаем расширенный кадр
            (else (extend var val frame)))))

  ;; работает как предикат, проверяет, зависит ли выражение, которое пытаются сделать
  ;; значением переменной образца, от самой переменной
  (define (depends-on? exp var frame)
    ;; рекурсивный обход выражения
    (define (tree-walk e)
      ;; если выражение = переменная
      (cond ((var? e)
             ;; и при этом это заданная переменная, вернуть true
             (if (equal? var e)
                 true
                 ;; иначе попробовать ее связать в данном кадре
                 (let ((b (binding-in-frame e frame)))
                   ;; если связывание получено, проверяем его
                   (if b
                       (tree-walk (binding-value b))
                       ;; иначе провал
                       false))))
            ;; если выражение - пара, то рекурсивно его обходм
            ((pair? e)
             (or (tree-walk (car e))
                 (tree-walk (cdr e))))
            ;; иначе провал
            (else false)))
    (tree-walk exp))

  (define (tagged-list? exp tag)
    (if (pair? exp)
        (eq? (car exp) tag)
        #f))
#+END_SRC

Организация БД.

Все утверждения хранятся в общем потоке. Есть отдельные потоки, которые
включают в себя утверждения, carы которых - это константные уникальные
символы. Такие потоки хранятся в таблице, ключами служат как раз эти
уникальные идентификаторы.
 В первую очередь мы будем проверять запросы на такие константные
символы, чтоб сократить посик по БД.

#+BEGIN_SRC scheme
  ;; поток всех утверждений
  (define THE-ASSERTIONS the-empty-stream)

  (define (fetch-assertions pattern frame)
    (if (use-index? pattern)
        (get-indexed-assertions pattern)
        (get-all-assertions)))

  ;; получить все утверждения
  (define (get-all-assertions) THE-ASSERTIONS)

  ;; получить все утверждения из таблицы
  (define (get-indexed-assertions pattern)
    (get-stream (index-key-of pattern) 'assertion-stream))

  ;; ищем поток утверждений в таблице
  ;; возвращает поток в случае успеха и пустой поток в случае провала
  (define (get-stream key1 key2)
    (let ((s (get key1 key2)))
      (if s s the-empty-stream)))

  ;; все правила
  (define THE-RULES the-empty-stream)

  (define (fetch-rules pattern frame)
    (if (use-index? pattern)
        (get-indexed-rules pattern)
        (get-all-rules)))

  ;; получить все правила
  (define (get-all-rules) THE-RULES)

  ;; получить все правила, car заключения которых имеют переменную
  ;; если образец имеет идентификатор в car, а правило имеет в car заключения переменную,
  ;; то сопоставление правила и образца будет удачным. Если, конечно, образец и правило не
  ;; противоречат друг другу в остальном.
  (define (get-indexed-rules pattern)
    (stream-append
     (get-stream (index-key-of pattern) 'rule-stream)
     (get-stream '? 'rule-stream)))

  ;; добавление правила или утверждения в таблицу (?)
  (define (add-rule-or-assertion! assertion)
    (if (rule? assertion)
        (add-rule! assertion)
        (add-assertion! assertion)))

  ;; добавление утверждения
  (define (add-assertion! assertion)
    ;; пробуем проиндексировать утверждение (записать в БД),
    ;; будет проиндексировано если его car - константный id
    (store-assertion-in-index assertion)
    ;; записываем утверждение в общий поток
    (let ((old-assertions THE-ASSERTIONS))
      (set! THE-ASSERTIONS
            (cons-stream assertion old-assertions))
      'ok))

  ;; добавление правила
  (define (add-rule! rule)
    (display "add-rule!\n")
    ;; пробуем проиндексировать правило
    (store-rule-in-index rule)
    ;; записываем правило в общий поток правил
    ;; будет проиндексировано если car его заключения  - константный id или переменная
    (let ((old-rules THE-RULES))
      (set! THE-RULES (cons-stream rule old-rules))
      'ok))

  ;; индексирует (записывает в БД) утверждение, если это возможно
  (define (store-assertion-in-index assertion)
    ;; индексируемо?
    (if (indexable? assertion)
        ;; да, получаем ключ
        (let ((key (index-key-of assertion)))
          ;; получаем поток, куда запишем утверждение
          (let ((current-assertion-stream
                 (get-stream key 'assertion-stream)))
            ;; кладем поток с ключом и новым утверждением в таблицу
            (put key
                 'assertion-stream
                  (cons-stream assertion
                               current-assertion-stream))))))

  ;; индексирует (записывает в БД) правило, если это возможно
  ;; работает аналогично индексации утверждения
  (define (store-rule-in-index rule)
    (let ((pattern (conclusion rule)))
      (if (indexable? pattern)
          (let ((key (index-key-of pattern)))
            (display "key \n")
            (display key)
            (newline)
            (let ((current-rule-stream
                   (get-stream key 'rule-stream)))
              (put key
                   'rule-stream
                    (cons-stream rule
                                 current-rule-stream)))))))

  ;; предикат, отпределяющий, возможно ли проиндексировать данный образец
  (define (indexable? pat)
    (or (constant-symbol? (car pat))
        (var? (car pat))))

  ;; селектор, возвращающий ключ образца
  ;; это всегда либо константный id, либо переменная, которая начинается с '?
  (define (index-key-of pat)
    (let ((key (car pat)))
      (if (var? key) '? key)))

  ;; предикат, определяющий, есть ли у образца константный id
  (define (use-index? pat)
    (constant-symbol? (car pat)))
#+END_SRC


~Упражнение 4.70.~
Какова цель выражений let в процедурах add-assertion! и add-rule!? Что
неправильно в следующем варианте add-assertion!? Подсказка: вспомните определение
бесконечного потока единиц из раздела 3.5.2: (define ones (cons-stream 1 ones)).

#+BEGIN_SRC scheme
  (define (add-assertion! assertion)
    (store-assertion-in-index assertion)
    (set! THE-ASSERTIONS
          (cons-stream assertion THE-ASSERTIONS))
    'ok)
#+END_SRC

let нужен, чтоб е создавать бесконечный поток. Мы получаем содержимое
глобальной переменной, а это сам поток, затем соединяем его с новым
утверждением и новый поток присваиваем глобальной переменной. А в
add-assertion!, который дан здесь, мы создаем именно бесконечный поток. В
результате потопытка перебрать все утверждения из потока приведет к
зацикливанию.

~операции над потоками~

#+BEGIN_SRC scheme
  >;; принимает 2 потока, один из которых дополнительно задержан
  ;; соединяет 2 потока в один
  (define (stream-append-delayed s1 delayed-s2)
    (if (stream-null? s1)
        (force delayed-s2)
        (cons-stream
         (stream-car s1)
         (stream-append-delayed (stream-cdr s1) delayed-s2))))

  ;; принимает 2 потока, один из которых дополнительно задержан
  ;; перемешивает 2 потока в один
  (define (interleave-delayed s1 delayed-s2)
    (if (stream-null? s1)
        (force delayed-s2)
        (cons-stream
         (stream-car s1)
         (interleave-delayed (force delayed-s2)
                             (delay (stream-cdr s1))))))

  ;; применяет процедуру ко всем кадрам потока, а затем результат применений (расширенные
  ;; кадры) собирает в единый поток
  (define (stream-flatmap proc s)
    (flatten-stream (stream-map proc s)))

  (define (flatten-stream stream)
    (if (stream-null? stream)
        the-empty-stream
        (interleave-delayed
         (stream-car stream)
         (delay (flatten-stream (stream-cdr stream))))))

  ;; создание одноэлементного потока
  (define (singleton-stream x)
    (cons-stream x the-empty-stream))

  ;; возвращает тип выражения
  (define (type exp)
    (if (pair? exp)
        (car exp)
        (error "Неизвестное выражение TYPE" exp)))

  ;; возвращает содержимое выражения
  (define (contents exp)
    (if (pair? exp)
        (cdr exp)
        (error "Неизвестное выражение CONTENTS" exp)))

  ;; предикат распознает, когда юзер хочет добавить утверждение, т.е. распознает синтаксис
  (define (assertion-to-be-added? exp)
    (eq? (type exp) 'assert!))


  (define (add-assertion-body exp)
    (car (contents exp)))

  (define (empty-conjunction? exps) (null? exps))

  (define (first-conjunct exps) (car exps))

  (define (rest-conjuncts exps) (cdr exps))

  (define (empty-disjunction? exps) (null? exps))

  (define (first-disjunct exps) (car exps))

  (define (rest-disjuncts exps) (cdr exps))

  (define (negated-query exps) (car exps))

  (define (predicate exps) (car exps))

  (define (args exps) (cdr exps))

  (define (rule? statement)
    (tagged-list? statement 'rule))

  (define (conclusion rule) (cadr rule))

  (define (rule-body rule)
    (if (null? (cddr rule))
        '(always-true)
        (caddr rule)))

  ;; преобразование синтаксиса для повышения эффективности обработки запросов
  ;; выражение (должность ?x ?y) превратится в (должность (? x)  (? y))
  (define (query-syntax-process exp)
    (map-over-symbols expand-question-mark exp))

  (define (map-over-symbols proc exp)
    (cond ((pair? exp)
           (cons (map-over-symbols proc (car exp))
                 (map-over-symbols proc (cdr exp))))
          ((symbol? exp) (proc exp))
          (else exp)))

  (define (expand-question-mark symbol)
    (let ((chars (symbol->string symbol)))
      (if (string=? (substring chars 0 1) "?")
          (list '?
                 (string->symbol
                  (substring chars 1 (string-length chars))))
          symbol)))

  (define (var? exp)
    (tagged-list? exp '?))

  (define (constant-symbol? exp) (symbol? exp))

  ;; счетчик для генеринга константных идентификаторов
  (define rule-counter 0)

  ;; созддание нового идентификатора
  (define (new-rule-application-id)
    (set! rule-counter (+ 1 rule-counter))
    rule-counter)

  ;; создание переменной с добавлением к ней идентификатора (нужно, чтоб при применении
  ;; правила к разным кадрам переменные не перекрывали друг друга, так что при каждом
  ;; применении к переменной добавляется уникальный новый идентификатор)
  (define (make-new-variable var rule-application-id)
    (cons '? (cons rule-application-id (cdr var))))

  ;; преобразование всех несвязанных переменных к их изначальному виду
  ;; т.е. если на вход система получила ?x, во время попыток связывания мы полсили ?7x, но
  ;; связывания не нашли, то на выходе вернем ?x
  (define (contract-question-mark variable)
    (string->symbol
    (string-append "?"
                    (if (number? (cadr variable))
                        (string-append (symbol->string (caddr variable))
                                       "-"
                                       (number->string (cadr variable)))
                        (symbol->string (cadr variable))))))

  (define (display-stream s)
    (stream-for-each display-line s))

  (define (display-line x)
    (newline)
    (display x))

  (define (stream-ref s n)
    (if (= n 0)
        (stream-car s)
        (stream-ref (stream-cdr s) (- n 1))))

  (define (stream-map proc s)
    (if (stream-null? s)
        the-empty-stream
        (cons-stream (proc (stream-car s))
                     (stream-map proc (stream-cdr s)))))

  (define (stream-for-each proc s)
    (if (stream-null? s)
        'done
         (begin (proc (stream-car s))
                (stream-for-each proc (stream-cdr s)))))
#+END_SRC

~кадры и связывания~

Кадры представляются аналогично кадрам в предыдущих разделах - это списки
связываний, где каждый подсписок имеет вид (переменная значение)

#+BEGIN_SRC scheme
  (define (make-binding variable value)
    (cons variable value))

  (define (binding-variable binding)
    (car binding))

  (define (binding-value binding)
    (cdr binding))

  (define (binding-in-frame variable frame)
    (assoc variable frame))

  (define (extend variable value frame)
    (cons (make-binding variable value) frame))
#+END_SRC


~тестовые утверждения и правила~

#+BEGIN_SRC scheme
  (assert! (address (Bitobor Ben) (Slammerwill (R Road) 10)))
  (assert! (position (Bitobor Ben) (computers guru)))
  (assert! (salary (Bitobor Ben) 60000))


  (assert! (address (Hacker Lisa P) (Cambridge (Massachusetts Avenue) 78)))
  (assert! (position (Hacker Lisa P) (computers programmer)))
  (assert! (salary (Hacker Lisa P) 40000))

  (assert! (boss (Hacker Lisa P) (Bitobor Ben)))

  (assert! (address (Fect Pablo E) (Cambridge (Ames Street) 3)))
  (assert! (position (Fect Pablo E) (computers programmer)))
  (assert! (salary (Fect Pablo E) 35000))

  (assert! (boss (Fect Pablo E) (Bitobor Ben)))

  (assert! (address (Popravich Daiko) (Boston (Bay State Road) 22)))
  (assert! (position (Popravich Daiko) (computers programmer)))
  (assert! (position (Popravich Daiko) (junior programmer)))

  (assert! (salary (Popravich Daiko) 25000))

  (assert! (boss (Popravich Daiko) (Bitobor Ben)))

  (assert! (boss (Sofia S) (Bitobor Ben)))
  (assert! (boss (Sofia S) (Nill Akers)))
  (assert! (address (Sofia S) (Boston (Bay State Road) 22)))
#+END_SRC


#+BEGIN_SRC scheme
  (assert! (rule (same ?x ?x)))

  (assert! (rule (leaves-near ?person-1 ?person-2)
                 (and (address ?person-1 (?town . ?rest-1))
                      (address ?person-1 (?town . ?rest-2))
                      (not (same ?person-1 ?person-2)))))
#+END_SRC

~Упражнение 4.71.~
Хьюго Дум не понимает, почему процедуры simple-query и disjoin
реализованы через явные операции delay, а не следующим образом:

#+BEGIN_SRC scheme
  (define (simple-query query-pattern frame-stream)
    (stream-flatmap
     (lambda (frame)
       (stream-append (find-assertions query-pattern frame)
                      (apply-rules query-pattern frame)))
     frame-stream))ss

  (define (disjoin disjuncts frame-stream)
    (if (empty-disjunction? disjuncts)
        the-empty-stream
        (interleave
         (qeval (first-disjunct disjuncts) frame-stream)
         (disjoin (rest-disjuncts disjuncts) frame-stream))))
#+END_SRC

stream-append-delayed и interleave-delayed в оригинальных версиях функций
позволяют в некоторых случаях это откладывает зацикливание. Допустим, мы
ввели простой зопрос (супруг Микки ?x), у нас есть соответствующее
утвержление (супруг Микки Минни) и правило
(rule (супруг ?x ?y)
(супруг ?y ?x))), cогласно которому если Микки супруг Минни, то она
супруг Микки. Проблема в том, что такое правило приводит к зацикливаю. Но
если мы будем использовать stream-append-delayed вместо stream-append, то
получим поток, в котором следуют сначала все подходящие утверждения, а
затем результат применения всех правил. Поскольку нас устроит утверждение
(супруг Микки Минни), yам не придется пользоваться правилом "супруг", nfк
мы избежим зацикливания.

Аналогичная ситуация может возникнуть, если мы введем составной вопрос с
формой or (они опрабатываются disjoin), который содержит в себе
зацикливание. с interleave-delayed у нас есть шас его избежать

~Упражнение 4.72.~
Почему adjoin (на самом деле disjoin, там опечатка) и stream-flatmap
чередуют потоки, а не просто их сцепляют? Приведите примеры, которые
показывают, что чередование работает лучше.
(Подсказка: зачем мы пользовались interleave в разделе 3.5.3?)

Ответ: у нас могут быть потенциально бесконечные потоки. Следовательно,
если мы попытаемся соединить элементы двух бесконечных потоков
последовательно, т.е. все из первого, а потом все из второго, то мы
навечно зависнем на неисчерпаемом первом потоке.

~Упражнение 4.73.~
Почему flatten-stream использует delay явно? Что было бы неправильно в
таком определении:

#+BEGIN_SRC scheme
  (define (flatten-stream stream)
    (if (stream-null? stream)
        the-empty-stream
        (interleave
         (stream-car stream)
         (flatten-stream (stream-cdr stream)))))

#+END_SRC

Проблема та же, что и в упражнении 4.71: interleave не защищает нас от
зацикливания системы при попытке сопоставить образец и правило. А
interleave-delayed, который используется в оригинальной flatten-stream
позволяет отсрочить зацикливание. Более того, flatten-stream в новой
версии не остановится, пока поток не кончится, а потоки могут быть
бесконечными.

~Упражнение 4.74.~
Лиза П. Хакер предлагает использовать в negate, lisp-value и
find-assertions упрощенную версию stream-flatmap. Она замечает, что в
этих случаях процедура, которая отображает
поток кадров, всегда порождает либо пустой поток, либо поток из одного
элемента, и поэтому при слиянии этих потоков незачем использовать чередование.

Заполните пропуски в определениях:

#+BEGIN_SRC scheme
  (define (simple-stream-flatmap proc s)
    (simple-flatten (stream-map proc s)))

  (define (simple-flatten stream)
    (stream-map (lambda (str)
                  (stream-car str))
                (stream-filter (lambda (str)
                                 (not (stream-null? str)))
                               stream)))
#+END_SRC

~Упражнение 4.75.~
Реализуйте в языке запросов новую особую форму unique. Выражение unique
должно быть успешно, если в базе данных ровно одна запись,
удовлетворяющая указанному запросу.
Примеры запроса с формой и ответов на него:
- (unique (position ?x (computers guru))) => одноэлементный поток
(unique (position (Bitobor Ben) (computers guru)))
- (unique (position ?x (computers programmer))) => пустой поток
-  (and (position ?x ?j) (unique (position ?anyone ?j))) => перечисление
  всех единичных должностей и людей, которые их занимают.

Реалиизация состояит из двух частей:
1. Написать процедуру, которая обрабатывает особую форму unique.
2. Научить qeval распознавать эту процедуру.

Предположим, процедура, обрабатывающая unique называется
uniquely-asserted.
Она будет обрабатывать все запросы, и который сar - это символ unique.
На вход принимает contens запроса и поток кадров.
Для каждого кадра в потоке она должна с помощью qeval находить поток всех
расширений, удовлетворяющих данному запросу. Потоки, в которых число
элементов не равно одному, должны отбрасываться.
Оставшиеся потоки нужно собирать в один большой поток. Он и становится
результатом запроса unique. Эта процедура подобна реализации особой формы
not.

Проверьте свою реализацию, сформировав запрос, который находит всех
служащих, которые начальствуют ровно над одним человеком.

#+BEGIN_SRC scheme
  (define (uniquely-asserted pat frame-stream)
    (let ((query (car pat)))
      (stream-flatmap (lambda (frame)
                        (let ((cur-stream (qeval query
                                                 (singleton-stream frame))))
                          (if (and (not (stream-null? cur-stream))
                                   (stream-null? (stream-cdr cur-stream)))
                              cur-stream
                              the-empty-stream)))
                      frame-stream)))

  (put 'unique 'qeval uniquely-asserted)
#+END_SRC

~Упражнение 4.76.~
Наша реализация and в виде последовательной комбинации запросов (рисунок
4.5) изящна, но неэффективна, поскольку при обработке второго запроса приходится
просматривать базу данных для каждого кадра, порожденного первым
запросом. Если в базе данных N записей, а типичный запрос порождает число
записей, пропорциональное N (скажем, N/k), то проход базы данных для
каждого кадра, порожденного первым запросом, потребует N^2/k вызовов
сопоставителя.
Другой подход может состоять в том, чтобы обрабатывать два подвыражения запроса
and по отдельности а затем искать совместимые пары входных кадров. Если
каждый запрос порождает N/k кадров, то нам придется проделать N 2 /k 2
проверок на совместимость — в k раз меньше, чем число сопоставлений при
нашем теперешнем методе.
Постройте реализацию and с использованием этой стратегии. Вам придется
написать процедуру, которая принимает на входе два кадра, проверяет
связывания в этих кадрах на совместимость и, если они совместимы,
порождает кадр, в котором множества связываний слиты. Эта операция
подобна унификации.

Итак, мы будем вычислять подвыражения and попарно, независимо друг от
друга, а затем будем сверять кадры в полученных потоках на
совместимость. Совместимые кадры соберем в общий поток.

Совместимыми считаем те кадры, в которых связывания не противоречат друг
другу. К примеру, если в одном кадре x = 10, а в другом  х = 2, то такие
кадры нельзя совместить. А если в одном кадре x = 10, а в другом значение
х неизвестно, то такие кадры совместимы, поскольку иксу из второго кадра
вполне можно присвоить значение икса из первого кадра.
#+BEGIN_SRC scheme
  ;; новая реализация and
  (define (new-conjoin conjuncts frame-stream)
    (define (new-conjoin-iter conjuncts frame-stream final-frame-stream)
      (if (empty-conjunction? conjuncts)
          final-frame-stream
          ;; вычисляем следующее выражение
          (let* ((first-conjunct-frame-stream (qeval (first-conjunct conjuncts)
                                                     frame-stream))
                 ;; проверяем совместимость кадров для данного выражения с кадрами,
                 ;; полученными при вычислении предыдущих выражений
                 (merged-stream (check-frames-streams first-conjunct-frame-stream
                                                      final-frame-stream)))
            (new-conjoin-iter (rest-conjuncts conjuncts)
                              frame-stream merged-stream))))
    (if (empty-conjunction? conjuncts)
        frame-stream
        ;; вычисляем первое выражение
        (let ((new-frame-stream (qeval (first-conjunct conjuncts) frame-stream)))
          (new-conjoin-iter (rest-conjuncts conjuncts) frame-stream new-frame-stream))))

  (put 'new-and 'qeval new-conjoin)

  ;; сравниваем кадры между собой
  (define (check-frame frame1 frame2)
    (if (null? frame1)
        frame2
        (let* ((binding (car frame1))
               (extended-frame (extend-if-possible
                                (binding-variable binding)
                                (binding-value binding) frame2)))
          (if (eq? 'failed extended-frame)
              'failed
              (check-frame (cdr frame1) extended-frame)))))

  ;; сравниваем каждый кадр из первого потока с каждым кадром из второго потока
  (define (check-frames-streams frame-stream1 frame-stream2)
    (stream-flatmap (lambda (frame1)
                      (stream-flatmap (lambda (frame2)
                                        (let ((new-frame (check-frame frame1 frame2)))
                                              (if (eq? 'failed new-frame)
                                                  the-empty-stream
                                                  (singleton-stream new-frame))))
                                      frame-stream2))
                    frame-stream1))

  ;; тест
  (new-and (position ?x (computers programmer))
           (boss ?x (Bitobor Ben)) (address ?x (Boston (Bay State Road) 22)))
#+END_SRC

~Упражнение 4.77.~
В разделе 4.4.3 мы видели, что выражения not и lisp-value могут заставить
язык запросов выдавать «неправильные» значения, если эти фильтрующие операции
применяются к кадрам с несвязанными переменными. Придумайте способ
избавиться от этого недостатка.
Одна из возможностей состоит в том, чтобы проводить «задержанную»
фильтрацию, цепляя к кадру «обещание» провести ее, которое выполняется
только тогда, когда связано достаточно переменных, чтобы операция стала
возможна.
Можно ждать и проводить фильтрацию только тогда,
когда выполнены все остальные операции. Однако из соображений
эффективности хотелось бы фильтровать как можно раньше, чтобы уменьшить
число порождаемых промежуточных кадров.

1. Предположим, мы можем запретить фильтрацию для запросов, у которых
   пустые кадры. Но тогда не сработает простой запрос
   (not (position ?x (компьютеры программист))).

2. Как определить "достаточно связанных переменных?" Может, выполнять
   фильтрацию, когда будут связаны все переменные в запросе, над потоком
   которого проводят фильтрацию?


Попробуем сначала реализовать вариант, когда фильтрация выполняется
последней.

Если получили на вход составное выражение, то:
1. Проверить, начинается ли подвыражение с not/lisp-value. Если да, то обернуть его
   в промис и запомнить.
2. Выполнить все выражения кроме завернутого в промис. Когда выражения
   кончились, вынудить промис и передать фильтруещему выражению поток
   кадров, полученный от исполнения предыдущих выражений.

Данный подход потребует преобразовать процедуру, отвечающую за исполнение
выражений and.
#+BEGIN_SRC scheme
  (define (my-conjoin conjuncts frame-stream)
    (define (my-conjoin-iter conjuncts frame-stream delayed-conjunct-stream)
      (cond ((and (empty-conjunction? conjuncts) (stream-null? delayed-conjunct-stream))
             frame-stream)
            ((empty-conjunction? conjuncts)
             (my-conjoin-iter conjuncts
                              (qeval (force (stream-car delayed-conjunct-stream))
                                     frame-stream) (stream-cdr delayed-conjunct-stream)))
            (else (let ((first (first-conjunct conjuncts)))
                    (if (or (tagged-list? first 'not)
                            (tagged-list? first 'lisp-value))
                        (my-conjoin-iter (rest-conjuncts conjuncts)
                                         frame-stream (cons-stream (delay first)
                                                                   delayed-conjunct-stream))
                        (my-conjoin-iter (rest-conjuncts conjuncts)
                                         (qeval first frame-stream)
                                                delayed-conjunct-stream))))))
    (my-conjoin-iter conjuncts frame-stream the-empty-stream))

  (put 'my-and 'qeval my-conjoin)

  ;; тесты

  (my-and (boss ?x ?y)
          (not (position ?x (computers programmer))))

  (and (boss ?x ?y)
          (not (position ?x (computers programmer))))

  (my-and (not (position ?x (computers programmer)))
          (boss ?x ?y))

  (and (not (position ?x (computers programmer)))
          (boss ?x ?y))

  (my-and (salary ?person ?amount) (lisp-value > ?amount 30000))

  (and (lisp-value > ?amount 30000) (salary ?person ?amount))

  (my-and (lisp-value > ?amount 30000) (salary ?person ?amount))

#+END_SRC

~Упражнение 4.78.~
Перестройте язык запросов в виде недетерминистской программы, реализуемой
интерпретатором из раздела 4.3, а не в виде процесса обработки потоков.
При таком подходе каждый запрос будет порождать один ответ
(а не поток всех возможных ответов), а пользователь может ввести try-
again и получить следующий ответ. Вы увидите, что существенная часть
механизмов, которые мы построили в этом разделе, заменяется
недетерминистским поиском и перебором с возвратами.
Однако помимо этого, Вы обнаружите, что новый язык запросов отличается в
тонких деталях поведения от реализованного нами в этом разделе.
Можете ли Вы привести примеры, показывающие эти отличия?

Итак, в недетерменистском интерпретаторе кадры представляются так же, как
в языке запросов. Так что все процедуры, связанные с созданием кадров, мы
оставляем.

Недетерминистский интерпретатор умеет вычислять выражения с различными
операторами, функции, лямбды, определять переменные и т.д. Нам это не
нужно, так что получаемое на вход выражение мы по-прежнему будем
рассматривать как запрос или добавление утверждения/правила в систему.

Таким образом, в запросной системе поменяется только поиск подходящих
правил и утверждений для запроса.

Как запросная система исполняет запрос (коротко):
- получили выражение, пришли к выводу, что это запрос
- вызвали qeval (вычислитель) с потоком кадров (изначально он пустой)
- qeval определяет, есть ли специальная операция для вычисления данного
  запроса (например conjoin для выражений с and, disjoin для not и т.д.)
- если такая операция имеется, мы передаем ей содержимое запроса и поток
  кадров
- в противном случае считаем, что это простой запрос и вызываем процедуру
~simple-query~

Рассмотрим работу ~simple-query~, поскольку она унифицирована для всех
простых запросов.
- для каждого кадра в переданном потоке кадров вызывается
~find-assertions~. Фактически это сопоставитель, который ищет в БД все
утверждения, подходящие под запрос: сначала проверят, проиндексированно
ли это правило. Если да, то ищет в проиндексировнных, иначе ищет во
всех. Затем запрос сопоставляем с каждым утверждением, из подходящих
утверждений формируем овый поток
- аналогично для каждого кадра вызывается ~apply-rules~, которая найдет все
  правила, подходящие под данный запрос и применит их к запросу. На
  выходе получим поток расширенных кадров.
- сливаем потоки от ~find-assertions~ и ~apply-rules~ в единый поток. Он
  является результатом обработки нашего запроса.

Теперь разберемся, что нам нужно для запросной системы в
недетерминистском стиле:
- распознавать добавление новых утверждений (правил)
- распознавать простые и составные запросы

#+BEGIN_SRC scheme
  (define input-prompt ";;; Ввод Amb-Eval:")

  (define output-prompt ";;; Значение Amb-Eval:")

  (define (announce-output string)
    (newline) (display string) (newline))

  (define (user-print object)
    (display object))

  (define (driver-loop)
    (define (internal-loop try-again)
      ;; печатаем приглашение к вводу
      (prompt-for-input input-prompt)
      ;; считываем ввод
      (let ((input (read)))
        ;; если пользователь хочет попробовать вычислить данное выражение еще раз
        ;; (перебрать другие варианты), пробуем вычислить еще раз
        (if (eq? input 'try-again)
            (try-again)
            ;; иначе
            (begin
              ;; считаем, что у юзера новая задача
              (newline)
              (display ";;; Начало новой задачи ")
              ;; передадим введенному выражению глобальное окружение и 2 продолжения
              (qeval input
                     (singleton-stream '())
                     ;; успех ambeval
                     (lambda (val next-alternative)
                       ;; печатаем уведомление о значении
                       (announce-output output-prompt)
                       ;; печатаем само значение
                       (user-print val)
                       ;; вычисляем следующую альтернативу
                       (internal-loop next-alternative))
                     ;; неудача ambeval
                     (lambda ()
                       (announce-output
                        ";;; Нет больше значений")
                       (user-print input)
                       (driver-loop)))))))
    (internal-loop
     ;; печать ошибки, если пользователь пытается вычислить альтернативы, не
     ;; поставив задачу
     (lambda ()
       (newline)
       (display ";;; Задача не задана")
       (driver-loop))))

  (define (qeval exp frame succeed fail)
    ((analyze exp) frame succeed fail))

  (define (or? exp)
    (tagged-list? exp 'or))

  (define (and? exp)
    (tagged-list? exp 'and))

  (define (not? exp)
    (tagged-list? exp 'not))

  (define (lisp-value? exp)
    (tagged-list? exp 'lisp-value))

  (define (assert? exp)
    (tagged-list? exp 'assert!))

  (define (analyze exp)
    (cond ((or? exp) (analyze-or (contens exp)))
          ((and? exp) (analyze-and (contens exp)))
          ((not? exp) (analyze-not (contens exp)))
          ((assert? exp) (analyze-assert (contens exp)))
          ((lisp-value? exp) (analyze-lisp-value (contens exp)))
          (else
           (analyze-simple-query exp))))

  (define (analyze-simple-query exp)
    (lambda (frame succeed fail)
      (define (check-assertions assertions)
        (if (stream-null? assertions)
            (check-rules (fetch-rules exp frame))
            (let ((ext-frame (pattern-match exp (stream-car assertions) frame)))
              (if (eq? ext-frame 'failed)
                  (lambda () (check-assertions (stream-cdr assertions)))
                  (succeed ext-frame
                           (lambda ()
                             (check-assertions (stream-cdr assertions))))))))
      (define (check-rules rules)
        (if (stream-null? rules)
            fail
            (let ((rules (fetch-rules exp frame)))
              (if (stream-null? rules)
                  fail
                  (let* ((clean-rule (rename-variables-in (stream-car rules)))
                         (unify-result
                          (unify-match query-pattern
                                       (conclusion clean-rule)
                                       query-frame)))
                    (if (eq? unify-result 'failed)
                        (lambda ()
                          (check-rules (stream-cdr rules)))
                        ((analyze (rule-body clean-rule)) unify-result
                         succeed fail)
                        (lambda ()
                          (check-rules (stream-cdr rules)))))))))
      (check-rules (fetch-rules exp frame))))

  (define (analyze-or disjuncts)
    (lambda (frame succeed fail)
      (if (empty-disjunction? disjuncts)
          the-empty-stream
          (qeval (car disjuncts)
                 frame succeed
                 (lambda ()
                   ((analyze (cdr disjuncts)) frame
                    succeed fail))))))
#+END_SRC

~Упражнение 4.79.~
Реализуйте для языка запросов метод применения правил, который использует
не переименования, а окружения. Рассмотрите, можно ли использовать Вашу систему
окружений для построения в языке запросов конструкций для работы с
большими системами, например аналога блочной структуры процедур для
правил. Можно ли связать это с проблемой ведения рассуждений в кон-
тексте (например: «Если бы я предположил, что истинно P , то я смог бы
доказать A и B») в качестве метода решения задач?
(Это упражнение не имеет однозначного решения. Хороший
ответ, скорее всего, мог бы служить темой диссертации.)

Строго говоря, мы можем создать для каждого применения правила свое
собственное окружение, тогда переменные не будут перекрывать друг друга.

Найти ситуацию, когда переименовывание переменных действительно важно и
дает разницу по сравнению с применением правила без переименовывания,
потому что сейчас все работает правильно и без переименований.

#+BEGIN_SRC scheme

#+END_SRC


~Упражнение 5.1.~
Сделано на листочке

~Упражнение 5.2.~
С помощью языка регистровых машин опишите итеративную факториал-машину из
упражнения 5.1.

#+BEGIN_SRC scheme
  ;; исходная версия
  (define (factorial n)
    (define (iter product counter)
      (if (> counter n)
          product
          (iter (* counter product)
                (+ counter 1))))
    (iter 1 1))

  ;; версия на языке регистровых машин
  (controller
   factorial
   (assign p (const 1))
   (assign c (const 1))
   iter
   (test (op >) (reg c) (reg n))
   (branch (label iter-done))
   (assign t (op *) (reg c) (reg p))
   (assign p (reg t))
   (assign t (op +) (reg c) (const 1))
   (assign c (reg t))
   (goto (label iter))
   iter-done)
#+END_SRC

~Упражнение 5.3.~
Спроектируйте машину для вычисления квадратных корней методом Ньютона,
как описано в разделе 1.1.7.
Для начала предположите, что операции good-enough? и improve имеются как
примитивы.
Затем покажите, как развернуть их с помощью арифметических
операций. Опишите каждую из версий машины sqrt, нарисовав диаграмму путей
данных, и написав определение контроллера на языке регистровых машин.

#+BEGIN_SRC scheme
  ;; исходный вид
  (define (sqrt x)
    (define (good-enough? guess)
      (< (abs (- (square guess) x)) 0.001))

    (define (average x y)
      (/ (+ x y) 2))

    (define (improve guess)
      (average guess (/ x guess)))

    (define (sqrt-iter guess)
      (if (good-enough? guess)
          guess
          (sqrt-iter (improve guess))))
    (sqrt-iter 1.0))

  ;; считаем, что improve и good-enough? - примитивы
  (controller
   sqrt
   (assign g (const 1.0))
   sqrt-iter
   (test (op good-enough?) (reg g))
   (branch (label sqrt-done))
   (assign t (op improve) (reg g))
   (goto (label sqrt-iter))
   sqrt-done)

  ;; реализуем improve и good-enough? как часть контроллера с помощью арифм. операций
  ;; считаем, что average, square и abs - примитивы
  (controller
   sqrt
   (assign g (const 1.0))

   sqrt-iter

   good-enough?
   (assign s (op square) (reg g))
   (assign r (op - ) (reg s) (reg x))
   (assign t (op abs) (reg r))
   (test (op <) (reg t) (const 0.001))
   (branch (label sqrt-done))

   improve
   (assign t (op /) (reg x) (reg g))
   (assign r (op average) (reg g) (reg t))
   (assign g (reg t))
   (goto (label sqrt-iter))

   sqrt-done)

#+END_SRC

~Упражнение 5.4.~
Опишите регистровые машины для реализации каждой из следующих
процедур. Для каждой из этих машин напишите последовательность команд
контроллера и нарисуйте диаграмму, показывающую пути данных.

#+BEGIN_SRC scheme
  ;; рекурсивный процесс
  (define (expt b n)
    (if (= n 0)
        1
        (* b (expt b (- n 1)))))

  (define expt-machine
    (make-machine
     '(n val b continue)
     (list (list '= =) (list '* *) (list '- -))
     '((assign continue (label expt-done))
       (save continue)
       expt
       ;; проверили n
       (test (op =) (reg n) (const 0))
       ;; если дошли до дна рекурсии, идем в точку отката назад
       (branch (label base-case))

       ;; иначе сохраняем адрес возвратаи продолжаем итерацию
       (save continue)
       (assign n (op -) (reg n) (const 1))
       (assign continue (label after-expt))
       (goto (label expt))

       ;; достигли дна рекурсии
       base-case
       (assign val (const 1))
       (goto (reg continue))

       ;; откатываемся нада по стеку
       after-expt
       (restore continue)
       (assign val (op *) (reg b) (reg val))
       (goto (reg continue))
       expt-done)))

  ;; итеративный процесс
  (define (expt b n)
    (define (expt-iter counter product)
      (if (= counter 0)
          product
          (expt-iter (- counter 1) (* b product))))
    (expt-iter n 1))

  (define expt-machine-iter
    (make-machine
     '(counter n b r t product)
     (list (list '= =) (list '* *) (list '- -))
     '(expt
       (assign counter (reg n))
       (assign product (const 1))
       expt-iter
       (test (op =) (reg counter) (const 0))
       (branch (label expt-iter-done))
       (assign t (op -) (reg counter) (const 1))
       (assign r (op *) (reg b) (reg product))
       (assign product (reg r))
       (assign counter (reg t))
       (goto (label expt-iter))
       expt-iter-done)))
#+END_SRC
~Упражнение 5.5.~
Смоделируйте вручную работу факториальной машины и машины Фибоначчи с
каким-нибудь нетривиальным значением на входе (чтобы потребовался хотя бы один
рекурсивный вызов). Покажите содержимое стека в каждый момент выполнения.

Cделано на листочке.

~Упражнение 5.6.~
Бен Битобор утверждает, что последовательность команд машины Фибоначчи
содержит одну лишнюю команду save и одну лишнюю restore, которые можно
убрать и получить более быструю машину. Что это за команды?
#+BEGIN_SRC scheme
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)) (fib (- n 2)))))

  (controller
   (assign continue (label fib-done))
   fib-loop
   (test (op <) (reg n) (const 2))
   (branch (label immediate-answer))
   ;; готовимся вычислить Fib (n − 1)
   (save continue)
   (assign continue (label afterfib-n-1))
   (save n)

   (assign n (op -) (reg n) (const 1))
   (goto (label fib-loop))

   afterfib-n-1

   (restore n)
   (restore continue)    ;; лишняя операция
   ;; готовимся вычислить Fib (n − 2)
   (assign n (op -) (reg n) (const 2))
   (save continue)       ;; лишняя операция
   (assign continue (label afterfib-n-2))
   (save val)

   (goto (label fib-loop))

   afterfib-n-2
   (assign n (reg val))

   (restore val)

   (restore continue)
   (assign val (op +) (reg val) (reg n))
   (goto (reg continue))
                                          ; возврат, ответ~в val
   immediate-answer
   (assign val (reg n))
                                          ; базовый случай: Fib(n) = n
   (goto (reg continue))
   fib-done)
#+END_SRC

~модель регистровых машин~

#+BEGIN_SRC scheme
  (define (tagged-list? exp tag)
    (if (pair? exp)
        (eq? (car exp) tag)
        false))

  (define (make-machine register-names ops controller-text)
    (let ((machine (make-new-machine)))
      (for-each (lambda (register-name)
                  ((machine 'allocate-register) register-name))
                register-names)
      ((machine 'install-operations) ops)
      ((machine 'install-instruction-sequence)
       (assemble controller-text machine))
      machine))

  (define (make-register name)
    (let ((contents '*unassigned*))
      (define (dispatch message)
        (cond ((eq? message 'get) contents)
              ((eq? message 'set)
               (lambda (value) (set! contents value)))
              (else
               (error "Неизвестная операция -- REGISTER" message))))
      dispatch))

  (define (get-contents register)
    (register 'get))

  (define (set-contents! register value)
    ((register 'set) value))

  (define (make-stack)
    (let ((s '()))
      (define (push x)
        (set! s (cons x s)))
      (define (pop)
        (if (null? s)
            (error "Пустой стек -- POP")
            (let ((top (car s)))
              (set! s (cdr s))
              top)))
      (define (initialize)
        (set! s '())
        'done)
      (define (dispatch message)
        (cond ((eq? message 'push) push)
              ((eq? message 'pop) (pop))
              ((eq? message 'initialize) (initialize))
              (else (error "Неизвестная операция -- STACK"
                           message))))
      dispatch))

  (define (pop stack)
    (stack 'pop))

  (define (push stack value)
    ((stack 'push) value))

  (define (start machine)
    (machine 'start))

  (define (get-register-contents machine register-name)
    (get-contents (get-register machine register-name)))

  (define (set-register-contents! machine register-name value)
    (set-contents! (get-register machine register-name) value)
    'done)

  (define (get-register machine reg-name)
    ((machine 'get-register) reg-name))

  (define (assemble controller-text machine)
    (extract-labels controller-text
                    (lambda (insts labels)
                      (update-insts! insts labels machine)
                      insts)))

  (define (make-new-machine)
    (let ((pc (make-register 'pc))
          (flag (make-register 'flag))
          (stack (make-stack))
          (the-instruction-sequence  '()))
      (let ((the-ops
             (list (list 'initialize-stack
                          (lambda () (stack 'initialize)))))
            (register-table
             (list (list 'pc pc) (list 'flag flag))))
        (define (allocate-register name)
          (if (assoc name register-table)
              (error "Многократно определенный регистр: " name)
              (set! register-table
                    (cons (list name (make-register name))
                          register-table)))
          'register-allocated)
        (define (lookup-register name)
          (let ((val (assoc name register-table)))
            (if val
                (cadr val)
                (error "Неизвестный регистр:" name))))
        (define (execute)
          (let ((insts (get-contents pc)))
            (if (null? insts)
                'done
                 (begin
                   ((instruction-execution-proc (car insts)))
                   (execute)))))
        (define (dispatch message)
          (cond ((eq? message 'start)
                 (set-contents! pc the-instruction-sequence)
                 (execute))
                ((eq? message 'install-instruction-sequence)
                 (lambda (seq) (set! the-instruction-sequence seq)))
                ((eq? message 'allocate-register) allocate-register)
                ((eq? message 'get-register) lookup-register)
                ((eq? message 'install-operations)
                 (lambda (ops) (set! the-ops (append the-ops ops))))
                ((eq? message 'stack) stack)
                ((eq? message 'operations) the-ops)
                (else (error "Неизвестная операция -- MACHINE" message))))
        dispatch)))

  (define (extract-labels text receive)
    (if (null? text)
        (receive '() '())
        (extract-labels (cdr text)
                        (lambda (insts labels)
                          (let ((next-inst (car text)))
                            (if (symbol? next-inst)
                                (receive insts
                                         (cons (make-label-entry next-inst
                                                                 insts)
                                               labels))
                                (receive (cons (make-instruction next-inst)
                                               insts)
                                         labels)))))))

  (define (update-insts! insts labels machine)
    (let ((pc (get-register machine 'pc))
          (flag (get-register machine 'flag))
          (stack (machine 'stack))
          (ops (machine 'operations)))
      (for-each
       (lambda (inst)
         (set-instruction-execution-proc!
          inst
          (make-execution-procedure
           (instruction-text inst) labels machine
           pc flag stack ops)))
       insts)))

  (define (make-instruction text)
    (cons text '()))

  (define (instruction-text inst)
    (car inst))

  (define (instruction-execution-proc inst)
    (cdr inst))

  (define (set-instruction-execution-proc! inst proc)
    (set-cdr! inst proc))

  (define (make-label-entry label-name insts)
    (cons label-name insts))

  (define (lookup-label labels label-name)
    ;; (display "lookup-label: label-name\n")
    ;; (display label-name)
    ;; (newline)
    (let ((val (assoc label-name labels)))
      (if val
          (cdr val)
          (error "Неопределенная метка -- ASSEMBLE" label-name))))

  (define (make-execution-procedure inst labels machine
                                    pc flag stack ops)
    ;; (display (car inst))
    ;; (newline)
    (cond ((eq? (car inst) 'assign)
           (make-assign inst machine labels ops pc))
          ((eq? (car inst) 'test)
           (make-test inst machine labels ops flag pc))
          ((eq? (car inst) 'branch)
           (make-branch inst machine labels flag pc))
          ((eq? (car inst) 'goto)
           (make-goto inst machine labels pc))
          ((eq? (car inst) 'save)
           (make-save inst machine stack pc))
          ((eq? (car inst) 'restore)
           (make-restore inst machine stack pc))
          ((eq? (car inst) 'perform)
           (make-perform inst machine labels ops pc))
          (else (error "Неизвестный тип команды -- ASSEMBLE"
                       inst))))

  (define (make-assign inst machine labels operations pc)
    (let ((target
           (get-register machine (assign-reg-name inst)))
          (value-exp (assign-value-exp inst)))
          (let ((value-proc
             (if (operation-exp? value-exp)
                 (make-operation-exp
                  value-exp machine labels operations)
                 (make-primitive-exp
                  (car value-exp) machine labels))))
        (lambda ()
                                        ; исполнительная процедура для assign
          (set-contents! target (value-proc))
          (advance-pc pc)))))

  (define (assign-reg-name assign-instruction)
    (cadr assign-instruction))

  (define (assign-value-exp assign-instruction)
    (cddr assign-instruction))

  (define (advance-pc pc)
    (set-contents! pc (cdr (get-contents pc))))

  (define (make-test inst machine labels operations flag pc)
    (let ((condition (test-condition inst)))
      (if (operation-exp? condition)
          (let ((condition-proc
                 (make-operation-exp
                  condition machine labels operations)))
            (lambda ()
              (set-contents! flag (condition-proc))
              (advance-pc pc)))
          (error "Плохая команда TEST -- ASSEMBLE" inst))))

  (define (test-condition test-instruction)
    (cdr test-instruction))

  (define (make-branch inst machine labels flag pc)
    (let ((dest (branch-dest inst)))
      ;; (display "dest\n")
      ;; (display dest)
      ;; (newline)
      ;; (display "dest2\n")
      ;; (display (label-exp-label dest))
      ;; (newline)
      (if (label-exp? dest)
          (let ((insts
                 (lookup-label labels (label-exp-label dest))))
            (lambda ()
              (if (get-contents flag)
                  (set-contents! pc insts)
                  (advance-pc pc))))
          (error "Плохая команда BRANCH -- ASSEMBLE" inst))))

  (define (branch-dest branch-instruction)
    (cadr branch-instruction))

  (define (make-goto inst machine labels pc)
    (let ((dest (goto-dest inst)))
      (cond ((label-exp? dest)
             (let ((insts
                    (lookup-label labels
                                  (label-exp-label dest))))
               (lambda () (set-contents! pc insts))))
            ((register-exp? dest)
             (let ((reg
                    (get-register machine
                                  (register-exp-reg dest))))
               (lambda ()
                 (set-contents! pc (get-contents reg)))))
            (else (error "Плохая команда GOTO -- ASSEMBLE"
                         inst)))))

  (define (goto-dest goto-instruction)
    (cadr goto-instruction))

  (define (make-save inst machine stack pc)
    (let ((reg (get-register machine
                             (stack-inst-reg-name inst))))
      (lambda ()
        (push stack (get-contents reg))
        (advance-pc pc))))

  (define (make-restore inst machine stack pc)
    (let ((reg (get-register machine
                             (stack-inst-reg-name inst))))
      (lambda ()
        (set-contents! reg (pop stack))
        (advance-pc pc))))
  (define (stack-inst-reg-name stack-instruction)
    (cadr stack-instruction))

  (define (make-perform inst machine labels operations pc)
    (let ((action (perform-action inst)))
      (if (operation-exp? action)
          (let ((action-proc
                 (make-operation-exp
                  action machine labels operations)))
            (lambda ()
              (action-proc)
              (advance-pc pc)))
          (error "Плохая команда PERFORM -- ASSEMBLE" inst))))

  (define (perform-action inst) (cdr inst))

  (define (make-primitive-exp exp machine labels)
    ;; (display exp)
    ;; (newline)
    (cond ((constant-exp? exp)
           (let ((c (constant-exp-value exp)))
             (lambda () c)))
          ((label-exp? exp)
           (let ((insts
                  (lookup-label labels
                                (label-exp-label exp))))
             (lambda () insts)))
          ((register-exp? exp)
           (let ((r (get-register machine
                                  (register-exp-reg exp))))
             (lambda () (get-contents r))))
          (else
           (error "Неизвестный тип выражения -- ASSEMBLE" exp))))

  (define (register-exp? exp) (tagged-list? exp 'reg))
  (define (register-exp-reg exp) (cadr exp))
  (define (constant-exp? exp) (tagged-list? exp 'const))
  (define (constant-exp-value exp) (cadr exp))
  (define (label-exp? exp) (tagged-list? exp 'label))
  (define (label-exp-label exp) (cadr exp))

  (define (make-operation-exp exp machine labels operations)
    (let ((op (lookup-prim (operation-exp-op exp) operations))
          (aprocs
           (map (lambda (e)
                  (make-primitive-exp e machine labels))
                (operation-exp-operands exp))))
      (lambda ()
        (apply op (map (lambda (p) (p)) aprocs)))))

  (define (operation-exp? exp)
    (and (pair? exp) (tagged-list? (car exp) 'op)))

  (define (operation-exp-op operation-exp)
    (cadr (car operation-exp)))

  (define (operation-exp-operands operation-exp)
    (cdr operation-exp))

  (define (lookup-prim symbol operations)
    (let ((val (assoc symbol operations)))
      (if val
          (cadr val)
          (error "Неизвестная операция -- ASSEMBLE" symbol))))
#+END_SRC

Залить все в интерпретатор
~Упражнение 5.7~.
Проверьте на имитаторе машины, построенные Вами в упражнении 5.4.

#+BEGIN_SRC scheme
  (define gcd-machine
    (make-machine
     '(a b t)
      (list (list 'rem remainder) (list '= =))
      '(test-b
        (test (op =) (reg b) (const 0))
        (branch (label gcd-done))
        (assign t (op rem) (reg a) (reg b))
        (assign a (reg b))
        (assign b (reg t))
        (goto (label test-b))
        gcd-done)))

  ;; рекурсивный процесс
  (define (expt b n)
    (if (= n 0)
        1
        (* b (expt b (- n 1)))))

  (define expt-machine
    (make-machine
     '(n val b continue)
     (list (list '= =) (list '* *) (list '- -))
     '((assign continue (label expt-done))
       (save continue)
      expt
      ;; проверили n
      (test (op =) (reg n) (const 0))
      ;; если дошли до дна рекурсии, идем в точку отката назад
      (branch (label base-case))

      ;; иначе сохраняем адрес возвратаи продолжаем итерацию
      (save continue)
      (assign n (op -) (reg n) (const 1))
      (assign continue (label after-expt))
      (goto (label expt))

      ;; достигли дна рекурсии
      base-case
      (assign val (const 1))
      (goto (reg continue))

      ;; откатываемся нада по стеку
      after-expt
      (restore continue)
      (assign val (op *) (reg b) (reg val))
      (goto (reg continue))
      expt-done)))


  (set-register-contents! expt-machine 'b 2)
  (set-register-contents! expt-machine 'n 3)
  (start expt-machine)
  (get-register-contents expt-machine 'val)

  ;; итеративный процесс
  (define (expt b n)
    (define (expt-iter counter product)
      (if (= counter 0)
          product
          (expt-iter (- counter 1) (* b product))))
    (expt-iter n 1))

  (define expt-machine-iter
    (make-machine
     '(counter n b r t product)
     (list (list '= =) (list '* *) (list '- -))
     '(expt
       (assign counter (reg n))
       (assign product (const 1))
       expt-iter
       (test (op =) (reg counter) (const 0))
       (branch (label expt-iter-done))
       (assign t (op -) (reg counter) (const 1))
       (assign r (op *) (reg b) (reg product))
       (assign product (reg r))
       (assign counter (reg t))
       (goto (label expt-iter))
       expt-iter-done)))

  (set-register-contents! expt-machine-iter 'b 2)
  (set-register-contents! expt-machine-iter 'n 3)
  (start expt-machine-iter)
  (get-register-contents expt-machine-iter 'product)
#+END_SRC

~Упражнение 5.8.~
Следующий код для регистровой машины неоднозначен, поскольку метка here
определена более одного раза.
Каково будет содержимое регистра a в нашем имитаторе, когда управление
достигнет there?
Измените процедуру extract-labels так, чтобы ассемблер сообщал об ошибке
в случае, когда одно и то же имя метки обозначает две различных точки в коде.

#+BEGIN_SRC scheme
  ;; исходный вид
  start
  (goto (label here))
  here
  (assign a (const 3))
  (goto (label there))
  here
  (assign a (const 4))
  (goto (label there))
  there

  ;; мой тест
  (define test-machine
    (make-machine
     '(a)
     '()
     '(start
       (goto (label here))
       here
       (assign a (const 3))
       (goto (label there))
       here
       (assign a (const 4))
       (goto (label there))
       there)))

  (start test-machine)
  (get-register-contents test-machine 'a)
#+END_SRC

Интерпретатор возвращает 3. Значит, язык регистровых машин переходит на
первую метку here.

Усовершенствованный extract-labels. Протестить можно на примере из
данного упражнения и выполненных выше упражнениях.

#+BEGIN_SRC scheme
  ;; проверяем, был ли точно такой же символ в списке меток
  ;; если был, возвращаем true, иначе false
  (define (repeated-label? cur-label labels-insts-list)
    (if (null? labels-insts-list)
        false
        (let ((cur-labels-insts (car labels-insts-list)))
          (if (eq? cur-label (car cur-labels-insts))
              true
              (repeated-label? cur-label (cdr labels-insts-list))))))


  (define (extract-labels text receive)
    (if (null? text)
        (receive '() '())
        (extract-labels (cdr text)
                        (lambda (insts labels)
                          (let ((next-inst (car text)))
                            (if (symbol? next-inst)
                                (if (repeated-label? next-inst labels)
                                    (error "Переопределение метки -- EXTRACT-LABELS"
                                           next-inst)
                                    (receive insts
                                             (cons (make-label-entry next-inst
                                                                     insts)
                                                   labels)))
                                (receive (cons (make-instruction next-inst)
                                               insts)
                                         labels)))))))
#+END_SRC

~Упражнение 5.9.~
Приведенная в тексте обработка позволяет машинным операциям принимать в
качестве аргументов не только константы и содержимое регистров, но и метки. Измените
процедуры, обрабатывающие выражения, и обеспечьте выполнение условия, что
операции можно применять исключительно к регистрам и константам.

#+BEGIN_SRC scheme
  (define (make-operation-exp exp machine labels operations)
    (let ((op (lookup-prim (operation-exp-op exp) operations))
          (aprocs
           (map (lambda (e)
                  (if (label-exp? e)
                      (error "Операции не могут быть применены к меткам -- ASSEMBLE" e)
                      (make-primitive-exp e machine labels)))
                (operation-exp-operands exp))))
      (lambda ()
        (apply op (map (lambda (p) (p)) aprocs)))))

  (define test
    (make-machine
     '(a)
     (list (list '+ +))
     '(test-a
       test-b
       (assign a (op +) (label test-a) (label test-b)))))
#+END_SRC

~Упражнение 5.10~
Придумайте новый синтаксис для команд регистровой машины и измените
имитатор так, чтобы он использовал Ваш новый синтаксис. Можете ли Вы
реализовать свой синтаксис, ничего не трогая, кроме синтаксических
процедур из этого раздела?

Начнем с простого. Предположим, изменим синтаксис присваивания. Раньше
синтаксис был (assign приемник источник), то теперь пусть приемник будет
последним.

#+BEGIN_SRC scheme
  (define (assign-reg-name assign-instruction)
      (if (= (length assign-instruction) 1)
          (car assign-instruction)
          (assign-reg-name
           (cdr assign-instruction))))

  (define (assign-value-exp assign-instruction)
    (define (iter assign-instruction)
      (if (= (length assign-instruction) 1)
          '()
          (cons (car assign-instruction)
                (iter (cdr assign-instruction)))))
    (iter (cdr assign-instruction)))

  ;; тест

  (define test-machine
    (make-machine
     '(a b c)
     (list (list '+ +))
     '(test
       (assign (const 3) a)
       (assign (const 4) b)
       (assign (op +) (reg b) (reg a) c))))
#+END_SRC

Команды ~branch~ и ~goto~ трогать не будем, там нет пространства для
маневра, в ~branch~ без тэга ~label~ асм не сможет распознать метку и
выражение не выполнится, а ~goto~ может принимать как метки, так и
регистры, так что там по-любому придется указывать, что мы имеем ввиду.

Можно было бы поменять синтаксис в ~test~, чтоб установить алгебраический
порядок в выражении, но в в асме обычно используется префиксная нотация
вида "операция применик источник" или "операция источник приемник", так
что не вижу особого смысла менять синтаксис здесь, к тому же эта задача
будет похожа на изменение синтаксис ~assign~.

Остальные же синтаксические изменения потребуют более значительных
изменений в системе, в частности при парсинге выражений.

~Упражнение 5.11.~
Когда мы в разделе 5.1.4 определяли ~save~ и ~restore~, мы не указали, что
произойдет, если попытаться восстановить значение не в том регистре,
который был сохранен последним, как в последовательности команд

#+BEGIN_SRC scheme
  (save y)
  (save x)
  (restore y)
#+END_SRC

Есть несколько разумных вариантов значения ~restore~:
а. (restore y) переносит в y последнее значение, сохраненное на стеке,
независимо от того, откуда это значение взялось. Так работает наш
имитатор.
Покажите, как с помощью такого поведения убрать одну команду из машины
Фибоначчи (раздел 5.1.4, рисунок 5.12).

#+BEGIN_SRC scheme
  (define fib-machine
    (make-machine
     '(n val continue)
     (list (list '+ +) (list '= =) (list '- -) (list '< <))
     '(controller
       (assign continue (label fib-done))
       fib-loop
       (test (op <) (reg n) (const 2))
       (branch (label immediate-answer))
       ;; готовимся вычислить Fib (n − 1)
       (save continue)
       (assign continue (label afterfib-n-1))
       (save n)

       (assign n (op -) (reg n) (const 1))
       (goto (label fib-loop))

       afterfib-n-1

       (restore n)
       (restore continue)    ;; лишняя операция
       ;; готовимся вычислить Fib (n − 2)
       (assign n (op -) (reg n) (const 2))
       (save continue)       ;; лишняя операция
       (assign continue (label afterfib-n-2))
       (save val)

       (goto (label fib-loop))

       afterfib-n-2  ;; изменено
       (restore n)

       (restore continue)
       (assign val (op +) (reg val) (reg n))
       (goto (reg continue))
                                          ; возврат, ответ~в val
       immediate-answer
       (assign val (reg n))
                                          ; базовый случай: Fib(n) = n
       (goto (reg continue))
       fib-done)))

  (set-register-contents! fib-machine 'n 4)
  (start fib-machine)
  (get-register-contents fib-machine 'val)
#+END_SRC

б. (restore y) переносит в y последнее значение, сохраненное на стеке, но
только в том случае, когда это значение происходит из регистра y; иначе возникает
сообщение об ошибке.
Модифицируйте имитатор и заставьте его вести себя таким образом. Придется
изменить save так, чтобы он сохранял имя регистра вместе со значением.

МНе пришлось изменить save, restore и представление регистра.
Теперь можно узнать имя регистра, отправив ему соответствующее сообщение,
так проще узнавать имя при работе с регистром в процедурах, реализующих
имитатор.

~make-save~ теперь пушит список (имя_регистра значение), а ~restore~
сравнивает имя регистра-приемник с имеем регистра-источника. Если они не
совпадают, то выдается ошибка
#+BEGIN_SRC scheme
  (define (make-save inst machine stack pc)
    (let ((reg (get-register machine
                             (stack-inst-reg-name inst))))
      (lambda ()
        (push stack (list (get-reg-name reg) (get-contents reg)))
        (advance-pc pc))))

  (define (make-restore inst machine stack pc)
    (let ((reg (get-register machine
                             (stack-inst-reg-name inst))))
      (lambda ()
        (let* ((name-dest-reg (get-reg-name reg))
               (source (pop stack))
               (name-source-reg (car source))
               (value-source-reg (cdr source)))
          (if (eq? name-dest-reg name-source-reg)
              (begin
              (set-contents! reg value-source-reg)
              (advance-pc pc))
              (error "Регистры не совпадают -- REGISTER" name-source-reg))))))

  (define (make-register name)
    (let ((contents '*unassigned*))
      (define (dispatch message)
        (cond ((eq? message 'get) contents)
              ((eq? message 'name) name)
              ((eq? message 'set)
               (lambda (value) (set! contents value)))
              (else
               (error "Неизвестная операция -- REGISTER" message))))
      dispatch))

  (define (get-reg-name reg)
    (reg 'name))

  ;; тесты
  (define test
    (make-machine
     '(a b)
     '()
     '((assign a (const 2))
       (assign b (const 3))
       (save a)
       (restore b))))

  (define test2
    (make-machine
     '(a b)
     '()
     '((assign a (const 2))
       (assign b (const 3))
       (save a)
       (restore a))))

#+END_SRC

в. (restore y) переносит в y последнее значение, сохраненное из y,
независимо от того, какие другие регистры были сохранены и не восстановлены после
y.
Модифицируйте имитатор
так, чтобы он вел себя таким образом. С каждым регистром придется связать
свой собственный стек. Операция initialize-stack должна инициализировать
стеки всех регистров.


Моя идея: нам предлагается создать стеки для всех регистров, таким образом
можно будет вообще не думать, что в какой последовательности мы
сохраняем/берем из стека. Я так понимаю, что общего стека у нас не будет
в принципе.

Очевидно, что придется расширить представление
регистра, чтоб можно было устновить связь между ним, и его стеком.
Модифицировать save-restore? Потому что они теперь будут не получать стек
на входе, а образщаться к нему через регистр, с которымон связан.
И придется измениь make-machine так, чтоб она инициализировала не один
общий стек, а стеки для всех регистров сразу (почму это нельзя сделать на
этапе создания самого регистра и стека для него?)

#+BEGIN_SRC scheme
  ;; больше не принимает стек как параметр
  (define (make-execution-procedure inst labels machine
                                    pc flag ops)
    (cond ((eq? (car inst) 'assign)
           (make-assign inst machine labels ops pc))
          ((eq? (car inst) 'test)
           (make-test inst machine labels ops flag pc))
          ((eq? (car inst) 'branch)
           (make-branch inst machine labels flag pc))
          ((eq? (car inst) 'goto)
           (make-goto inst machine labels pc))
          ((eq? (car inst) 'save)
           (make-save inst machine pc))
          ((eq? (car inst) 'restore)
           (make-restore inst machine pc))
          ((eq? (car inst) 'perform)
           (make-perform inst machine labels ops pc))
          (else (error "Неизвестный тип команды -- ASSEMBLE"
                       inst))))

  ;; больше не принимает стек как параметр
  (define (update-insts! insts labels machine)
    (let ((pc (get-register machine 'pc))
          (flag (get-register machine 'flag))
          (ops (machine 'operations)))
      (for-each
       (lambda (inst)
         (set-instruction-execution-proc!
          inst
          (make-execution-procedure
           (instruction-text inst) labels machine
           pc flag ops)))
       insts)))

  (define (make-new-machine)
    (let ((pc (make-register 'pc))
          (flag (make-register 'flag))
          (the-instruction-sequence  '()))
      (let* ((register-table
             (list (list 'pc pc) (list 'flag flag)))
            (the-ops
             (list (list 'initialize-stack
                         (lambda ()   ;; добавлена инициализация всех стеков
                           (define (initialize-all-stacks regs)
                             (if (null? regs)
                                 'done
                                 (let ((reg (cadr (car regs))))  ;; получили тек. регистр
                                   (reg 'initialize-stack)
                                   (initialize-all-stacks (cdr regs)))))
                           (initialize-all-stacks register-table))))))
        (define (allocate-register name)
          (if (assoc name register-table)
              (error "Многократно определенный регистр: " name)
              (set! register-table
                    (cons (list name (make-register name))
                          register-table)))
          'register-allocated)
        (define (lookup-register name)
          (let ((val (assoc name register-table)))
            (if val
                (cadr val)
                (error "Неизвестный регистр:" name))))
        (define (execute)
          (let ((insts (get-contents pc)))
            (if (null? insts)
                'done
                (begin
                  ((instruction-execution-proc (car insts)))
                  (execute)))))
        (define (dispatch message)
          (cond ((eq? message 'start)
                 (set-contents! pc the-instruction-sequence)
                 (execute))
                ((eq? message 'install-instruction-sequence)
                 (lambda (seq) (set! the-instruction-sequence seq)))
                ((eq? message 'allocate-register) allocate-register)
                ((eq? message 'get-register) lookup-register)
                ((eq? message 'install-operations)
                 (lambda (ops) (set! the-ops (append the-ops ops))))
                ((eq? message 'stack) stack)
                ((eq? message 'operations) the-ops)
                (else (error "Неизвестная операция -- MACHINE" message))))
        dispatch)))

  ;; добавлено:
  ;; регистр содержит в себе представление стека
  ;; можно получить или инициалиировать стек
  (define (make-register name)
    (let ((contents '*unassigned*)
          (stack (make-stack)))
      (define (dispatch message)
        (cond ((eq? message 'get) contents)
              ((eq? message 'set)
               (lambda (value) (set! contents value)))
              ((eq? message 'initialize-stack) (stack 'initialize))
              ((eq? message 'get-stack) stack)
              (else
               (error "Неизвестная операция -- REGISTER" message))))
      dispatch))

  ;; получаем стек из регистра, а не как параметр
  (define (make-save inst machine pc)
    (let* ((reg (get-register machine
                              (stack-inst-reg-name inst)))
           (stack (reg 'get-stack)))
      (lambda ()
        (push stack (get-contents reg))
        (advance-pc pc))))

  ;; получаем стек из регистра, а не как параметр
  (define (make-restore inst machine pc)
    (let* ((reg (get-register machine
                             (stack-inst-reg-name inst)))
          (stack (reg 'get-stack)))
      (lambda ()
        (set-contents! reg (pop stack))
        (advance-pc pc))))

  ;; тесты
  (define test
    (make-machine
     '(a b c d)
     '()
     '((assign a (const 2))
       (assign b (const 3))
       (assign c (const 4))
       (assign d (const 1))
       (save a)
       (save b)
       (save c)
       (save d)
       (restore b)
       (restore a)
       (restore d)
       (restore c))))

  (start test)
  (get-register-contents test 'a)
  (get-register-contents test 'b)
  (get-register-contents test 'c)
  (get-register-contents test 'd)

  (define test2
    (make-machine
     '(a b)
     '()
     '((assign a (const 2))
       (assign b (const 3))
       (save a)
       (restore b))))

  (start test2)
#+END_SRC
~Упражнение 5.12.~
При помощи имитатора можно определять пути данных, которые требуются для
реализации машины с данным контроллером. Расширьте ассемблер и заставьте его хранить
следующую информацию о модели машины и проверьте на машине Фибоначчи.

Функционал добавляется по отдельности, т.е. разные версии машины из
разных подхаданий из текущего упражнения не пересекаются друг с другом,
нужно перезаливать машину фибоначчи, заливать новый функционал и тогд
тестить.

a. список всех команд, с удаленными дубликатами, отсортированный по типу
команды (assign, goto и так далее)

Я так понимаю, что нужно составить список всех команд, чтоб они не
повторялись. Для проверки надо залить машину Фибоначчи из упр. 5.11

#+BEGIN_SRC scheme
  (define (add-command machine command-name)
    ((machine 'add-command) command-name))

  (define (get-commands machine)
    (machine 'get-commands))

  (define (make-execution-procedure inst labels machine
                                    pc flag stack ops)
    ;; (display (car inst))
    ;; (newline)
    (cond ((eq? (car inst) 'assign)
           (begin
             (add-command machine 'assign)
             (make-assign inst machine labels ops pc)))
          ((eq? (car inst) 'test)
           (begin
             (add-command machine 'test)
             (make-test inst machine labels ops flag pc)))
          ((eq? (car inst) 'branch)
           (begin
             (add-command machine 'branch)
             (make-branch inst machine labels flag pc)))
          ((eq? (car inst) 'goto)
           (begin
             (add-command machine 'goto)
             (make-goto inst machine labels pc)))
          ((eq? (car inst) 'save)
           (begin
             (add-command machine 'save)
             (make-save inst machine stack pc)))
          ((eq? (car inst) 'restore)
           (begin
             (add-command machine 'restore)
             (make-restore inst machine stack pc)))
          ((eq? (car inst) 'perform)
           (begin
             (add-command machine 'perform)
             (make-perform inst machine labels ops pc)))
          (else (error "Неизвестный тип команды -- ASSEMBLE"
                       inst))))


  (define (make-new-machine)
    (let ((pc (make-register 'pc))
          (flag (make-register 'flag))
          (stack (make-stack))
          (commands '())
          (the-instruction-sequence  '()))
      (let ((the-ops
             (list (list 'initialize-stack
                         (lambda () (stack 'initialize)))))
            (register-table
             (list (list 'pc pc) (list 'flag flag))))
        (define (allocate-register name)
          (if (assoc name register-table)
              (error "Многократно определенный регистр: " name)
              (set! register-table
                    (cons (list name (make-register name))
                          register-table)))
          'register-allocated)
        (define (lookup-register name)
          (let ((val (assoc name register-table)))
            (if val
                (cadr val)
                (error "Неизвестный регистр:" name))))
        (define (execute)
          (let ((insts (get-contents pc)))
            (if (null? insts)
                'done
                (begin
                  ((instruction-execution-proc (car insts)))
                  (execute)))))

        (define (add-command command)
          (define (add-command-iter commands-list)
            (cond ((null? commands-list)
                   (set! commands (cons command
                                        commands)))
                  ((eq? (car commands-list) command)
                   false)
                  (else (add-command-iter (cdr commands-list)))))
          (add-command-iter commands))
        (define (dispatch message)
          (cond ((eq? message 'start)
                 (set-contents! pc the-instruction-sequence)
                 (execute))
                ((eq? message 'install-instruction-sequence)
                 (lambda (seq) (set! the-instruction-sequence seq)))
                ((eq? message 'allocate-register) allocate-register)
                ((eq? message 'get-register) lookup-register)
                ((eq? message 'get-commands) commands)
                ((eq? message 'add-command) add-command)
                ((eq? message 'install-operations)
                 (lambda (ops) (set! the-ops (append the-ops ops))))
                ((eq? message 'stack) stack)
                ((eq? message 'operations) the-ops)
                (else (error "Неизвестная операция -- MACHINE" message))))
        dispatch)))

  (get-commands fib-machine)

#+END_SRC

б.список (без дубликатов) регистров, в которых хранятся точки входа (это
те регистры, которые упоминаются в командах goto).

Я так понимаю, что требуется создать список имен регистров, имеющих очки входа.

#+BEGIN_SRC scheme
  (define (add-entry-point machine reg-name)
    ((machine 'add-entry-point) reg-name))

  (define (make-goto inst machine labels pc)
    (let ((dest (goto-dest inst)))
      (cond ((label-exp? dest)
             (let ((insts
                    (lookup-label labels
                                  (label-exp-label dest))))
               (lambda () (set-contents! pc insts))))
            ((register-exp? dest)
             (let ((reg
                    (get-register machine
                                  (register-exp-reg dest))))
               ;; добавляем имя регистра в список точек входа, если это возможно
               (add-entry-point machine (register-exp-reg dest))
               (lambda ()
                 (set-contents! pc (get-contents reg)))))
            (else (error "Плохая команда GOTO -- ASSEMBLE"
                         inst)))))

  (define (make-new-machine)
    (let ((pc (make-register 'pc))
          (flag (make-register 'flag))
          (stack (make-stack))
          (the-instruction-sequence  '())
          (entry-points '()))  ;; список точек входа
      (let ((the-ops
             (list (list 'initialize-stack
                         (lambda () (stack 'initialize)))))
            (register-table
             (list (list 'pc pc) (list 'flag flag))))
        (define (allocate-register name)
          (if (assoc name register-table)
              (error "Многократно определенный регистр: " name)
              (set! register-table
                    (cons (list name (make-register name))
                          register-table)))
          'register-allocated)
        (define (lookup-register name)
          (let ((val (assoc name register-table)))
            (if val
                (cadr val)
                (error "Неизвестный регистр:" name))))
        (define (execute)
          (let ((insts (get-contents pc)))
            (if (null? insts)
                'done
                (begin
                  ((instruction-execution-proc (car insts)))
                  (execute)))))
        (define (add-entry-point-to-list reg-name)
          (define (entry-point-iter cur-entry-points)
            (cond ((null? cur-entry-points) (set! entry-points (cons reg-name
                                                                     entry-points)))
                  ((eq? (car cur-entry-points) reg-name)
                   false)
                  (else (entry-point-iter (cdr cur-entry-points)))))
          (entry-point-iter entry-points))
        (define (dispatch message)
          (cond ((eq? message 'start)
                 (set-contents! pc the-instruction-sequence)
                 (execute))
                ((eq? message 'install-instruction-sequence)
                 (lambda (seq) (set! the-instruction-sequence seq)))
                ((eq? message 'allocate-register) allocate-register)
                ((eq? message 'get-register) lookup-register)
                ((eq? message 'add-entry-point) add-entry-point-to-list)
                ((eq? message 'get-entry-points) entry-points)
                ((eq? message 'install-operations)
                 (lambda (ops) (set! the-ops (append the-ops ops))))
                ((eq? message 'stack) stack)
                ((eq? message 'operations) the-ops)
                (else (error "Неизвестная операция -- MACHINE" message))))
        dispatch)))

  ;; данный тест не стоит запускать, поскольку он приводит к бесконечной рекурсии, но он
  ;; дает возможность протестить новые возможности машины
  ;; (define test
  ;;   (make-machine
  ;;    '(a b c)
  ;;    '()
  ;;    '(label-1
  ;;      label-2
  ;;      label-3
  ;;      label-4
  ;;      (assign a (label label-1))
  ;;      (assign b (label label-2))
  ;;      (assign c (label label-3))
  ;;      (goto (reg a))
  ;;      (goto (reg b))
  ;;      (goto (reg c))
  ;;      (goto (label label-4)))))

  ;; (test 'get-entry-points)

  (fib-machine 'get-entry-points)
#+END_SRC

в. Список (без дубликатов) регистров, к которым применяются команды save или
restore.

Задание аналогичное предыдущему.

#+BEGIN_SRC scheme

  (define (add-to-save-restore-list machine reg-name)
    ((machine 'add-to-save-restore-list) reg-name))

  (define (make-save inst machine stack pc)
    (let ((reg (get-register machine
                             (stack-inst-reg-name inst))))
      (add-to-save-restore-list machine (stack-inst-reg-name inst))
      (lambda ()
        (push stack (get-contents reg))
        (advance-pc pc))))

  (define (make-restore inst machine stack pc)
    (let ((reg (get-register machine
                             (stack-inst-reg-name inst))))
      (add-to-save-restore-list machine (stack-inst-reg-name inst))
      (lambda ()
        (set-contents! reg (pop stack))
        (advance-pc pc))))

  (define (make-new-machine)
    (let ((pc (make-register 'pc))
          (flag (make-register 'flag))
          (stack (make-stack))
          (the-instruction-sequence  '())
          (save-restore-list '()))
      (let ((the-ops
             (list (list 'initialize-stack
                         (lambda () (stack 'initialize)))))
            (register-table
             (list (list 'pc pc) (list 'flag flag))))
        (define (allocate-register name)
          (if (assoc name register-table)
              (error "Многократно определенный регистр: " name)
              (set! register-table
                    (cons (list name (make-register name))
                          register-table)))
          'register-allocated)
        (define (lookup-register name)
          (let ((val (assoc name register-table)))
            (if val
                (cadr val)
                (error "Неизвестный регистр:" name))))
        (define (execute)
          (let ((insts (get-contents pc)))
            (if (null? insts)
                'done
                (begin
                  ((instruction-execution-proc (car insts)))
                  (execute)))))
        (define (add-reg-to-save-restore-list reg-name)
          (define (add-reg-to-save-restore-iter cur-save-restore-list)
            (cond ((null? cur-save-restore-list) (set! save-restore-list (cons reg-name
                                                                         save-restore-list)))
                  ((eq? (car cur-save-restore-list) reg-name)
                   false)
                  (else (add-reg-to-save-restore-iter (cdr cur-save-restore-list)))))
          (add-reg-to-save-restore-iter save-restore-list))
        (define (dispatch message)
          (cond ((eq? message 'start)
                 (set-contents! pc the-instruction-sequence)
                 (execute))
                ((eq? message 'install-instruction-sequence)
                 (lambda (seq) (set! the-instruction-sequence seq)))
                ((eq? message 'allocate-register) allocate-register)
                ((eq? message 'get-register) lookup-register)
                ((eq? message 'add-to-save-restore-list) add-reg-to-save-restore-list)
                ((eq? message 'get-save-restore-list) save-restore-list)
                ((eq? message 'install-operations)
                 (lambda (ops) (set! the-ops (append the-ops ops))))
                ((eq? message 'stack) stack)
                ((eq? message 'operations) the-ops)
                (else (error "Неизвестная операция -- MACHINE" message))))
        dispatch)))

  ;; (define test
  ;;   (make-machine
  ;;    '(a b c d)
  ;;    '()
  ;;    '(label-1
  ;;      label-2
  ;;      label-3
  ;;      (assign a (label label-1))
  ;;      (assign b (label label-2))
  ;;      (assign c (label label-3))
  ;;      (save a)
  ;;      (save b)
  ;;      (restore d))))

  ;; (test 'get-save-restore-list)

  (fib-machine 'get-save-restore-list)
#+END_SRC

г. Для каждого регистра, список (без дубликатов) источников, из которых
ему присваивается значение (например, для регистра val в факториальной
машине на рисунке 5.11 источниками являются (const 1) и ((op *) (reg n) (reg val)))

#+BEGIN_SRC scheme
  (define (add-source-to-list reg source-inst)
    ((reg 'add-source) source-inst))

  (define (make-register name)
    (let ((contents '*unassigned*)
          (sources '()))
      (define (add-source source-inst)
        (define (add-source-iter source-list)
          (cond ((null? source-list)
                 (set! sources (cons source-inst sources)))
                ((equal? (car source-list) source-inst)
                 false)
                (else (add-source-iter (cdr source-list)))))
        (add-source-iter sources))
      (define (dispatch message)
        (cond ((eq? message 'get) contents)
              ((eq? message 'set)
               (lambda (value) (set! contents value)))
              ((eq? message 'get-sources) sources)
              ((eq? message 'add-source) add-source)
              (else
               (error "Неизвестная операция -- REGISTER" message))))
      dispatch))

  (define (make-assign inst machine labels operations pc)
    (let ((target
           (get-register machine (assign-reg-name inst)))
          (value-exp (assign-value-exp inst)))
      (add-source-to-list target value-exp)
      (let ((value-proc
             (if (operation-exp? value-exp)
                 (make-operation-exp
                  value-exp machine labels operations)
                 (make-primitive-exp
                  (car value-exp) machine labels))))
        (lambda ()
                                          ; исполнительная процедура для assign
          (set-contents! target (value-proc))
          (advance-pc pc)))))

  (define (get-register-sources machine reg-name)
    ((get-register machine reg-name) 'get-sources))

  ;; (define test
  ;;   (make-machine
  ;;    '(a b c)
  ;;    (list (list '+ +) (list '- -))
  ;;    '((assign a (op +) (const 2) (const 3))
  ;;      (assign b (const 7))
  ;;      (assign b (const 9))
  ;;      (assign c (op -) (reg b) (reg a))
  ;;      (assign c (const 2)))))

  ;; (get-register-sources test 'a)
  ;; (get-register-sources test 'b)
  ;; (get-register-sources test 'c)

  (get-register-sources fib-machine 'n)
  (get-register-sources fib-machine 'val)
  (get-register-sources fib-machine 'continue)
#+END_SRC

~Упражнение 5.13.~
Модифицируйте имитатор так, чтобы он определял, какие регистры
присутствуют в машине, из последовательности команд контроллера, а не
принимал список регистров в качестве аргумента make-machine.
Вместо того, чтобы выделять регистры в make-machine заранее, их можно
создавать по одному, когда они встречаются в первый раз при
ассемблировании команд.

Данное задание не потребует глобальных изменений. Достаточно только
убрать выделение регистров при создании машины и изменить поведение
~lookup-register~. Раньше если ~lookup-register~ не находила регистр в
таблице регистров, то она выдавала сообщение об ошибке, а теперь она
вызовет ~allocate-register~ и вернет новый регистр.

У данного подхода есть минус: пользователь должен очень четко следить,
какие регистры он использует впервые. Изначальное значение регистров
unsigned, поэтому если регистру не присвоено никакое значение, то
невозможно использовать его для арифметических операций или как адрес
перезода для ~goto~.

#+BEGIN_SRC scheme
  (define (make-machine ops controller-text)
    (let ((machine (make-new-machine)))
      ((machine 'install-operations) ops)
      ((machine 'install-instruction-sequence)
       (assemble controller-text machine))
      machine))

  (define (make-new-machine)
    (let ((pc (make-register 'pc))
          (flag (make-register 'flag))
          (stack (make-stack))
          (the-instruction-sequence  '()))
      (let ((the-ops
             (list (list 'initialize-stack
                         (lambda () (stack 'initialize)))))
            (register-table
             (list (list 'pc pc) (list 'flag flag))))
        (define (allocate-register name)
          (if (assoc name register-table)
              (error "Многократно определенный регистр: " name)
              (set! register-table
                    (cons (list name (make-register name))
                          register-table)))
          'register-allocated)
        (define (lookup-register name)
          (let ((val (assoc name register-table)))
            ;; если регистр есть,
            (if val
                ;; возвращаем его
                (cadr val)
                ;; иначе создаем новый и ищем его в таблице снова
                (begin
                  (allocate-register name)
                  (lookup-register name)))))
        (define (execute)
          (let ((insts (get-contents pc)))
            (if (null? insts)
                'done
                (begin
                  ((instruction-execution-proc (car insts)))
                  (execute)))))
        (define (dispatch message)
          (cond ((eq? message 'start)
                 (set-contents! pc the-instruction-sequence)
                 (execute))
                ((eq? message 'install-instruction-sequence)
                 (lambda (seq) (set! the-instruction-sequence seq)))
                ((eq? message 'allocate-register) allocate-register)
                ((eq? message 'get-register) lookup-register)
                ((eq? message 'install-operations)
                 (lambda (ops) (set! the-ops (append the-ops ops))))
                ((eq? message 'stack) stack)
                ((eq? message 'operations) the-ops)
                (else (error "Неизвестная операция -- MACHINE" message))))
        dispatch)))

  (define test
    (make-machine
     (list (list '= =) (list '+ +) (list 'display display))
     '((assign b (const 1))
       test-label-a
       (assign a (label test-label-a))
       (assign b (op +) (reg b) (const 1))
       (test (op =) (reg b) (const 3))
       (branch (label the-end))
       (goto (reg a))
       the-end
       )))

  (start test)
  (get-register-contents test 'b)
#+END_SRC


~Новая версия стека из мана~
#+BEGIN_SRC scheme
  (define (make-new-machine)
    (let ((pc (make-register 'pc))
          (flag (make-register 'flag))
          (stack (make-stack))
          (the-instruction-sequence  '()))
      (let ((the-ops
             (list (list 'initialize-stack
                         (lambda () (stack 'initialize)))
                   (list 'print-stack-statistics
                         (lambda () (stack 'print-statistics)))))
            (register-table
             (list (list 'pc pc) (list 'flag flag))))
        (define (allocate-register name)
          (if (assoc name register-table)
              (error "Многократно определенный регистр: " name)
              (set! register-table
                    (cons (list name (make-register name))
                          register-table)))
          'register-allocated)
        (define (lookup-register name)
          (let ((val (assoc name register-table)))
            (if val
                (cadr val)
                (error "Неизвестный регистр:" name))))
        (define (execute)
          (let ((insts (get-contents pc)))
            (if (null? insts)
                'done
                (begin
                  ((instruction-execution-proc (car insts)))
                  (execute)))))
        (define (dispatch message)
          (cond ((eq? message 'start)
                 (set-contents! pc the-instruction-sequence)
                 (execute))
                ((eq? message 'install-instruction-sequence)
                 (lambda (seq) (set! the-instruction-sequence seq)))
                ((eq? message 'allocate-register) allocate-register)
                ((eq? message 'get-register) lookup-register)
                ((eq? message 'the-instruction-sequence) the-instruction-sequence)
                ((eq? message 'install-operations)
                 (lambda (ops) (set! the-ops (append the-ops ops))))
                ((eq? message 'stack) stack)
                ((eq? message 'operations) the-ops)
                (else (error "Неизвестная операция -- MACHINE" message))))
        dispatch)))

  (define (make-stack)
    (let ((s '())
          (number-pushes 0)
          (max-depth 0)
          (current-depth 0))
      (define (push x)
        (set! s (cons x s))
        (set! number-pushes (+ 1 number-pushes))
        (set! current-depth (+ 1 current-depth))
        (set! max-depth (max current-depth max-depth)))
      (define (pop)
        (if (null? s)
            (error "Пустой стек -- POP")
            (let ((top (car s)))
              (set! s (cdr s))
              (set! current-depth (- current-depth 1))
              top)))
      (define (initialize)
        (set! s '())
        (set! number-pushes 0)
        (set! max-depth 0)
        (set! current-depth 0)
        'done)
      (define (print-statistics)
        (newline)
        (display (list 'total-pushes '= number-pushes
                        'maximum-depth '= max-depth)))
      (define (dispatch message)
        (cond ((eq? message 'push) push)
              ((eq? message 'pop) (pop))
              ((eq? message 'initialize) (initialize))
              ((eq? message 'print-statistics)
               (print-statistics))
              (else
               (error "Неизвестная операция -- STACK" message))))
      dispatch))


  ;; (factorial-machine 'get-instruction-sequence)
  ;; (set-register-contents! factorial-machine 'n 4)
  ;; (start factorial-machine)
#+END_SRC

~Упражнение 5.14.~
Измерьте количество сохранений и максимальную глубину стека, требуемую
для вычисления n! при различных малых значениях n с помощью факториальной машины,
показанной на рисунке ке 5.11. По этим данным определите формулы в
зависимости от n для числа сохранений и максимальной глубины стека,
требуемых для вычисления n! при любом n > 1.
Обратите внимание, что это линейные функции от n, и они определяются
двумя константами. Чтобы увидеть статистику, Вам придется добавить к
факториальной машине команды для инициализации
стека и распечатки статистики.
Можно также заставить машину в цикле считывать n, вычислять факториал и
печатать результат (как для машины НОД с рисунка 5.4), так, чтобы не
нужно было все время вызывать get-register-contents, set-register-contents! и start.

Факториальная машина.
#+BEGIN_SRC scheme
  (define factorial-machine
    (make-machine
     '(continue n val)
     (list (list '* *) (list '- -) (list '= =))
     '(controller
       (assign continue (label fact-done))
                                          ; установить адрес
                                          ; окончательного возврата
       fact-loop
       (test (op =) (reg n) (const 1))
       (branch (label base-case))
       ;; Подготовиться к рекурсивному вызову, сохраняя n и continue.
       ;; Установить
       ;; continue так, что вычисление продолжится
       ;; с after-fact после возврата из подпрограммы.
       (save continue)
       (save n)
       (assign n (op -) (reg n) (const 1))
       (assign continue (label after-fact))
       (goto (label fact-loop))
       after-fact
       (restore n)
       (restore continue)
       (assign val (op *) (reg n) (reg val)) ; теперь val содержит n(n − 1)!
       (goto (reg continue))
                                          ; возврат в вызывающую программу
       base-case
       (assign val (const 1))
                                          ; базовый случай: 1! = 1
       (goto (reg continue))
                                          ; возврат в вызывающую программу
       fact-done)))
#+END_SRC

Напишем 2 общие процедуры, которые позволят для любой машины
проинициализировать стек и распечатать статистику, и проведем
наблюдения.

#+BEGIN_SRC scheme
  (define (print-stat machine)
    ((machine 'stack) 'print-statistics))

  (define (initialize-stack machine)
    ((machine 'stack) 'initialize))


  (initialize-stack factorial-machine)
  (set-register-contents! factorial-machine 'n 5)
  (start factorial-machine)
  (get-register-contents factorial-machine 'val)

  (print-stat factorial-machine)

  ;; (total-pushes = 8 maximum-depth = 8)

  (initialize-stack factorial-machine)

  (set-register-contents! factorial-machine 'n 4)
  (start factorial-machine)
  (get-register-contents factorial-machine 'val)

  (print-stat factorial-machine)
  ;; (total-pushes = 10 maximum-depth = 6)

  (initialize-stack factorial-machine)
  (set-register-contents! factorial-machine 'n 3)
  (start factorial-machine)
  (get-register-contents factorial-machine 'val)

  (print-stat factorial-machine)

  ;; (total-pushes = 4 maximum-depth = 4)

  (initialize-stack factorial-machine)
  (set-register-contents! factorial-machine 'n 2)
  (start factorial-machine)
  (get-register-contents factorial-machine 'val)

  (print-stat factorial-machine)

  ;;(total-pushes = 2 maximum-depth = 2)

  (initialize-stack factorial-machine)
  (set-register-contents! factorial-machine 'n 1)
  (start factorial-machine)
  (get-register-contents factorial-machine 'val)

  (print-stat factorial-machine)

  ;; (total-pushes = 0 maximum-depth = 0)
#+END_SRC

Согласно им формулу макисмальной глубины для n! можно вывести как
(n - 1) * 2.

~Упражнение 5.15.~
Добавьте к модели регистровой машины подсчет команд (instruction
counting). Это значит, что машина должна подсчитывать число выполненных
ею команд. Расширьте интерфейс модели и добавьте новое сообщение, которое
печатает счетчик команд и переустанавливает его в ноль.

У нас есть ~the-instruction-sequence~, которая представляет собой список,
содержащий все команды. Если мы хоти узнать, сколько команд всего, то
можно просто распечатать длину этого списка. Но я так понимаю, что нужно
именно в процесс исполнения программы показать, сколько команд было
выполнено. Так что заведем соответствующий счетчик.

#+BEGIN_SRC scheme
  (define (make-new-machine)
    (let ((pc (make-register 'pc))
          (flag (make-register 'flag))
          (stack (make-stack))
          (instruction-cnt 0)
          (the-instruction-sequence  '()))
      (let ((the-ops
             (list (list 'initialize-stack
                         (lambda () (stack 'initialize)))
                   (list 'print-stack-statistics
                         (lambda () (stack 'print-statistics)))))
            (register-table
             (list (list 'pc pc) (list 'flag flag))))
        (define (allocate-register name)
          (if (assoc name register-table)
              (error "Многократно определенный регистр: " name)
              (set! register-table
                    (cons (list name (make-register name))
                          register-table)))
          'register-allocated)
        (define (lookup-register name)
          (let ((val (assoc name register-table)))
            (if val
                (cadr val)
                (error "Неизвестный регистр:" name))))
        (define (execute)
          (let ((insts (get-contents pc)))
            (if (null? insts)
                'done
                (begin
                  (set! instruction-cnt (+ instruction-cnt 1))
                  ((instruction-execution-proc (car insts)))
                  (execute)))))
        (define (print-cnt)
          (display "instruction-cuunter: ")
          (display instruction-cnt)
          (newline))
        (define (dispatch message)
          (cond ((eq? message 'start)
                 (set-contents! pc the-instruction-sequence)
                 (execute))
                ((eq? message 'install-instruction-sequence)
                 (lambda (seq) (set! the-instruction-sequence seq)))
                ((eq? message 'allocate-register) allocate-register)
                ((eq? message 'get-register) lookup-register)
                ((eq? message 'print-instruction-cuunter) (print-cnt))
                ((eq? message 'reset-instruction-cuunter) (set! instruction-cnt 0))
                ((eq? message 'get-instruction-sequence) the-instruction-sequence)
                ((eq? message 'install-operations)
                 (lambda (ops) (set! the-ops (append the-ops ops))))
                ((eq? message 'stack) stack)
                ((eq? message 'operations) the-ops)
                (else (error "Неизвестная операция -- MACHINE" message))))
        dispatch)))
#+END_SRC

~Упражнение 5.16.~
Добавьте к имитатору трассировку команд (instruction tracing). а именно,
перед тем, как выполнить каждую команду, имитатор должен распечатывать ее
текст. Заставьте модель принимать
сообщения trace-on и trace-off, которые включают и выключают трассировку.

#+BEGIN_SRC scheme
  (define (make-new-machine)
    (let ((pc (make-register 'pc))
          (flag (make-register 'flag))
          (stack (make-stack))
          (trace 0)
          (the-instruction-sequence  '()))
      (let ((the-ops
             (list (list 'initialize-stack
                         (lambda () (stack 'initialize)))
                   (list 'print-stack-statistics
                         (lambda () (stack 'print-statistics)))))
            (register-table
             (list (list 'pc pc) (list 'flag flag))))
        (define (allocate-register name)
          (if (assoc name register-table)
              (error "Многократно определенный регистр: " name)
              (set! register-table
                    (cons (list name (make-register name))
                          register-table)))
          'register-allocated)
        (define (lookup-register name)
          (let ((val (assoc name register-table)))
            (if val
                (cadr val)
                (error "Неизвестный регистр:" name))))

        (define (execute)
          (let ((insts (get-contents pc)))
            (if (null? insts)
                'done
                (if (= trace 1)
                (begin
                  (display (caar insts))
                  (newline)
                  ((instruction-execution-proc (car insts)))
                  (execute))
                (begin
                  ((instruction-execution-proc (car insts)))
                  (execute))))))
        (define (dispatch message)
          (cond ((eq? message 'start)
                 (set-contents! pc the-instruction-sequence)
                 (execute))
                ((eq? message 'install-instruction-sequence)
                 (lambda (seq) (set! the-instruction-sequence seq)))
                ((eq? message 'allocate-register) allocate-register)
                ((eq? message 'get-register) lookup-register)
                ((eq? message 'trace-off) (set! trace 0))
                ((eq? message 'trace-on) (set! trace 1))
                ((eq? message 'install-operations)
                 (lambda (ops) (set! the-ops (append the-ops ops))))
                ((eq? message 'stack) stack)
                ((eq? message 'operations) the-ops)
                (else (error "Неизвестная операция -- MACHINE" message))))
        dispatch)))

  ;; тестим на фаториальной машине

  ;; (factorial-machine 'trace-on)

  ;; (set-register-contents! factorial-machine 'n 3)

  ;; (start factorial-machine)

  ;; (factorial-machine 'trace-off)

  ;; (set-register-contents! factorial-machine 'n 3)

  ;; (start factorial-machine)
#+END_SRC

~Упражнение 5.17.~
Расширьте трассировку команд из упражнения 5.16 так, чтобы перед тем, как
печатать команду, имитатор распечатывал метки, которые стоят в последовательности
контроллера непосредственно перед этой командой.
Постарайтесь при этом не помешать подсчету команд (упражнение 5.15).
Придется заставить имитатор хранить необходимую информацию о метках.

Не очень понятно, что автор имел ввиду. Я понимаю это как требование
расширить трассировку таким образом, чтоб она показывала и метки
тоже. Т.е. чтоб можно было посмотреть текст программы целиком, а не
только команды.

Для этого необходимо:
- создать переменную, в которой будут храниться метки
- во время разбора кода выудить метки и заполнять ими переменную

План:
- если включена трассировка, то мы берем текущее выражение и смотрим,
  является ли оно частью какой-то метки (мы помним, что метка - это
  символ и все команды (выражения)  после него, до следующей метки или до конца
  программы, если больше меток нет)
- если да, то печатаем метку
- вне зависимости, нашли мы выражение среди меток или нет, печатаем команду
#+BEGIN_SRC scheme
  (define (assemble controller-text machine)
    (extract-labels controller-text
                    (lambda (insts labels)
                      (update-insts! insts labels machine)
                      ((machine 'install-instruction-labels) labels)
                                           insts)))
  (define (make-new-machine)
    (let ((pc (make-register 'pc))
          (flag (make-register 'flag))
          (stack (make-stack))
          (instruction-cnt 0)
          (trace 0)
          (the-instruction-labels '())
          (the-instruction-sequence '()))
      (let ((the-ops
             (list (list 'initialize-stack
                         (lambda () (stack 'initialize)))
                   (list 'print-stack-statistics
                         (lambda () (stack 'print-statistics)))))
            (register-table
             (list (list 'pc pc) (list 'flag flag))))
        (define (allocate-register name)
          (if (assoc name register-table)
              (error "Многократно определенный регистр: " name)
              (set! register-table
                    (cons (list name (make-register name))
                          register-table)))
          'register-allocated)
        (define (lookup-register name)
          (let ((val (assoc name register-table)))
            (if val
                (cadr val)
                (error "Неизвестный регистр:" name))))
        (define (lookup-insts labels insts)
          (let ((val (assoc insts labels)))
            (if val
                (begin
                  (display "val: ")
                  (display val)
                  (newline)
                  (cdr val)
                  )
                #f)))
        (define (execute)
          (let ((insts (get-contents pc)))
            (if (null? insts)
                'done
                (let ((inst (car insts)))
                  (if (= trace 1)
                      (begin
                        (let ((label (lookup-insts the-instruction-labels insts)))
                          (if label
                              (begin
                                (display label)
                                (newline))))
                        (newline)
                        (display (caar insts))
                        (newline)
                        ((instruction-execution-proc (car insts)))
                        (set! instruction-cnt (+ instruction-cnt 1))
                        (execute))
                      (begin
                        ((instruction-execution-proc (car insts)))
                        (set! instruction-cnt (+ instruction-cnt 1))
                        (execute)))))))
        (define (print-cnt)
          (display "instruction-cuunter: ")
          (display instruction-cnt)
          (newline))
        (define (dispatch message)
          (cond ((eq? message 'start)
                 (set-contents! pc the-instruction-sequence)
                 (execute))
                ((eq? message 'install-instruction-sequence)
                 (lambda (seq) (set! the-instruction-sequence seq)))
                ((eq? message 'allocate-register) allocate-register)
                ((eq? message 'get-register) lookup-register)
                ((eq? message 'trace-off) (set! trace 0))
                ((eq? message 'trace-on) (set! trace 1))
                ((eq? message 'install-instruction-labels) ;**
                 (lambda (labels) (set! the-instruction-labels
                                        (map (lambda (x) (cons (cdr x) (car x))) labels))))
                ((eq? message 'print-instruction-cuunter) (print-cnt))
                ((eq? message 'reset-instruction-cuunter) (set! instruction-cnt 0))
                ((eq? message 'get-instruction-sequence) the-instruction-sequence)
                ((eq? message 'get-instruction-labels) the-instruction-labels)
                ((eq? message 'install-operations)
                 (lambda (ops) (set! the-ops (append the-ops ops))))
                ((eq? message 'stack) stack)
                ((eq? message 'operations) the-ops)
                (else (error "Неизвестная операция -- MACHINE" message))))
        dispatch)))

  ;; (factorial-machine 'get-instruction-labels)

  ;; (factorial-machine 'get-instruction-sequence)

  ;; (factorial-machine 'trace-on)

  ;; (set-register-contents! factorial-machine 'n 3)

  ;; (start factorial-machine)

  ;; (factorial-machine 'trace-off)

  ;; (set-register-contents! factorial-machine 'n 3)

  ;; (start factorial-machine)

  (equal? (cons '(assign continue (label fact-done)) '(lambda (x) x))
          (cons '(assign reg (label fact-done)) '(lambda (x) x)))
#+END_SRC

~Упражнение 5.18.~
Измените процедуру make-register из раздела 5.2.1, так, чтобы можно было
трассировать регистры.
Регистры должны принимать сообщения, которые включают и выключают
трассировку. Когда регистр подвергается трассировке, присваивание ему
значения должно вызывать распечатку имени регистра, старого его
содержимого и нового, которое ему присваивается. Расширьте
интерфейс модели и дайте пользователю возможность включать и выключать
трассировку для указанных регистров машины.

#+BEGIN_SRC scheme
  (define (make-register name)
    (let ((contents '*unassigned*)
          (trace 0))
      (define (dispatch message)
        (cond ((eq? message 'get) contents)
              ((eq? message 'trace-on) (set! trace 1))
              ((eq? message 'trace-off) (set! trace 0))
              ((eq? message 'set)
               (if (= trace 0)
                   (lambda (value) (set! contents value))
                   (lambda (value)
                     (display "reg-name: ")
                     (display name)
                     (display " | cur value: ")
                     (display contents)
                     (display " | future value: ")
                     (display value)
                     (newline)
                     (set! contents value))
                   ))
              (else
               (error "Неизвестная операция -- REGISTER" message))))
      dispatch))

  (define (make-new-machine)
    (let ((pc (make-register 'pc))
          (flag (make-register 'flag))
          (stack (make-stack))
          (the-instruction-sequence  '()))
      (let ((the-ops
             (list (list 'initialize-stack
                         (lambda () (stack 'initialize)))
                   (list 'print-stack-statistics
                         (lambda () (stack 'print-statistics)))))
            (register-table
             (list (list 'pc pc) (list 'flag flag))))
        (define (allocate-register name)
          (if (assoc name register-table)
              (error "Многократно определенный регистр: " name)
              (set! register-table
                    (cons (list name (make-register name))
                          register-table)))
          'register-allocated)
        (define (lookup-register name)
          (let ((val (assoc name register-table)))
            (if val
                (cadr val)
                (error "Неизвестный регистр:" name))))
        (define (execute)
          (let ((insts (get-contents pc)))
            (if (null? insts)
                'done
                (begin
                  ((instruction-execution-proc (car insts)))
                  (execute)))))
        ;; процедура, включающая/выключающая трассировку у одного регистра (передается имя
        ;; как отдельный символ) или нескольких (имена передаются списком)
        (define (trace-registers reg-names message)
          (if (null? reg-names)
              'done
              (if (pair? reg-names)
                  (let ((reg (lookup-register (car reg-names))))
                    (reg message)
                    (trace-registers (cdr reg-names) message))
                  (let ((reg (lookup-register reg-names)))
                    (reg message)
                    'done))))
        (define (dispatch message)
          (cond ((eq? message 'start)
                 (set-contents! pc the-instruction-sequence)
                 (execute))
                ((eq? message 'install-instruction-sequence)
                 (lambda (seq) (set! the-instruction-sequence seq)))
                ((eq? message 'allocate-register) allocate-register)
                ((eq? message 'get-register) lookup-register)
                ((eq? message 'trace-registers) trace-registers)
                ((eq? message 'install-operations)
                 (lambda (ops) (set! the-ops (append the-ops ops))))
                ((eq? message 'stack) stack)
                ((eq? message 'operations) the-ops)
                (else (error "Неизвестная операция -- MACHINE" message))))
        dispatch)))

  (define (turn-trace-reg-on machine reg-names)
    ((machine 'trace-registers) reg-names 'trace-on))

  (define (turn-trace-reg-off machine reg-names)
    ((machine 'trace-registers) reg-names 'trace-off))

  ;; тестируем новый функционал на факториале (залей машину факториала заново!)
  (turn-trace-reg-on factorial-machine '(n val))

  (set-register-contents! factorial-machine 'n 5)

  (start factorial-machine)

  (turn-trace-reg-off factorial-machine '(n val))

#+END_SRC

~Упражнение 5.19.~
Лиза П. Хакер хочет добавить в имитатор контрольные точки (breakpoints)
для облегчения отладки проектов машин. Вас наняли для реализации такой
возможности.
Лиза хочет, чтобы в последовательности команд контроллера можно было
указать место, где имитатор остановится и позволит ей исследовать
состояние машины.
Вам нужно реализовать процедуру (set-breakpoint <машина> <метка> <n>)
которая устанавливает контрольную точку перед n-й командой, следующей за
указанной меткой. Когда моделирование достигает контрольной точки,
имитатор должен распечатать метку и смещение точки, а затем прекратить
выполнение команд. Тогда Лиза может с помощью get-register-
contents и set-register-contents! исследовать и изменять состояние
имитируемой машины. Затем она должна быть способна продолжить выполнение, сказав
(proceed-machine <машина>)
Кроме того, необходимо иметь возможность удалить контрольную точку с
помощью (cancel-breakpoint <машина> <метка> <n>)
и удалить все контрольные точки с помощью (cancel-all-breakpoints <машина>)

Итак, от нас требуется создать подобие отладчика.

Каждый брейкпоинт - это объект, содержащий в себе метку, смещение и
выражение, на котором требуется остановиться.

Общий алгоритм установки бряка:
- юзер хочет устновить бряк на конкретной точке (метка смещение)
- сначала мы ищем метку с помощью ~get-breakpoint-exp~
- затем считаем от нее смещение с помощью ~set-breakpoint-exp~, создаем
  новый объект бряка, записываем в него метку, смещение и выражение
- все бряки хранятся в таблице ~breakpoints~, ключом является выражение
(инструкция), на котором стоит бряк

Во время выполнения:
- перед исполнением каждого выражения в ~execute~ мы проверяем, является
  ли оно точкой брейкпоинта. Если да, то печатаем метку и смещение,
  сохраняем все оставшиеся инструкции в переменную
  ~breakpoint-save-insts~. Если же выражение бряком не является, то мы
  продолжаем выполнение как раньше, перейдя в ~continue-execute~

Возобновление исполнения:
- требуется вызвать ~continue-execute~ с инструкциями из
~breakpoint-save-insts~

Удаление бряка:
- юзер передает метку и смещение
- в ~reset-break-point~ мы перебираем все бряки, вытаскивая из их
  объектов метки и смещение. Если они совпадают с заданными юзером, то
  данные бряк не попадает в новую таблицу бряков
- удаляение всех бряков происходит, если юзер передает машине
  соответствующее сообщение. Тогда в ~breakpoints~ устанавливает пустой
  список

Тестилось на факториальной машине из упражнений выше.
#+BEGIN_SRC scheme
  (define (assemble controller-text machine)
    (extract-labels controller-text
                    (lambda (insts labels)
                      (update-insts! insts labels machine)
                      ((machine 'install-instruction-labels) labels)
                      insts)))


  (define (make-breakpoint label n)
    (let ((breakpoint-exp)
          (break-label label)
          (offset n))
      (define (set-breakpoint-exp exp)
        (set! breakpoint-exp exp))
      (define (dispatch message)
        (cond ((eq? message 'set-breakpoint-exp) set-breakpoint-exp)
              ((eq? message 'get-breakpoint-exp) breakpoint-exp)
              ((eq? message 'breakpoits-user) (list break-label offset))
              (else (error "Неизвестная операция -- BREAKPOINT" message))))
    dispatch))


  (define (make-new-machine)
    (let ((pc (make-register 'pc))
          (flag (make-register 'flag))
          (stack (make-stack))
          (instruction-cnt 0)
          (trace 0)
          (breakpoints'())
          (breakpoint-save-insts)  ;; сюда будем сохранять оставшиеся инструкции после бряка
          (the-instruction-labels '())
          (the-instruction-sequence '()))
      (let ((the-ops
             (list (list 'initialize-stack
                         (lambda () (stack 'initialize)))
                   (list 'print-stack-statistics
                         (lambda () (stack 'print-statistics)))))
            (register-table
             (list (list 'pc pc) (list 'flag flag))))

        (define (allocate-register name)
          (if (assoc name register-table)
              (error "Многократно определенный регистр: " name)
              (set! register-table
                    (cons (list name (make-register name))
                          register-table)))
          'register-allocated)

        (define (lookup-register name)
          (let ((val (assoc name register-table)))
            (if val
                (cadr val)
                (error "Неизвестный регистр:" name))))

        (define (lookup-insts labels insts)
          (let ((val (assoc insts labels)))
            (if val
                (cdr val)
                #f)))
        ;; считает смещение от конкретной метки и сохраняет выражение, на котором
        ;; юзер хочет остановиться, как выражение конкретного брейкпоинта
        (define (set-breakpoint-exp insts n break-label offset)
          (cond ((null? insts)
                 (error
                  "Нет выражений после метки или слишком большое смещение -- MACHINE"
                  break-label))
                ((= n 1)
                 (let* ((breakpoint (make-breakpoint break-label offset)))
                   ((breakpoint 'set-breakpoint-exp) (car insts))
                   (set! breakpoints (cons (cons (car insts) breakpoint)
                                           breakpoints))))
                (else (set-breakpoint-exp (cdr insts) (- n 1)  break-label offset))))

        ;; ищет метку брейкпоинта
        (define (get-breakpoint-exp break-label n)
          (define (get-breakpoint-exp-iter labels)
            (cond ((null? labels) (error "Нет такой метки -- MACHINE" break-label))
                  ((eq? break-label (cdar labels))
                   (set-breakpoint-exp (caar labels) n break-label n))
                  (else (get-breakpoint-exp-iter (cdr labels)))))
          (get-breakpoint-exp-iter the-instruction-labels))

        ;; убирает конкретный брейк из таблицы брейков
        (define (reset-break-point break-label offset)
          (define (reset-break-point-iter breaks new-breaks)
            (if (null? breaks)
                (set! breakpoints new-breaks)
                (let* ((break (cdar breaks))
                       (cur-break-label-offset (break 'breakpoits-user)))
                  (if (equal? (list break-label offset)
                              cur-break-label-offset)
                      (reset-break-point-iter (cdr breaks) new-breaks)
                      (reset-break-point-iter (cdr breaks)
                                              (cons breaks (car new-breaks)))))))
          (reset-break-point-iter breakpoints '()))

        ;; проверяет, есть ли текущее выражение в таблице брейкпоинтов
        (define (breakpoint? breakpoints exp)
          (let ((break (assoc exp breakpoints)))
            (if break
                (cdr break)
                false)))

        (define (execute)
          (let ((insts (get-contents pc)))
            (if (null? insts)
                'done
                (let* ((inst (car insts))
                       (break (breakpoint? breakpoints inst)))
                  (if break
                       (let ((user-break (break 'breakpoits-user)))
                         (display "breakpoint :")
                         (display user-break)
                         (newline)
                         (set! breakpoint-save-insts insts)
                         'stop)
                       (continue-execute insts))))))

        (define (continue-execute insts)
          (let ((inst (car insts)))
            (if (= trace 1)
                (begin
                  (let ((label (lookup-insts the-instruction-labels insts)))
                    (if label
                        (begin
                          (display label)
                          (newline))))
                  (newline)
                  (display (caar insts))
                  (newline)
                  ((instruction-execution-proc (car insts)))
                  (set! instruction-cnt (+ instruction-cnt 1))
                  (execute))
                (begin
                  ((instruction-execution-proc (car insts)))
                  (set! instruction-cnt (+ instruction-cnt 1))
                  (execute)))))

        (define (print-cnt)
          (display "instruction-cuunter: ")
          (display instruction-cnt)
          (newline))

        (define (dispatch message)
          (cond ((eq? message 'start)
                 (set-contents! pc the-instruction-sequence)
                 (execute))
                ((eq? message 'install-instruction-sequence)
                 (lambda (seq) (set! the-instruction-sequence seq)))
                ((eq? message 'allocate-register) allocate-register)
                ((eq? message 'get-register) lookup-register)
                ((eq? message 'trace-off) (set! trace 0))
                ((eq? message 'trace-on) (set! trace 1))
                ((eq? message 'install-instruction-labels)
                 (lambda (labels) (set! the-instruction-labels
                                        (map (lambda (x) (cons (cdr x) (car x))) labels))))
                ((eq? message 'print-instruction-cuunter) (print-cnt))
                ((eq? message 'reset-instruction-cuunter) (set! instruction-cnt 0))
                ((eq? message 'get-instruction-sequence) the-instruction-sequence)
                ((eq? message 'get-instruction-labels) the-instruction-labels)
                ((eq? message 'get-breakpoints) breakpoints)
                ((eq? message 'set-break-point) get-breakpoint-exp)
                ((eq? message 'reset-break-point) reset-break-point)
                ((eq? message 'reset-all-break-points) (set! breakpoints '()))
                ((eq? message 'proceed-machine) (continue-execute breakpoint-save-insts))
                ((eq? message 'install-operations)
                 (lambda (ops) (set! the-ops (append the-ops ops))))
                ((eq? message 'stack) stack)
                ((eq? message 'operations) the-ops)
                (else (error "Неизвестная операция -- MACHINE" message))))
        dispatch)))

  (define (set-break-points machine label n)
    ((machine 'set-break-point) label n))

  (define (proceed-machine machine)
    (machine 'proceed-machine))

  (define (reset-break-point machine label n)
    ((machine 'reset-break-point) label n))

  (define (reset-all-break-points machine)
    (machine 'reset-all-break-points))

  ;; (proceed-machine factorial-machine)

  ;; (set-break-points factorial-machine 'fact-loop 3)

  ;; (reset-break-point factorial-machine 'fact-loop 3)

  ;; (factorial-machine 'get-breakpoints)

  ;; (factorial-machine 'get-instruction-labels)

  ;; (factorial-machine 'get-instruction-sequence)

  ;; (factorial-machine 'trace-on)

  ;; (set-register-contents! factorial-machine 'n 3)

  ;; (start factorial-machine)

  ;; (factorial-machine 'trace-off)

  ;; (set-register-contents! factorial-machine 'n 3)

  ;; (start factorial-machine)

#+END_SRC

~Упражнение 5.20.~
Нарисуйте стрелочную диаграмму и представление в виде вектора (как на
рисунке 5.14) списка,
который порождается кодом
#+BEGIN_SRC scheme
  (define x (cons 1 2))

  (define y (list x x))
#+END_SRC

если вначале указатель free равен p1. Чему равно значение free после
исполнения кода? Какие указатели представляют значения x и y?

Сделано на листочке.

~Упражнение 5.21.~
Реализуйте регистровые машины для следующих процедур. Считайте, что
операции с памятью, реализующие списковую структуру, имеются в машине как
примитивы.


Доделать!
#+BEGIN_SRC scheme
  (define (count-leaves tree)
    (cond ((null? tree) 0)
          ((not (pair? tree)) 1)
          (else (+ (count-leaves (car tree))
                   (count-leaves (cdr tree))))))


  (define count-leaves-machine
    (make-machine
     '(tree  continue elt n t)
     (list (list '+ +) (list 'not not) (list 'cdr cdr) (list 'car car)
           (list 'null? null?) (list 'pair? pair?))



  (define (count-leaves tree)
    (define (count-iter tree n)
      (cond ((null? tree) n)
            ((not (pair? tree)) (+ n 1))
            (else (count-iter (cdr tree)
                              (count-iter (car tree) n)))))
    (count-iter tree 0))


  (define count-leaves-machine
    (make-machine
    '(tree  continue elt n t)
    (list (list '+ +) (list 'not not) (list 'cdr cdr) (list 'car car)
          (list 'null? null?) (list 'pair? pair?))
    '(start
      (assign n (const 0))
      (assign continue (label done))

      loop-1

      (save tree)

      (test (op null?) (reg tree))
      (branch (label base-case-1))

      (assign t (op pair?) (reg tree))
      (test (op not) (reg t))
      (branch (label base-case-2))

      (save continue)
      (assign tree (op cdr) tree)
      (assign continue after-loop)
      (goto (label loop-1))

      base-case-2
      (assign n (op +) (reg n) (const 1))

      base-case-1
      (restore continue)
      (goto (reg continue))

      after-loop
      (restore tree)

      (test (op null?) (reg tree))
      (branch (label base-case-1))

      (assign t (op pair?) (reg tree))
      (test (op not) (reg t))
      (branch (label base-case-2))

      (restore continue)
      (goto (reg continue))
      done

      )))

  ((1 2) (3 4) (5 6))
   (1 2)             стек: ((3 4) (5 6))
   (2)             стек: ((3 4) (5 6)) 1
    2             стек: ((3 4) (5 6)) 1 '()

  n = 1


  (set-register-contents! count-leaves-machine 'tree '(a (b c (d)) (e f) g))

  (count-leaves '(a (b c (d)) (e f) g))

  (start count-leaves-machine)

  (get-register-contents count-leaves-machine 'n)



  '(a (b c (d)) (e f) g)

  after-loop
  (c (d)) (e f) g)
  done

  t = '(c (d))
  tree = b



  n = 2


  (define count-leaves-machine
    (make-machine
     '(tree  continue n t)
     (list (list '+ +) (list 'not not) (list 'cdr cdr) (list 'car car)
           (list 'null? null?) (list 'pair? pair?))
     '(start
       (assign n (const 0))
       (assign continue (label done))
       (save continue)

       loop-1

       (test (op null?) (reg tree))
       (branch (label after-loop))

       (assign t (op pair?) (reg tree))
       (test (op not) (reg t))
       (branch (label base-case-2))

       (assign t (op cdr) (reg tree))
       (save t)

       (assign tree (op car) (reg tree))
       (assign continue (label after-loop))

       (save continue)
       (goto (label loop-1))

       base-case-2
       (assign n (op +) (reg n) (const 1))

       after-loop
       (restore continue)
       (restore tree)
       (goto (reg continue))

       done
       )))





#+END_SRC

~Упражнение 5.22.~
В упражнении 3.12 из раздела 3.3.1 были представлены процедура append,
которая добавляет два списка друг к другу и получает третий, и процедура
append!, которая склеивает два списка вместе. Спроектируйте регистровые
машины, которые реализуют каждую из этих процедур. Предполагайте, что
операции с памятью, реализующие списковую структуру, являются примитивами.

Итак, нам предлагается создать обычный append и его недеструктвную
версию.
#+BEGIN_SRC scheme
  (define append-machine
    (make-machine
     '(continue list1 list2 final-list elt)
     (list (list 'cons cons) (list 'car car) (list 'cdr cdr) (list 'null? null?))
     '((assign continue (label prep-loop2))

       loop1

       (test (op null?) (reg list2))
       (branch (label base-case))

       (save continue)
       (assign elt (op car) (reg list2))
       (save elt)
       (assign continue (label after-loop))
       (assign list2 (op cdr) (reg list2))
       (goto (label loop1))

       base-case
       (assign final-list (reg list2))

       after-loop
       (restore elt)
       (restore continue)
       (assign final-list (op cons) (reg elt) (reg final-list))
       (goto (reg continue))

       prep-loop2
       (assign continue (label done))

       loop2

       (test (op null?) (reg list1))
       (branch (label after-loop))

       (save continue)
       (assign elt (op car) (reg list1))
       (save elt)
       (assign continue (label after-loop))
       (assign list1 (op cdr) (reg list1))
       (goto (label loop2))

       done)))

  ;; (set-register-contents! append-machine 'list1 '(1 2 3))
  ;; (set-register-contents! append-machine 'list2 '(4 5 6))
  ;; (start append-machine)

  ;; (get-register-contents append-machine 'final-list)

  (define append!-machine
    (make-machine
     '(continue list1 list2 elt)
     (list (list 'cons cons) (list 'car car) (list 'cdr cdr) (list 'null? null?))
     '((assign continue (label done))

       loop1

       (test (op null?) (reg list1))
       (branch (label after-loop))

       (save continue)
       (assign elt (op car) (reg list1))
       (save elt)
       (assign continue (label after-loop))
       (assign list1 (op cdr) (reg list1))
       (goto (label loop1))

       after-loop
       (restore elt)
       (restore continue)
       (assign list2 (op cons) (reg elt) (reg list2))
       (goto (reg continue))

       loop2

       (test (op null?) (reg list2))
       (branch (label loop2))

       (save continue)
       (assign elt (op car) (reg list2))
       (save elt)
       (assign continue (label after-loop))
       (assign list2 (op cdr) (reg list2))
       (goto (label loop2))

       done)))

  ;; (set-register-contents! append!-machine 'list1 '(1 2 3))
  ;; (set-register-contents! append!-machine 'list2 '(4 5 6))

  ;; (start append!-machine)

  ;; (get-register-contents append!-machine 'list2)
#+END_SRC

~Вычислитель с явным управлением~

Залить все из метациклического интерпретатора + процедуры для анализа
синтаксиса, но НЕ ПЕРЕОПРЕДЕЛЯТЬ APPLY!

#+BEGIN_SRC scheme
  (define (empty-arglist) '())

  (define (adjoin-arg arg arglist)
    (append arglist (list arg)))

  (define (last-operand? ops)
    (null? (cdr ops)))

  (define the-global-environment (setup-environment))

  (define (get-global-environment)
    the-global-environment)

  (define (self-evaluating? exp)
    (cond ((number? exp) true)
          ((string? exp) true)
          (else false)))

  (define apply-in-underlying-scheme apply)

  (define (apply-primitive-procedure proc args)
    (apply-in-underlying-scheme
     (primitive-implementation proc) args))

  (define primitive-procedures
    (list (list 'car car)
          (list 'cdr cdr)
          (list 'cadr cadr)
          (list 'cdar cdar)
          (list 'cddr cddr)
          (list 'caddr caddr)
          (list 'first first)
          (list 'second second)
          (list 'third third)
          (list 'fourth fourth)
          (list 'cons cons)
          (list 'null? null?)
          (list 'list list)
          (list 'assoc assoc)
          (list 'append append)
          (list 'not not)
          (list 'eq? eq?)
          (list 'equal? equal?)
          (list 'memq memq)
          (list 'newline newline)
          (list 'last-pair last-pair)
          (list '< <)
          (list '> >)
          (list '= =)
          (list '/ /)
          (list '* *)
          (list '+ +)
          (list '- -)
          (list 'display display)
          (list 'member member)
          (list 'even? even?)
          (list 'remainder remainder)
          ))

  (define eceval-operations
    (list (list 'lookup-variable-value lookup-variable-value)
          (list 'self-evaluating? self-evaluating?)
          (list 'variable? variable?)
          (list 'quoted?  quoted?)
          (list 'assignment? assignment?)
          (list 'definition? definition?)
          (list 'if? if?)
          (list 'lambda? lambda?)
          (list 'begin? begin?)
          (list 'application? application?)
          (list 'text-of-quotation text-of-quotation)
          (list 'lambda-parameters lambda-parameters)
          (list 'lambda-body lambda-body)
          (list 'make-procedure make-procedure)
          (list 'operands operands)
          (list 'operator operator)
          (list 'empty-arglist empty-arglist)
          (list 'no-operands? no-operands?)
          (list 'first-operand first-operand)
          (list 'last-operand? last-operand?)
          (list 'adjoin-arg adjoin-arg)
          (list 'rest-operands rest-operands)
          (list 'primitive-procedure? primitive-procedure?)
          (list 'compound-procedure? compound-procedure?)
          (list 'procedure-parameters procedure-parameters)
          (list 'procedure-environment procedure-environment)
          (list 'extend-environment extend-environment)
          (list 'procedure-body procedure-body)
          (list 'begin-actions begin-actions)
          (list 'first-exp first-exp)
          (list 'last-exp? last-exp?)
          (list 'rest-exps rest-exps)
          (list 'if-predicate if-predicate)
          (list 'if-alternative if-alternative)
          (list 'true? true?)
          (list 'if-consequent if-consequent)
          (list 'assignment-variable assignment-variable)
          (list 'assignment-value assignment-value)
          (list 'set-variable-value! set-variable-value!)
          (list 'definition-variable definition-variable)
          (list 'definition-value definition-value)
          (list 'define-variable! define-variable!)
          (list 'prompt-for-input prompt-for-input)
          (list 'get-global-environment get-global-environment)
          ;; (list 'initialize-stack initialize-stack)
          (list 'read read)
          (list 'announce-output announce-output)
          (list 'user-print user-print)
          (list 'apply-primitive-procedure apply-primitive-procedure)))

  (define eceval
    (make-machine
     '(exp env val continue proc argl unev)
     eceval-operations
     '(
       ;; запуск вычислителя
       read-eval-print-loop

       (perform (op initialize-stack))
       (perform
        (op prompt-for-input) (const ";;; Ввод EC-Eval:"))
       (assign exp (op read))
       (assign env (op get-global-environment))
       (assign continue (label print-result))
       (goto (label eval-dispatch))

       print-result
       (perform
        (op announce-output) (const ";;; Значение EC-Eval:"))
       (perform (op user-print) (reg val))
       (goto (label read-eval-print-loop))

       unknown-expression-type
       (assign val (const unknown-expression-type-error))
       (goto (label signal-error))

       unknown-procedure-type
       (restore continue)
                                          ; очистить стек (после apply-dispatch)
       (assign val (const unknown-procedure-type-error))
       (goto (label signal-error))
       signal-error
       (perform (op user-print) (reg val))
       (goto (label read-eval-print-loop))

      ;; eval
      eval-dispatch
      (test (op variable?) (reg exp))
      (branch (label ev-variable))
      (test (op self-evaluating?) (reg exp))
      (branch (label ev-self-eval))
      (test (op quoted?) (reg exp))
      (branch (label ev-quoted))
      (test (op assignment?) (reg exp))
      (branch (label ev-assignment))
      (test (op definition?) (reg exp))
      (branch (label ev-definition))
      (test (op if?) (reg exp))
      (branch (label ev-if))
      (test (op lambda?) (reg exp))
      (branch (label ev-lambda))
      (test (op begin?) (reg exp))
      (branch (label ev-begin))
      (test (op application?) (reg exp))
      (branch (label ev-application))
      (goto (label unknown-expression-type))

      ;; вычисление простых выражений
      ev-self-eval
      (assign val (reg exp))
      (goto (reg continue))

      ev-variable
      (assign val (op lookup-variable-value) (reg exp) (reg env))
      (goto (reg continue))

      ev-quoted
      (assign val (op text-of-quotation) (reg exp))
      (goto (reg continue))

      ;; вычисление вызовов процедур
      ev-lambda
      (assign unev (op lambda-parameters) (reg exp))
      (assign exp (op lambda-body) (reg exp))
      (assign val (op make-procedure)
              (reg unev) (reg exp) (reg env))
      (goto (reg continue))

      ev-application
      (save continue)
      (save env)
      (assign unev (op operands) (reg exp))
      (save unev)
      (assign exp (op operator) (reg exp))
      (assign continue (label ev-appl-did-operator))
      (goto (label eval-dispatch))

      ev-appl-did-operator
      (restore unev)
                                          ; операнды
      (restore env)
      (assign argl (op empty-arglist))
      (assign proc (reg val))
                                          ; оператор
      (test (op no-operands?) (reg unev))
      (branch (label apply-dispatch))
      (save proc)

      ev-appl-operand-loop
      (save argl)
      (assign exp (op first-operand) (reg unev))
      (test (op last-operand?) (reg unev))
      (branch (label ev-appl-last-arg))
      (save env)
      (save unev)
      (assign continue (label ev-appl-accumulate-arg))
      (goto (label eval-dispatch))

      ev-appl-accumulate-arg
      (restore unev)
      (restore env)
      (restore argl)
      (assign argl (op adjoin-arg) (reg val) (reg argl))
      (assign unev (op rest-operands) (reg unev))
      (goto (label ev-appl-operand-loop))

      ev-appl-last-arg
      (assign continue (label ev-appl-accum-last-arg))
      (goto (label eval-dispatch))

      ev-appl-accum-last-arg
      (restore argl)
      (assign argl (op adjoin-arg) (reg val) (reg argl))
      (restore proc)
      (goto (label apply-dispatch))

      apply-dispatch
      (test (op primitive-procedure?) (reg proc))
      (branch (label primitive-apply))
      (test (op compound-procedure?) (reg proc))
      (branch (label compound-apply))
      (goto (label unknown-procedure-type))

      primitive-apply
      (assign val (op apply-primitive-procedure)
              (reg proc)
              (reg argl))
      (restore continue)
      (goto (reg continue))

      compound-apply
      (assign unev (op procedure-parameters) (reg proc))

      (assign env (op procedure-environment) (reg proc))
      (assign env (op extend-environment)
              (reg unev) (reg argl) (reg env))
      (assign unev (op procedure-body) (reg proc))
      (goto (label ev-sequence))

      ;; вычисление последовательностей и хвостовая рекурсия
      ev-begin
      (assign unev (op begin-actions) (reg exp))
      (save continue)
      (goto (label ev-sequence))

      ev-sequence
      (assign exp (op first-exp) (reg unev))
      (test (op last-exp?) (reg unev))
      (branch (label ev-sequence-last-exp))
      (save unev)
      (save env)
      (assign continue (label ev-sequence-continue))
      (goto (label eval-dispatch))

      ev-sequence-continue
      (restore env)
      (restore unev)
      (assign unev (op rest-exps) (reg unev))
      (goto (label ev-sequence))

      ev-sequence-last-exp
      (restore continue)
      (goto (label eval-dispatch))

      ;; условные выражения
      ev-if
      (save exp)
                                          ; сохраняем выражение
      (save env)
      (save continue)
      (assign continue (label ev-if-decide))
      (assign exp (op if-predicate) (reg exp))
      (goto (label eval-dispatch))
      ; вычисляем предикат

      ev-if-decide
      (restore continue)
      (restore env)
      (restore exp)
      (test (op true?) (reg val))
      (branch (label ev-if-consequent))

      ev-if-alternative
      (assign exp (op if-alternative) (reg exp))
      (goto (label eval-dispatch))

      ev-if-consequent
      (assign exp (op if-consequent) (reg exp))
      (goto (label eval-dispatch))

      ;; присваивания
      ev-assignment
      (assign unev (op assignment-variable) (reg exp))
      (save unev)
                                          ; сохранить переменную
      (assign exp (op assignment-value) (reg exp))
      (save env)
      (save continue)
      (assign continue (label ev-assignment-1))
      (goto (label eval-dispatch)) ; вычислить присваиваемое значение

      ev-assignment-1
      (restore continue)
      (restore env)
      (restore unev)
      (perform
       (op set-variable-value!) (reg unev) (reg val) (reg env))
      (assign val (const ok))
      (goto (reg continue))

      ;; определения
      ev-definition
      (assign unev (op definition-variable) (reg exp))
      (save unev)
                                          ; сохранить переменную
      (assign exp (op definition-value) (reg exp))
      (save env)
      (save continue)
      (assign continue (label ev-definition-1))
      (goto (label eval-dispatch))
                                          ; вычислить значение переменной
      ev-definition-1
      (restore continue)
      (restore env)
      (restore unev)
      (perform
       (op define-variable!) (reg unev) (reg val) (reg env))
      (assign val (const ok))
      (goto (reg continue)))))

  ;;(start eceval)


  ;; (define (append x y)
  ;;   (if (null? x)
  ;;       y
  ;;       (cons (car x)
  ;;             (append (cdr x) y))))

  ;; (append '(1 2) '(3 4))

  (define the-global-environment (setup-environment))
#+END_SRC


~Упражнение 5.23.~
Расширьте вычислитель так, чтобы обрабатывались производные выражения
cond, let и тому подобные (раздел 4.1.2). Можно «сжульничать» и считать, что
синтаксические трансформации вроде cond->if имеются как машинные операции.

Начнем с let. У нас уже есть готовое решение из предыдущих упражнений по
преобразованию let в лямбду.

#+BEGIN_SRC scheme
  (define (let? exp)
    (tagged-list? exp 'let))

  (define (let->combination exp)
    (define (get-all-params exp)
      (if (null? exp)
          '()
          (cons (caar exp) (get-all-params (cdr exp)))))
    (define (get-all-exps exp)
      (if (null? exp)
          '()
          (cons (cadar exp) (get-all-exps (cdr exp)))))
    (append (list (make-lambda (get-all-params (cadr exp))
                               (cddr exp)))
            (get-all-exps (cadr exp))))
#+END_SRC

Добавим обработку cond
#+BEGIN_SRC scheme

  (define (cond? exp) (tagged-list? exp 'cond))

  (define (cond-clauses exp) (cdr exp))

  (define (cond-else-clause? clause)
    (eq? (cond-predicate clause) 'else))

  (define (cond-predicate clause) (car clause))

  (define (cond-actions clause) (cdr clause))

  (define (cond->if exp)
    (expand-clauses (cond-clauses exp)))

  (define (expand-clauses clauses)
    (if (null? clauses)
        'false
                                          ; нет ветви else
        (let ((first (car clauses))
              (rest (cdr clauses)))
          (if (cond-else-clause? first)
              (if (null? rest)
                  (sequence->exp (cond-actions first))
                  (error "Ветвь ELSE не последняя -- COND->IF"
                         clauses))
              (make-if (cond-predicate first)
                       (sequence->exp (cond-actions first))
                       (expand-clauses rest))))))
#+END_SRC

Добавляем исполнение let*

#+BEGIN_SRC scheme
  (define (make-let param-and-expr-list body)
    (list 'let param-and-expr-list body))

  (define (let*? exp)
    (tagged-list? exp 'let*))

  (define (let*->nested-lets exp)
    (define (iter param-and-expr-list body)
      (if (null? param-and-expr-list)
          body
          (make-let (list (car param-and-expr-list))
                    (iter (cdr param-and-expr-list) body))))
    (iter (cadr exp) (car (last-pair exp))))

  ;; тест
    (let* ((x 3)
           (y (+ x 2))
           (z (+ x y 5)))
      (* x z))

#+END_SRC

Создаем новые ветки вычислени.
#+BEGIN_SRC scheme
  (define eceval-operations
    (list (list 'lookup-variable-value lookup-variable-value)
          (list 'self-evaluating? self-evaluating?)
          (list 'variable? variable?)
          (list 'quoted?  quoted?)
          (list 'assignment? assignment?)
          (list 'definition? definition?)
          (list 'if? if?)
          (list 'lambda? lambda?)
          (list 'begin? begin?)
          (list 'application? application?)
          (list 'text-of-quotation text-of-quotation)
          (list 'lambda-parameters lambda-parameters)
          (list 'lambda-body lambda-body)
          (list 'make-procedure make-procedure)
          (list 'operands operands)
          (list 'operator operator)
          (list 'empty-arglist empty-arglist)
          (list 'no-operands? no-operands?)
          (list 'first-operand first-operand)
          (list 'last-operand? last-operand?)
          (list 'adjoin-arg adjoin-arg)
          (list 'rest-operands rest-operands)
          (list 'primitive-procedure? primitive-procedure?)
          (list 'compound-procedure? compound-procedure?)
          (list 'procedure-parameters procedure-parameters)
          (list 'procedure-environment procedure-environment)
          (list 'extend-environment extend-environment)
          (list 'procedure-body procedure-body)
          (list 'begin-actions begin-actions)
          (list 'first-exp first-exp)
          (list 'last-exp? last-exp?)
          (list 'rest-exps rest-exps)
          (list 'if-predicate if-predicate)
          (list 'if-alternative if-alternative)
          (list 'true? true?)
          (list 'if-consequent if-consequent)
          (list 'assignment-variable assignment-variable)
          (list 'assignment-value assignment-value)
          (list 'set-variable-value! set-variable-value!)
          (list 'definition-variable definition-variable)
          (list 'definition-value definition-value)
          (list 'define-variable! define-variable!)
          (list 'prompt-for-input prompt-for-input)
          (list 'get-global-environment get-global-environment)
          (list 'read read)
          (list 'announce-output announce-output)
          (list 'user-print user-print)
          (list 'apply-primitive-procedure apply-primitive-procedure)
          ;; обработка let
          (list 'let? let?)
          (list 'let->combination let->combination)
          ;; обработка cond
          (list 'cond? cond?)
          (list 'cond->if cond->if)
          ;; обработка let*
          (list 'make-let make-let)
          (list 'let*? let*?)
          (list 'let*->nested-lets let*->nested-lets)))

  (define eceval
    (make-machine
     '(exp env val continue proc argl unev)
     eceval-operations
     '(
       ;; запуск вычислителя
       read-eval-print-loop

       (perform (op initialize-stack))
       (perform
        (op prompt-for-input) (const ";;; Ввод EC-Eval:"))
       (assign exp (op read))
       (assign env (op get-global-environment))
       (assign continue (label print-result))
       (goto (label eval-dispatch))

       print-result
       (perform
        (op announce-output) (const ";;; Значение EC-Eval:"))
       (perform (op user-print) (reg val))
       (goto (label read-eval-print-loop))

       unknown-expression-type
       (assign val (const unknown-expression-type-error))
       (goto (label signal-error))

       unknown-procedure-type
       (restore continue)
                                          ; очистить стек (после apply-dispatch)
       (assign val (const unknown-procedure-type-error))
       (goto (label signal-error))
       signal-error
       (perform (op user-print) (reg val))
       (goto (label read-eval-print-loop))

       ;; eval
       eval-dispatch
       (test (op variable?) (reg exp))
       (branch (label ev-variable))
       (test (op let?) (reg exp))    ;; let
       (branch (label ev-let))
       (test (op cond?) (reg exp))   ;; cond
       (branch (label ev-cond))
       (test (op let*?) (reg exp))   ;; let*
       (branch (label ev-let*))
       (test (op self-evaluating?) (reg exp))
       (branch (label ev-self-eval))
       (test (op quoted?) (reg exp))
       (branch (label ev-quoted))
       (test (op assignment?) (reg exp))
       (branch (label ev-assignment))
       (test (op definition?) (reg exp))
       (branch (label ev-definition))
       (test (op if?) (reg exp))
       (branch (label ev-if))
       (test (op lambda?) (reg exp))
       (branch (label ev-lambda))
       (test (op begin?) (reg exp))
       (branch (label ev-begin))
       (test (op application?) (reg exp))
       (branch (label ev-application))
       (goto (label unknown-expression-type))

       ;; вычисление let
       ev-let
       (assign exp (op let->combination) (reg exp))
       (goto (label eval-dispatch))

       ;; вычисление cond
       ev-cond
       (assign exp (op cond->if) (reg exp))
       (goto (label eval-dispatch))

       ;; вычисление let*
       ev-let*
       (assign exp (op let*->nested-lets) (reg exp))
       (goto (label ev-let))

       ;; вычисление простых выражений
       ev-self-eval
       (assign val (reg exp))
       (goto (reg continue))

       ev-variable
       (assign val (op lookup-variable-value) (reg exp) (reg env))
       (goto (reg continue))

       ev-quoted
       (assign val (op text-of-quotation) (reg exp))
       (goto (reg continue))

       ;; вычисление вызовов процедур
       ev-lambda
       (assign unev (op lambda-parameters) (reg exp))
       (assign exp (op lambda-body) (reg exp))
       (assign val (op make-procedure)
               (reg unev) (reg exp) (reg env))
       (goto (reg continue))

       ev-application
       (save continue)
       (save env)
       (assign unev (op operands) (reg exp))
       (save unev)
       (assign exp (op operator) (reg exp))
       (assign continue (label ev-appl-did-operator))
       (goto (label eval-dispatch))

       ev-appl-did-operator
       (restore unev)
                                          ; операнды
       (restore env)
       (assign argl (op empty-arglist))
       (assign proc (reg val))
                                          ; оператор
       (test (op no-operands?) (reg unev))
       (branch (label apply-dispatch))
       (save proc)

       ev-appl-operand-loop
       (save argl)
       (assign exp (op first-operand) (reg unev))
       (test (op last-operand?) (reg unev))
       (branch (label ev-appl-last-arg))
       (save env)
       (save unev)
       (assign continue (label ev-appl-accumulate-arg))
       (goto (label eval-dispatch))

       ev-appl-accumulate-arg
       (restore unev)
       (restore env)
       (restore argl)
       (assign argl (op adjoin-arg) (reg val) (reg argl))
       (assign unev (op rest-operands) (reg unev))
       (goto (label ev-appl-operand-loop))

       ev-appl-last-arg
       (assign continue (label ev-appl-accum-last-arg))
       (goto (label eval-dispatch))

       ev-appl-accum-last-arg
       (restore argl)
       (assign argl (op adjoin-arg) (reg val) (reg argl))
       (restore proc)
       (goto (label apply-dispatch))

       apply-dispatch
       (test (op primitive-procedure?) (reg proc))
       (branch (label primitive-apply))
       (test (op compound-procedure?) (reg proc))
       (branch (label compound-apply))
       (goto (label unknown-procedure-type))

       primitive-apply
       (assign val (op apply-primitive-procedure)
               (reg proc)
               (reg argl))
       (restore continue)
       (goto (reg continue))

       compound-apply
       (assign unev (op procedure-parameters) (reg proc))

       (assign env (op procedure-environment) (reg proc))
       (assign env (op extend-environment)
               (reg unev) (reg argl) (reg env))
       (assign unev (op procedure-body) (reg proc))
       (goto (label ev-sequence))

       ;; вычисление последовательностей и хвостовая рекурсия
       ev-begin
       (assign unev (op begin-actions) (reg exp))
       (save continue)
       (goto (label ev-sequence))

       ev-sequence
       (assign exp (op first-exp) (reg unev))
       (test (op last-exp?) (reg unev))
       (branch (label ev-sequence-last-exp))
       (save unev)
       (save env)
       (assign continue (label ev-sequence-continue))
       (goto (label eval-dispatch))

       ev-sequence-continue
       (restore env)
       (restore unev)
       (assign unev (op rest-exps) (reg unev))
       (goto (label ev-sequence))

       ev-sequence-last-exp
       (restore continue)
       (goto (label eval-dispatch))

       ;; условные выражения
       ev-if
       (save exp)
                                          ; сохраняем выражение
       (save env)
       (save continue)
       (assign continue (label ev-if-decide))
       (assign exp (op if-predicate) (reg exp))
       (goto (label eval-dispatch))
                                          ; вычисляем предикат

       ev-if-decide
       (restore continue)
       (restore env)
       (restore exp)
       (test (op true?) (reg val))
       (branch (label ev-if-consequent))

       ev-if-alternative
       (assign exp (op if-alternative) (reg exp))
       (goto (label eval-dispatch))

       ev-if-consequent
       (assign exp (op if-consequent) (reg exp))
       (goto (label eval-dispatch))

       ;; присваивания
       ev-assignment
       (assign unev (op assignment-variable) (reg exp))
       (save unev)
                                          ; сохранить переменную
       (assign exp (op assignment-value) (reg exp))
       (save env)
       (save continue)
       (assign continue (label ev-assignment-1))
       (goto (label eval-dispatch)) ; вычислить присваиваемое значение

       ev-assignment-1
       (restore continue)
       (restore env)
       (restore unev)
       (perform
        (op set-variable-value!) (reg unev) (reg val) (reg env))
       (assign val (const ok))
       (goto (reg continue))

       ;; определения
       ev-definition
       (assign unev (op definition-variable) (reg exp))
       (save unev)
                                          ; сохранить переменную
       (assign exp (op definition-value) (reg exp))
       (save env)
       (save continue)
       (assign continue (label ev-definition-1))
       (goto (label eval-dispatch))
                                          ; вычислить значение переменной
       ev-definition-1
       (restore continue)
       (restore env)
       (restore unev)
       (perform
        (op define-variable!) (reg unev) (reg val) (reg env))
       (assign val (const ok))
       (goto (reg continue)))))

  ;; тест
  ;;(start eceval)

  ;; (cond ((> (+ 1 2) (+ 2 3)) (+ 2 3))
  ;;       ((< (+ 1 2) (+ 2 3)) (+ 1 2))
  ;;       (else false))

  ;; (let ((a 3) (b 4))
  ;;   (+ a b))

  ;; (let ((a 3)
  ;;       (b 4))
  ;;   (let ((n 3)
  ;;         (c 4))
  ;;   (+ a b n c)))

  ;; тест
  ;; (let* ((x 3)
  ;;        (y (+ x 2))
  ;;        (z (+ x y 5)))
  ;;   (* x z))
#+END_SRC

~Упражнение 5.24.~
Реализуйте cond как новую особую форму, не сводя его к if. Придется
организовать цикл, проверяющий предикаты последовательных ветвей cond,
пока один не окажется истинным, а затем с помощью ev-sequence выполнять
действия этой ветви.

#+BEGIN_SRC scheme

#+END_SRC

~Упражнение 5.25.~
Измените вычислитель так, чтобы он использовал нормальный порядок
вычислений, на основе ленивого интерпретатора из раздела 4.2.

Фактически от нас требуют переписать вычислитель так, чтоб он работал с
ленивыми вычислениями, т.е. на основе ленивого интерпретатора.
Эти изменения коснутся в основном исполнения процедур.

Раньше мы вычисляли операнды и оператор, теперь же по умолчанию будем
вычислять только оператор. На основе него мы будем принимать решение,
процедура составная или элементарная. Все элементарные процедуры -
строгие, мы сразу вычислим все операнды и передадим их значения в вызов
процедуры. Все составные процедуры - нестрогие, т.е. мы обернем выражения
аргументов в санки и только после этого запустим вычисления процедуры.

Добавляем все необходимые процедуры для санков как примитивы.
#+BEGIN_SRC scheme
  (define (delay-it exp env)
    (list 'thunk exp env))

  (define (thunk? obj)
    (tagged-list? obj 'thunk))

  (define (thunk-exp thunk) (cadr thunk))

  (define (thunk-env thunk) (caddr thunk))

  (define (evaluated-thunk? obj)
    (tagged-list? obj 'evaluated-thunk))

  (define (thunk-value evaluated-thunk) (cadr evaluated-thunk))

  (define (force-it obj)
    (cond ((thunk? obj)
           (let ((result (actual-value
                          (thunk-exp obj)
                          (thunk-env obj))))
             (set-car! obj 'evaluated-thunk)
             (set-car! (cdr obj) result)
                                          ; заменить exp на его значение
             (set-cdr! (cdr obj) '()) ; забыть ненужное env
             result))
          ((evaluated-thunk? obj)
           (thunk-value obj))
          (else obj)))
#+END_SRC

#+BEGIN_SRC scheme
  (define (list-of-arg-values exps env)
    (if (no-operands? exps)
        '()
        (cons (actual-value (first-operand exps) env)
              (list-of-arg-values (rest-operands exps)
                                  env))))

  (define (list-of-delayed-args exps env)
    (if (no-operands? exps)
        '()
        (cons (delay-it (first-operand exps) env)
              (list-of-delayed-args (rest-operands exps)
                                    env))))
#+END_SRC

#+BEGIN_SRC scheme
  (define (list-of-delayed-args? exp)
    (tagged-list? exp 'list-of-delayed-args))

  (define (list-of-arg-values? exp)
    (tagged-list? exp 'list-of-arg-values))

  (define eceval-operations
    (list (list 'lookup-variable-value lookup-variable-value)
          (list 'self-evaluating? self-evaluating?)
          (list 'variable? variable?)
          (list 'quoted?  quoted?)
          (list 'assignment? assignment?)
          (list 'definition? definition?)
          (list 'if? if?)
          (list 'lambda? lambda?)
          (list 'begin? begin?)
          (list 'application? application?)
          (list 'text-of-quotation text-of-quotation)
          (list 'lambda-parameters lambda-parameters)
          (list 'lambda-body lambda-body)
          (list 'make-procedure make-procedure)
          (list 'operands operands)
          (list 'operator operator)
          (list 'empty-arglist empty-arglist)
          (list 'no-operands? no-operands?)
          (list 'first-operand first-operand)
          (list 'last-operand? last-operand?)
          (list 'adjoin-arg adjoin-arg)
          (list 'rest-operands rest-operands)
          (list 'primitive-procedure? primitive-procedure?)
          (list 'compound-procedure? compound-procedure?)
          (list 'procedure-parameters procedure-parameters)
          (list 'procedure-environment procedure-environment)
          (list 'extend-environment extend-environment)
          (list 'procedure-body procedure-body)
          (list 'begin-actions begin-actions)
          (list 'first-exp first-exp)
          (list 'last-exp? last-exp?)
          (list 'rest-exps rest-exps)
          (list 'if-predicate if-predicate)
          (list 'if-alternative if-alternative)
          (list 'true? true?)
          (list 'if-consequent if-consequent)
          (list 'assignment-variable assignment-variable)
          (list 'assignment-value assignment-value)
          (list 'set-variable-value! set-variable-value!)
          (list 'definition-variable definition-variable)
          (list 'definition-value definition-value)
          (list 'define-variable! define-variable!)
          (list 'prompt-for-input prompt-for-input)
          (list 'get-global-environment get-global-environment)
          (list 'read read)
          (list 'announce-output announce-output)
          (list 'user-print user-print)
          (list 'apply-primitive-procedure apply-primitive-procedure)
          ;; обработка let
          (list 'let? let?)
          (list 'let->combination let->combination)
          ;; обработка cond
          (list 'cond? cond?)
          (list 'cond->if cond->if)
          ;; обработка let*
          (list 'make-let make-let)
          (list 'let*? let*?)
          (list 'let*->nested-lets let*->nested-lets)
          (list 'delay-it delay-it)
          (list 'force-it force-it)
          (list 'cons cons)
          (list 'list-of-delayed-args? list-of-delayed-args?)
          (list 'list-of-arg-values? list-of-arg-values?)))

  (define eceval
    (make-machine
     '(exp env val continue proc argl unev)
     eceval-operations
     '(
       ;; запуск вычислителя
       read-eval-print-loop

       (perform (op initialize-stack))
       (perform
        (op prompt-for-input) (const ";;; Ввод EC-Eval:"))
       (assign exp (op read))
       (assign env (op get-global-environment))
       (assign continue (label print-result))

       (goto (label actual-value))   ;; изменено

       print-result
       (perform
        (op announce-output) (const ";;; Значение EC-Eval:"))
       (perform (op user-print) (reg val))
       (goto (label read-eval-print-loop))

       unknown-expression-type
       (assign val (const unknown-expression-type-error))
       (goto (label signal-error))

       unknown-procedure-type
       (restore continue)
                                          ; очистить стек (после apply-dispatch)
       (assign val (const unknown-procedure-type-error))
       (goto (label signal-error))
       signal-error
       (perform (op user-print) (reg val))
       (goto (label read-eval-print-loop))

       actual-value
       ;; хз что может быть в continue, тупо сохраняем
       (save continue)
       (assign continue (label label-force-it))
       (goto (label eval-dispatch))

       label-force-it
       (restore continue)
       (assign exp (op force-it) (reg val))
       (goto (reg continue))

       ;; eval
       eval-dispatch
       (test (op variable?) (reg exp))
       (branch (label ev-variable))
       (test (op let?) (reg exp))    ;; let
       (branch (label ev-let))
       (test (op cond?) (reg exp))   ;; cond
       (branch (label ev-cond))
       (test (op let*?) (reg exp))   ;; let*
       (branch (label ev-let*))
       (test (op self-evaluating?) (reg exp))
       (branch (label ev-self-eval))
       (test (op quoted?) (reg exp))
       (branch (label ev-quoted))
       (test (op assignment?) (reg exp))
       (branch (label ev-assignment))
       (test (op definition?) (reg exp))
       (branch (label ev-definition))
       (test (op if?) (reg exp))
       (branch (label ev-if))
       (test (op lambda?) (reg exp))
       (branch (label ev-lambda))
       (test (op begin?) (reg exp))
       (branch (label ev-begin))
       (test (op list-of-delayed-args?) (reg exp)) ;; тест list-of-delayed-args
       (branch (label list-of-delayed-args))
       (test (op list-of-arg-values?) (reg exp)) ;; тест list-of-arg-values
       (branch (label list-of-arg-values-1))
       (test (op application?) (reg exp))
       (branch (label ev-application))
       (goto (label unknown-expression-type))

       ;; цикл по вынуждению санков (получаем значения аргументов для процедур)
       ;; перед его выполнением надо сохранить на стеке все выражения (хотя зачем?)
       list-of-arg-values-1
       (assign exp (op rest-operands) (reg exp))

       list-of-arg-values
       (test (op no-operands?) (reg exp))
       (branch (label prep-after-list-of-arg-values))

       (save continue)
       (save exp)

       (assign continue (label ev-rest-list-of-arg-values))
       (assign exp (op first-operand) (reg exp))
       (goto (label actual-value))

       ev-rest-list-of-arg-values
       (assign val (reg exp))
       (restore exp)
       (assign exp (op rest-operands) (reg exp))
       (save val)
       (assign continue (label after-list-of-arg-values))
       (goto (label list-of-arg-values))

       prep-after-list-of-arg-values
       (assign val (reg exp))

       after-list-of-arg-values
       (restore exp)
       (assign val (op cons) (reg exp) (reg val))
       (restore continue)
       (goto (reg continue))

       ;; цикл по запаковке выражений в санки
       list-of-delayed-args

       (test (op no-operands?) (reg exp))
       (branch (label prep-after-list-of-delayed-args))

       (save continue)
       (save exp)

       ;; (assign continue (label ev-rest-list-of-arg-values))
       (assign exp (op first-operand) (reg exp))
       (assign val (op delay-it) (reg exp) (reg env))

       ev-rest-list-of-delayed-args
       ;; (assign val (reg exp))
       (restore exp)
       (assign exp (op rest-operands) (reg exp))
       (save val)
       (assign continue (label after-list-of-delayed-args))
       (goto (label list-of-delayed-args))

       prep-after-list-of-delayed-args
       (assign val (reg exp))

       after-list-of-delayed-args
       (restore exp)
       (assign val (op cons) (reg exp) (reg val))
       (restore continue)
       (goto (reg continue))

       ;; вычисление let
       ev-let
       (assign exp (op let->combination) (reg exp))
       (goto (label eval-dispatch))

       ;; вычисление cond
       ev-cond
       (assign exp (op cond->if) (reg exp))
       (goto (label eval-dispatch))

       ;; вычисление let*
       ev-let*
       (assign exp (op let*->nested-lets) (reg exp))
       (goto (label ev-let))

       ;; вычисление простых выражений
       ev-self-eval
       (assign val (reg exp))
       (goto (reg continue))

       ev-variable
       (assign val (op lookup-variable-value) (reg exp) (reg env))
       (goto (reg continue))

       ev-quoted
       (assign val (op text-of-quotation) (reg exp))
       (goto (reg continue))

       ;; вычисление вызовов процедур
       ev-lambda
       (assign unev (op lambda-parameters) (reg exp))
       (assign exp (op lambda-body) (reg exp))
       (assign val (op make-procedure)
               (reg unev) (reg exp) (reg env))
       (goto (reg continue))

       ev-application
       (save continue)
       (save env)
       (assign unev (op operands) (reg exp))
       (save unev)
       (assign exp (op operator) (reg exp))
       (assign continue (label ev-appl-did-operator))
       (goto (label eval-dispatch))

       ev-appl-did-operator
       (restore unev)
                                          ; операнды
       (restore env)
       (assign argl (op empty-arglist))
       (assign proc (reg val))
                                          ; оператор
       (test (op no-operands?) (reg unev))
       (branch (label apply-dispatch))
       (save proc)

       ev-appl-operand-loop
       (save argl)
       (assign exp (op first-operand) (reg unev))
       (test (op last-operand?) (reg unev))
       (branch (label ev-appl-last-arg))
       (save env)
       (save unev)
       (assign continue (label ev-appl-accumulate-arg))
       (goto (label eval-dispatch))

       ev-appl-accumulate-arg
       (restore unev)
       (restore env)
       (restore argl)
       (assign argl (op adjoin-arg) (reg val) (reg argl))
       (assign unev (op rest-operands) (reg unev))
       (goto (label ev-appl-operand-loop))

       ev-appl-last-arg
       (assign continue (label ev-appl-accum-last-arg))
       (goto (label eval-dispatch))

       ev-appl-accum-last-arg
       (restore argl)
       (assign argl (op adjoin-arg) (reg val) (reg argl))
       (restore proc)
       (goto (label apply-dispatch))

       apply-dispatch
       (test (op primitive-procedure?) (reg proc))
       (branch (label primitive-apply))
       (test (op compound-procedure?) (reg proc))
       (branch (label compound-apply))
       (goto (label unknown-procedure-type))

       primitive-apply
       (assign val (op apply-primitive-procedure)
               (reg proc)
               (reg argl))
       (restore continue)
       (goto (reg continue))

       compound-apply
       (assign unev (op procedure-parameters) (reg proc))

       (assign env (op procedure-environment) (reg proc))
       (assign env (op extend-environment)
               (reg unev) (reg argl) (reg env))
       (assign unev (op procedure-body) (reg proc))
       (goto (label ev-sequence))

       ;; вычисление последовательностей и хвостовая рекурсия
       ev-begin
       (assign unev (op begin-actions) (reg exp))
       (save continue)
       (goto (label ev-sequence))

       ev-sequence
       (assign exp (op first-exp) (reg unev))
       (test (op last-exp?) (reg unev))
       (branch (label ev-sequence-last-exp))
       (save unev)
       (save env)
       (assign continue (label ev-sequence-continue))
       (goto (label eval-dispatch))

       ev-sequence-continue
       (restore env)
       (restore unev)
       (assign unev (op rest-exps) (reg unev))
       (goto (label ev-sequence))

       ev-sequence-last-exp
       (restore continue)
       (goto (label eval-dispatch))

       ;; условные выражения
       ev-if
       (save exp)
                                          ; сохраняем выражение
       (save env)
       (save continue)
       (assign continue (label ev-if-decide))
       (assign exp (op if-predicate) (reg exp))
       (goto (label eval-dispatch))
                                          ; вычисляем предикат

       ev-if-decide
       (restore continue)
       (restore env)
       (restore exp)
       (test (op true?) (reg val))
       (branch (label ev-if-consequent))

       ev-if-alternative
       (assign exp (op if-alternative) (reg exp))
       (goto (label eval-dispatch))

       ev-if-consequent
       (assign exp (op if-consequent) (reg exp))
       (goto (label eval-dispatch))

       ;; присваивания
       ev-assignment
       (assign unev (op assignment-variable) (reg exp))
       (save unev)
                                          ; сохранить переменную
       (assign exp (op assignment-value) (reg exp))
       (save env)
       (save continue)
       (assign continue (label ev-assignment-1))
       (goto (label eval-dispatch)) ; вычислить присваиваемое значение

       ev-assignment-1
       (restore continue)
       (restore env)
       (restore unev)
       (perform
        (op set-variable-value!) (reg unev) (reg val) (reg env))
       (assign val (const ok))
       (goto (reg continue))

       ;; определения
       ev-definition
       (assign unev (op definition-variable) (reg exp))
       (save unev)
                                          ; сохранить переменную
       (assign exp (op definition-value) (reg exp))
       (save env)
       (save continue)
       (assign continue (label ev-definition-1))
       (goto (label eval-dispatch))
                                          ; вычислить значение переменной
       ev-definition-1
       (restore continue)
       (restore env)
       (restore unev)
       (perform
        (op define-variable!) (reg unev) (reg val) (reg env))
       (assign val (const ok))
       (goto (reg continue)))))

  ;; (start eceval)

  ;; (list-of-delayed-args '(+ 1 2) '(+ 3 4) '(- 3 1))
  ;; (list-of-delayed-args '(+ 1 2))
  ;; (list-of-arg-values '(+ 1 2))


#+END_SRC
