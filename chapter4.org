#+STARTUP: showall indent hidestars


Все(?) процедуры, указанные в мане для построения метациклического
интерпретатора

~метациклический интерпретатор~

#+BEGIN_SRC scheme
  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((if? exp) (eval-if exp env))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((application? exp)
           (apply (eval (operator exp) env)
                  (list-of-values (operands exp) env)))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))

  (define apply-in-underlying-scheme apply)

  (define (apply procedure arguments)
    (cond ((primitive-procedure? procedure)
           (apply-primitive-procedure procedure arguments))
          ((compound-procedure? procedure)
           (eval-sequence
            (procedure-body procedure)
            (extend-environment
             (procedure-parameters procedure)
             arguments
             (procedure-environment procedure))))
          (else
           (error
            "Неизвестный тип процедуры -- APPLY" procedure))))

  (define (list-of-values exps env)
    (if (no-operands? exps)
        '()
         (cons (eval (first-operand exps) env)
               (list-of-values (rest-operands exps) env))))

  (define (eval-if exp env)
    (if (true? (eval (if-predicate exp) env))
        (eval (if-consequent exp) env)
        (eval (if-alternative exp) env)))

  (define (eval-sequence exps env)
    (cond ((last-exp? exps) (eval (first-exp exps) env))
          (else (eval (first-exp exps) env)
                (eval-sequence (rest-exps exps) env))))

  (define (eval-assignment exp env)
    (set-variable-value! (assignment-variable exp)
                         (eval (assignment-value exp) env)
                         env)
    'ok)

  (define (eval-definition exp env)
    (define-variable! (definition-variable exp)
      (eval (definition-value exp) env)
      env)
    'ok)

  (define (self-evaluating? exp)
    (cond ((number? exp) true)
          ((string? exp) true)
          (else false)))

  (define (variable? exp) (symbol? exp))

  (define (quoted? exp)
    (tagged-list? exp 'quote))

  (define (text-of-quotation exp) (cadr exp))

  (define (tagged-list? exp tag)
    (if (pair? exp)
        (eq? (car exp) tag)
        false))

  (define (assignment? exp)
    (tagged-list? exp 'set!))

  (define (assignment-variable exp) (cadr exp))

  (define (assignment-value exp) (caddr exp))

  (define (definition? exp)
    (tagged-list? exp 'define))

  (define (definition-variable exp)
    (if (symbol? (cadr exp))
        (cadr exp)
        (caadr exp)))

  (define (definition-value exp)
    (if (symbol? (cadr exp))
        (caddr exp)
        (make-lambda (cdadr exp)
                     (cddr exp))))

  (define (lambda? exp) (tagged-list? exp 'lambda))

  (define (lambda-parameters exp) (cadr exp))

  (define (lambda-body exp) (cddr exp))

  (define (make-lambda parameters body)
    (cons 'lambda (cons parameters body)))

  (define (if? exp) (tagged-list? exp 'if))

  (define (if-predicate exp) (cadr exp))

  (define (if-consequent exp) (caddr exp))

  (define (if-alternative exp)
    (if (not (null? (cdddr exp)))
        (cadddr exp)
        'false))

  (define (make-if predicate consequent alternative)
    (list 'if predicate consequent alternative))

  (define (begin? exp) (tagged-list? exp 'begin))

  (define (begin-actions exp) (cdr exp))

  (define (last-exp? seq) (null? (cdr seq)))

  (define (first-exp seq) (car seq))

  (define (rest-exps seq) (cdr seq))

  (define (sequence->exp seq)
    (cond ((null? seq) seq)
          ((last-exp? seq) (first-exp seq))
          (else (make-begin seq))))

  (define (make-begin seq) (cons 'begin seq))

  (define (application? exp) (pair? exp))

  (define (operator exp) (car exp))

  (define (operands exp) (cdr exp))

  (define (no-operands? ops) (null? ops))

  (define (first-operand ops) (car ops))

  (define (rest-operands ops) (cdr ops))

  (define (cond? exp) (tagged-list? exp 'cond))

  (define (cond-clauses exp) (cdr exp))

  (define (cond-else-clause? clause)
    (eq? (cond-predicate clause) 'else))

  (define (cond-predicate clause) (car clause))

  (define (cond-actions clause) (cdr clause))

  (define (cond->if exp)
    (expand-clauses (cond-clauses exp)))

  (define (expand-clauses clauses)
    (if (null? clauses)
        'false
                                          ; нет ветви else
         (let ((first (car clauses))
               (rest (cdr clauses)))
           (if (cond-else-clause? first)
               (if (null? rest)
                   (sequence->exp (cond-actions first))
                   (error "Ветвь ELSE не последняя -- COND->IF"
                          clauses))
               (make-if (cond-predicate first)
                        (sequence->exp (cond-actions first))
                        (expand-clauses rest))))))

  (define (true? x)
    (not (eq? x false)))

  (define (false? x)
    (eq? x false))

  (define (make-procedure parameters body env)
  (list 'procedure parameters body env))

  (define (compound-procedure? p)
    (tagged-list? p 'procedure))

  (define (procedure-parameters p) (cadr p))

  (define (procedure-body p) (caddr p))

  (define (procedure-environment p) (cadddr p))

  (define (enclosing-environment env) (cdr env))

  (define (first-frame env) (car env))

  (define the-empty-environment '())

  (define (make-frame variables values)
    (cons variables values))

  (define (frame-variables frame) (car frame))

  (define (frame-values frame) (cdr frame))

  (define (add-binding-to-frame! var val frame)
    (set-car! frame (cons var (car frame)))
    (set-cdr! frame (cons val (cdr frame))))

  (define (extend-environment vars vals base-env)
    (if (= (length vars) (length vals))
        (cons (make-frame vars vals) base-env)
        (if (< (length vars) (length vals))
            (error "Получено слишком много аргументов" vars vals)
            (error "Получено слишком мало аргументов" vars vals))))

  (define (lookup-variable-value var env)
    (define (env-loop env)
      (define (scan vars vals)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((eq? var (car vars))
               (car vals))
              (else (scan (cdr vars) (cdr vals)))))
      (if (eq? env the-empty-environment)
          (error "Несвязанная переменная" var)
          (let ((frame (first-frame env)))
            (scan (frame-variables frame)
                  (frame-values frame)))))
    (env-loop env))

  (define (set-variable-value! var val env)
    (define (env-loop env)
      (define (scan vars vals)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((eq? var (car vars))
               (set-car! vals val))
              (else (scan (cdr vars) (cdr vals)))))
      (if (eq? env the-empty-environment)
          (error "Несвязанная переменная -- SET!" var)
          (let ((frame (first-frame env)))
            (scan (frame-variables frame)
                  (frame-values frame)))))
    (env-loop env))

  (define (define-variable! var val env)
    (let ((frame (first-frame env)))
      (define (scan vars vals)
        (cond ((null? vars)
               (add-binding-to-frame! var val frame))
              ((eq? var (car vars))
               (set-car! vals val))
              (else (scan (cdr vars) (cdr vals)))))
      (scan (frame-variables frame)
            (frame-values frame))))

  (define (setup-environment)
    (let ((initial-env
           (extend-environment (primitive-procedure-names)
                               (primitive-procedure-objects)
                               the-empty-environment)))
      (define-variable! 'true true initial-env)
      (define-variable! 'false false initial-env)
      initial-env))

  (define (primitive-procedure? proc)
    (tagged-list? proc 'primitive))

  (define (primitive-implementation proc) (cadr proc))

  (define primitive-procedures
    (list (list 'car car)
          (list 'cdr cdr)
          (list 'cadr cadr)
          (list 'cdar cdar)
          (list 'cddr cddr)
          (list 'caddr caddr)
          (list 'first first)
          (list 'second second)
          (list 'third third)
          (list 'fourth fourth)
          (list 'cons cons)
          (list 'null? null?)
          (list 'list list)
          (list 'assoc assoc)
          (list 'append append)
          (list 'not not)
          (list 'eq? eq?)
          (list 'equal? equal?)
          (list 'xor xor)
          (list 'memq memq)
          (list 'newline newline)
          (list 'last-pair last-pair)
          (list '< <)
          (list '> >)
          (list '= =)
          (list '/ /)
          (list '* *)
          (list '+ +)
          (list '- -)
          (list 'display display)
          (list 'member member)
          (list 'even? even?)
          (list 'remainder remainder)
          ))

  (define (primitive-procedure-names)
    (map car
         primitive-procedures))

  (define (primitive-procedure-objects)
    (map (lambda (proc) (list 'primitive (cadr proc)))
         primitive-procedures))

  (define (apply-primitive-procedure proc args)
    (apply-in-underlying-scheme
     (primitive-implementation proc) args))

  (define input-prompt ";;; Ввод M-Eval:")
  (define output-prompt ";;; Значение M-Eval:")

  (define (driver-loop)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (let ((output (eval input the-global-environment)))
        (announce-output output-prompt)
        (user-print output)))
    (driver-loop))

  (define (prompt-for-input string)
    (newline) (newline) (display string) (newline))

  (define (announce-output string)
    (newline) (display string) (newline))

  (define (user-print object)
    (if (compound-procedure? object)
        (display (list 'compound-procedure
                        (procedure-parameters object)
                        (procedure-body object)
                        '<procedure-env>))
        (display object)))

  (define the-global-environment (setup-environment))
#+END_SRC


~Отделение анализа от исполнения~
#+BEGIN_SRC scheme
  (define (eval exp env)
    ((analyze exp) env))

  (define (analyze exp)
    (cond ((self-evaluating? exp)
           (analyze-self-evaluating exp))
          ((quoted? exp) (analyze-quoted exp))
          ((variable? exp) (analyze-variable exp))
          ((assignment? exp) (analyze-assignment exp))
          ((definition? exp) (analyze-definition exp))
          ((if? exp) (analyze-if exp))
          ((lambda? exp) (analyze-lambda exp))
          ((begin? exp) (analyze-sequence (begin-actions exp)))
          ((cond? exp) (analyze (cond->if exp)))
          ((application? exp) (analyze-application exp))
          (else
           (error "Неизвестный тип выражения -- ANALYZE" exp))))

  (define (analyze-self-evaluating exp)
    (lambda (env) exp))

  (define (analyze-quoted exp)
    (let ((qval (text-of-quotation exp)))
      (lambda (env) qval)))

  (define (analyze-variable exp)
    (lambda (env) (lookup-variable-value exp env)))

  (define (analyze-assignment exp)
    (let ((var (assignment-variable exp))
          (vproc (analyze (assignment-value exp))))
      (lambda (env)
        (set-variable-value! var (vproc env) env)
        'ok)))

  (define (analyze-definition exp)
    (let ((var (definition-variable exp))
          (vproc (analyze (definition-value exp))))
      (lambda (env)
        (define-variable! var (vproc env) env)
        'ok)))

  (define (analyze-if exp)
    (let ((pproc (analyze (if-predicate exp)))
          (cproc (analyze (if-consequent exp)))
          (aproc (analyze (if-alternative exp))))
      (lambda (env)
        (if (true? (pproc env))
            (cproc env)
            (aproc env)))))

  (define (analyze-lambda exp)
    (let ((vars (lambda-parameters exp))
          (bproc (analyze-sequence (lambda-body exp))))
      (lambda (env) (make-procedure vars bproc env))))

  (define (analyze-sequence exps)
    (define (sequentially proc1 proc2)
      (lambda (env) (proc1 env) (proc2 env)))
    (define (loop first-proc rest-procs)
      (if (null? rest-procs)
          first-proc
          (loop (sequentially first-proc (car rest-procs))
                (cdr rest-procs))))
    (let ((procs (map analyze exps)))
      (if (null? procs)
          (error "Пустая последовательность -- ANALYZE"))
      (loop (car procs) (cdr procs))))

  (define (analyze-application exp)
    (let ((fproc (analyze (operator exp)))
          (aprocs (map analyze (operands exp))))
      (lambda (env)
        (execute-application (fproc env)
                             (map (lambda (aproc) (aproc env))
                                  aprocs)))))
  (define (execute-application proc args)
    (cond ((primitive-procedure? proc)
           (apply-primitive-procedure proc args))
          ((compound-procedure? proc)
           ((procedure-body proc)
            (extend-environment (procedure-parameters proc)
                                args
                                (procedure-environment proc))))
          (else
           (error
            "Неизвестный тип процедуры -- EXECUTE-APPLICATION"
            proc))))
#+END_SRC

~ленивый интерпретатор~

Залей все для метациклического оператора (можно без кода для анализа
выражений до исполнения)

Можно, теоретически, проверить этим упражнения на ленивый интерпретатор:

И потом залей это:
Дополнения:
#+BEGIN_SRC scheme
  (define (actual-value exp env)
    (force-it (eval exp env)))

  (define (eval exp env)
    ;; самовычисляющееся? - вычислить сразу
    (cond ((self-evaluating? exp) exp)
          ;; переменная? - запусть ее поиск в окружении
          ((variable? exp) (lookup-variable-value exp env))
          ;; построение списока? - вернуть список или заковыченное выражение
          ((quoted? exp) (text-of-quotation exp))
          ;; присваивание? - запустить процесс присваивания
          ((assignment? exp) (eval-assignment exp env))
          ;; определение? - запустить процесс определения
          ((definition? exp) (eval-definition exp env))
          ;; особая форма if? - вычислить if
          ((if? exp) (eval-if exp env))
          ;; особая формя lambda? - создать процедуру
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ;; форма begin? - создать блок begin
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ;; cond? - превратить его в вложенные ифы
          ((cond? exp) (eval (cond->if exp) env))
          ;;вызов процедуры? - запустить вычисление процедуры
          ((application? exp)
           (apply (actual-value (operator exp) env)
                  (operands exp)
                  env))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))

  (define (apply procedure arguments env)
    (cond ((primitive-procedure? procedure)
           (apply-primitive-procedure
            procedure
            (list-of-arg-values arguments env))) ; изменение
          ((compound-procedure? procedure)
           (eval-sequence
            (procedure-body procedure)
            (extend-environment
             (procedure-parameters procedure)
             (list-of-delayed-args arguments env) ; изменение
             (procedure-environment procedure))))
          (else
           (error
            "Неизвестный тип процедуры -- APPLY" procedure))))

  (define (list-of-arg-values exps env)
    (if (no-operands? exps)
        '()
         (cons (actual-value (first-operand exps) env)
               (list-of-arg-values (rest-operands exps)
                                   env))))
  (define (list-of-delayed-args exps env)
    (if (no-operands? exps)
        '()
         (cons (delay-it (first-operand exps) env)
               (list-of-delayed-args (rest-operands exps)
                                     env))))

  (define (eval-if exp env)
    (if (true? (actual-value (if-predicate exp) env))
        (eval (if-consequent exp) env)
        (eval (if-alternative exp) env)))

  (define input-prompt ";;; Ввод L-Eval:")
  (define output-prompt ";;; Значение L-Eval:")
  (define (driver-loop)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (let ((output
             (actual-value input the-global-environment)))
        (announce-output output-prompt)
        (user-print output)))
    (driver-loop))

  (define the-global-environment (setup-environment))

  (define (delay-it exp env)
    (list 'thunk exp env))

  (define (thunk? obj)
    (tagged-list? obj 'thunk))

  (define (thunk-exp thunk) (cadr thunk))

  (define (thunk-env thunk) (caddr thunk))

  (define (evaluated-thunk? obj)
    (tagged-list? obj 'evaluated-thunk))

  (define (thunk-value evaluated-thunk) (cadr evaluated-thunk))

  (define (force-it obj)
    (cond ((thunk? obj)
           (let ((result (actual-value
                          (thunk-exp obj)
                          (thunk-env obj))))
             (set-car! obj 'evaluated-thunk)
             (set-car! (cdr obj) result)
                                          ; заменить exp на его значение
             (set-cdr! (cdr obj) '()) ; забыть ненужное env
             result))
          ((evaluated-thunk? obj)
           (thunk-value obj))
          (else obj)))

#+END_SRC


~Упражнение 4.1.~
Заметим, что мы не можем сказать, вычисляет ли метациклический
интерпретатор операнды слева направо или справа налево. Порядок
вычисления наследуется от нижележащего Лиспа: если аргументы ~cons~ в
процедуре ~list-of-values~ вычисляются слева направо, то и
операнды в ~list-of-values~ будут вычисляться слева направо. Если же вычисление
аргументов ~cons~ происходит справа налево, то и ~list-of-values~ будет
вычислять операнды справа налево.
Напишите версию ~list-of-values~, которая вычисляет операнды слева направо,
вне зависимости от порядка вычислений в нижележащем Лиспе. Напишите также версию,
которая вычисляет операнды справа налево.

Определение исходной версии ~list-of-values~

#+BEGIN_SRC scheme
  ;; принимает на вход список выражений и окружение
  ;; на выходе получим список рехультатов выражений
  (define (list-of-values exps env)
    (if (no-operands? exps)
        '()
         (cons (eval (first-operand exps) env)
               (list-of-values (rest-operands exps) env))))
#+END_SRC

Было похожее ~упражнение 3.8~, в котором требовалось именить порядок
вычисления.
В этом нам помог ~set!~, поскольку порядок вычисления формы ~set!~ всегда
будет один и тот же: сначала вычисляем выражение, результ которого
запишем в переменную, и только затем присвоим результат переменной.

Исходя из формулировки упражнения ясно, что ~cons~ использовать нельзя,
поскольку порядок вычислений может меняться. Значит нам надо соединить
результаты вычисления в список вручную, используя присваивание.

#+BEGIN_SRC scheme
  ;;вычисляет аргументы слева направо
  (define (my-list-of-values exps env)
    (define (iter exps env results)
    (if (no-operands? exps)
        results
        (let ((first-exp-result (list (eval (first-operand exps) env))))
          (if (null? results)
              (begin
                (set! results (list first-exp-result))
                (iter (rest-operands exps) env results))
              (begin
                (set-cdr! (last-pair results) (list first-exp-result))
                (iter (rest-operands exps) env results))))))
    (iter exps env '()))

  ;; поскольку my-list-of-values, определенную выше, протестить пока невозможно,
  ;; пишем аналогичную функцию и тестим ее
  (define (test list-args)
    (define (iter list-args results)
      (if (null? list-args)
          results
          (let ((first-elt (list (car list-args))))
            (if (null? results)
                (begin
                  (set! results (list first-elt))
                  (iter (cdr list-args) results))
                (begin
                  (set-cdr! (last-pair results) (list first-elt))
                  (iter (cdr list-args) results))))))
    (iter list-args '()))

  (test '(1 2 3 4))

  ;;вычисляет аргументы справа налево
  ;; выглядит как грязный хак, но работает
  (define (my-list-of-values exps env)
      (if (no-operands? exps)
          '()
          (let ((first-exp-result (eval (first-operand exps) env))
                (rest-args (my-list-of-values (rest-operands exps) env)))
            (cons first-exp-result rest-args))))

  ;; пишем аналогичную тестовую функцию
  (define (test list-args)
    (if (null? list-args)
        '()
        (let ((first (list (car list-args)))
              (rest (test (cdr list-args))))
          (cons first rest))))

  (test '(1 2 3 4))
#+END_SRC

~Упражнение 4.2.~
Хьюго Дум хочет переупорядочить ветви ~eval~ так, чтобы ветвь для вызова
процедур располагалась перед веткой для присваивания. Он утверждает, что при этом
интерпретатор станет эффективнее: поскольку в программах обычно больше
вызовов процедур, чем присваиваний, определений и т. д., его
усовершенствованный eval обычно будет рассматривать меньше вариантов,
чем исходный, при распознавании типа выражения.

а. Что за ошибка содержится в плане Хьюго? (Подсказка: что сделает его
интерпретатор с выражением (define x 3)?)

б. Хьюго расстроен, что его план не сработал. Он готов пойти на любые
жертвы, чтобы позволить интерпретатору распознавать вызовы процедур до того, как он
проверяет все остальные типы выражений.
Помогите ему, изменив синтаксис интерпретируемого языка
так, чтобы вызовы процедур начинались с символа call.
Например, вместо (factorial 3) нам теперь придется
писать (call factorial 3), а вместо (+ 1 2) — (call + 1 2).

Ответ а:
Хьюго в первом задании предлагает ветку исполнения процедур поместить в
начале, поскольку вызовы процедур встречаются чаще, значит, не придется
проверять все ветки каждый раз.

Но возникает проблема с определениями процедур типа (define x 3)
Срабатывает предикат ~defenition?~, поскольку выражение начинается с
~define~, затем вызывается данная процедура:

#+BEGIN_SRC scheme
  (define (eval-definition exp env)
    (define-variable! (definition-variable exp)
      (eval (definition-value exp) env)
      env)
    'ok)
#+END_SRC

Получаем имя переменной, затем вычисляем значение выражения в данном
окружении и присваиваем значение имени. Проблема в том, что define - это
синтаксический сахар для лямбды, которая в нем содержится. Это значит,
что (define x 3) может быть воспринят как вызов процедуры, в результате
таг define будет воспринят как оператор, который следует применить к
аргументм x и 3. В результате нас ждут ошибки.

Ответ б:
Чтоб избежать проблемы, описанной выше, нам теперь перед каждым вызовом
процедуры нужно будет писать, что это именно вызов, т.е. ~call~ или любой
другой зарезервированный для этого символ, что довольно неудобно.
И тогда редикат application? следует переписать таким образом, чтоб
первым делом он проверял наличие соответствующего тага у выражения.
Например, так:

#+BEGIN_SRC scheme
  (define (application? exp)
    (tagged-list? exp 'call))
#+END_SRC

~Упражнение 4.3.~
Перепишите ~eval~ так, чтобы диспетчеризация происходила в стиле,
управляемом данными. Сравните результат с дифференцированием, управляемым
данными, из упражнения 2.73. (Можно использовать car составного выражения
в качестве типа этого выражения, так как это хорошо
сочетается с синтаксисом, реализованным в этом разделе.)

Итак, раз нас просят использовать стиль, управляемый данными, значит, нам
нужно представить, что у нас есть таблица типов, как в колнце второй
главы и использовать ее. Предположим, что все операции уже помещены в
таблицу и теперь нам только достать их с gjvjom. ~apply-generic~, которая
самостоятельно найдет операцию в таблице для типов данных аргументов и
применит ее, если операция существует.

Некоторые процедуры будут вызываться самостоятельно, без ~apply-generic~,
поскольку сущесвуют в единственном виде для всех типов, остальные
выражения будут обрабатываться с помощью ~apply-generic~. Здесь есть
важное дополнение: чтоб данный способ сработал, вызов процедур должен
иметь вид (call вызов_нужной_процедуры), поскольку в исходном варианте
~eval~ вызовом процедуры считается любое выражение, которое является
списком и не подошло ни под одно предыдущее условие ~cond~

Сравнение с упражнением 2.73 выглядело бы более корректным, если бы я
использовала ~get~ вместо ~apply-generic~. Так что я напишу второй
вариант как в упражнении 2.73. В этом сучае так же придется изменить
представление вызова процедур.

Данное представление ~eval~, как и представление ~deriv~ делает программу
более гибкой, поскольку в случае добавления типов выражений, которые мы
хотим вычислить, нам не придется менять саму ~eval~, мы просто добавим
дополнительную процедуру в таблицу.

#+BEGIN_SRC scheme
  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          (else
           (apply-generic 'eval exp env))))

  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          (else
           ((get 'eval (car exp)) (cdr exp) env))))

#+END_SRC

~Упражнение 4.4.~
Вспомним определения особых форм and и or из главы 1:

- and: выражения вычисляются слева направо. Если значение какого-то из
  них оказывается ложным, возвращается ложь; оставшиеся выражения не
  вычисляются. Если все выражения оказываются истинными, возвращается
  значение последнего из них. Если нет ни одного выражения, возвращается истина.
- or: выражения вычисляются слева направо. Если значение какого-то из
  них оказывается истинным, возвращается это значение; оставшиеся
  выражения не вычисляются. Если все выражения оказываются ложными,
  или нет ни одного выражения, возвращается ложь.

Введите and и or в качестве новых особых форм интерпретатора, определив
соответствующие синтаксические процедуры и процедуры выполнения eval-and и eval-or. В
качестве альтернативы покажите, как можно реализовать and и or в виде
производных выражений.

Вариант а:
#+BEGIN_SRC scheme
  (define (or? exp)
    (tagged-list? exp 'or))

  (define (and? exp)
    (tagged-list? exp 'and))

  (define (eval-and exp env)
    (define (eval-and-iter exps env)
      (display exps)
      (newline)
      (cond ((null? exps) #t)
            ((null? (rest-exps exps)) (eval (first-exp exps) env))
            ((eval (first-exp exps) env) (eval-and-iter (rest-exps exps) env))
            (else #f)))
    (eval-and-iter (cdr exp) env))

  (define (eval-or exp env)
    (define (eval-or-iter exps env)
    (if (null? exps)
        #f
        (let ((some-result (eval (first-exp exps) env)))
          (if some-result
              some-result
              (eval-or (rest-exps exps) env)))))
    (display "eval-or")
    (newline)
    (display exp)
    (newline)
    (eval-or-iter (cdr exp) env))
#+END_SRC

Вставляем необходиые ветки в eval  и задливаем все в интерпретатор для проверки.
#+BEGIN_SRC scheme
  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((if? exp) (eval-if exp env))
          ((or? exp) (eval-or exp env))
          ((and? exp) (eval-and exp env))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((application? exp)
           (apply (eval (operator exp) env)
                  (list-of-values (operands exp) env)))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))
#+END_SRC

Вариант с производными выражениями:

#+BEGIN_SRC scheme
  (define (expand-and exp)
    (define (expand-and-iter exps)
      (if (null? exp)
          #t
          (let ((first (first-exp exps))
                (rest (rest-exps exps)))
            (if (null? rest)
                (sequence->exp (list first))
                (make-if first
                         (expand-and-iter (rest-exps exps))
                         #f)))))
    (expand-and-iter (cdr exp)))

  (define (expand-or exp)
    (define (expand-or-iter exps)
    (if (null? exps)
        #f
        (let ((first (first-exp exps))
              (rest (rest-exps exps)))
          (make-if first
                   (sequence->exp (list first))
                   (expand-or-iter (rest-exps exps))))))
    (expand-or-iter (cdr exp)))
#+END_SRC

Вставляем процедуры в eval и заливаем в интерпретатор
#+BEGIN_SRC scheme
  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((if? exp) (eval-if exp env))
          ((or? exp) (expand-or exp))
          ((and? exp) (expand-and exp))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((application? exp)
           (apply (eval (operator exp) env)
                  (list-of-values (operands exp) env)))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))
#+END_SRC

~Упражнение 4.5.~
В языке Scheme есть дополнительная разновидность синтаксиса вариантов
cond, (проверка) => (потребитель). Если результат вычисления <проверки> оказывается
истинным значением, то вычисляется <потребитель>. Его значение должно быть
одноместной процедурой; эта процедура вызывается со значением <проверки>
в качестве аргумента, и результат этого вызова возвращается как значение
выражения cond. Измените обработку cond так, чтобы она поддерживала этот
расширенный синтаксис.

У меня получилось только полностью его заменить..
#+BEGIN_SRC scheme
  (define (=>? exp)
    (tagged-list? exp '=>))

  (define (expand-clauses clauses)
    (if (null? clauses)
        'false
        (let ((first (car clauses))
              (rest (cdr clauses)))
          (if (cond-else-clause? first)
              (if (null? rest)
                  (sequence->exp (cond-actions first))
                  (error "Ветвь ELSE не последняя -- COND->IF"
                         clauses))
              (begin
                (display (sequence->exp
                          (list (append (cond-actions (cdr first))
                                        (list (cond-predicate first))))))
              ;; если первый символ из списка действий в текущем выражении =>
              ;; и при этом предикат истинен
              (make-if (and (=>? (cond-actions first)) (cond-predicate first))
                       ;; создаем выражение, в котором передаем действию из выражения
                       ;; значение предиката
                       (sequence->exp
                        (list (append (cond-actions (cdr first))
                                      (list (cond-predicate first)))))

                       ;; иначе создаем стандартный иф для cond
                       (make-if (cond-predicate first)
                                  (sequence->exp (cond-actions first))
                                  (expand-clauses rest))))))))

  (cond ((assoc 'v '((a 1) (b 2))) => cadr)
        ((assoc 'b '((a 3) (b 4))) => cadr)
        (else false))

#+END_SRC

~Упражнение 4.6.~
Выражения let производны, поскольку раскрываются в лямбду.
Напишите синтаксическое преобразование ~let->combination~, которое сводит
вычисление let-выражений к вычислению комбинаций указанного вида, и добавьте
соответствующую ветку для обработки let к eval.

#+BEGIN_SRC scheme
  (define (make-lambda parameters body)
    (cons 'lambda (cons parameters body)))

  (define (let? exp)
    (tagged-list? exp 'let))

  (define (let->combination exp)
    (define (get-all-params exp)
      (if (null? exp)
          '()
          (cons (caar exp) (get-all-params (cdr exp)))))
    (define (get-all-exps exp)
      (if (null? exp)
          '()
          (cons (cadar exp) (get-all-exps (cdr exp)))))
    (append (list (make-lambda (get-all-params (cadr exp))
                               (cddr exp)))
            (get-all-exps (cadr exp))))

;; тест
  (let ((a 3)
        (b 4))
    (let ((v 5)
          (g 7))
    (+ a b g v)))

#+END_SRC

Добавляем ветку в ~eval~

#+BEGIN_SRC scheme
  (define (eval exp env)
      (cond ((self-evaluating? exp) exp)
            ((variable? exp) (lookup-variable-value exp env))
            ((quoted? exp) (text-of-quotation exp))
            ((assignment? exp) (eval-assignment exp env))
            ((definition? exp) (eval-definition exp env))
            ((if? exp) (eval-if exp env))
            ((lambda? exp)
             (make-procedure (lambda-parameters exp)
                             (lambda-body exp)
                             env))
            ((begin? exp)
             (eval-sequence (begin-actions exp) env))
            ((cond? exp) (eval (cond->if exp) env))
            ((let? exp) (eval (let->combination exp) env))
            ((application? exp)
             (apply (eval (operator exp) env)
                    (list-of-values (operands exp) env)))
            (else
             (error "Неизвестный тип выражения -- EVAL" exp))))
#+END_SRC

~Упражнение 4.7~.
Особая форма ~let*~ подобна let, но только связывания переменных в let*
происходят последовательно, и каждое следующее связывание происходит в
окружении, где видны все предыдущие.
Объясните, каким образом можно переписать выражение ~let*~ в виде
набора вложенных выражений ~let~, и напишите процедуру ~let*->nested-lets~,
которая проделывает это преобразование. Если мы уже реализовали let (упражнение 4.6)
и хотим теперь расширить интерпретатор так, чтобы он обрабатывал let*, достаточно ли
будет добавить в ~eval~ ветвь, в которой действием записано
~(eval (let*->nested-lets exp) env)~
или нужно явным образом преобразовывать let* в набор непроизводных
выражений?

Преобразование формы let* -> вложенные let -> вложенные лямбды:
#+BEGIN_SRC scheme
  (let* ((x 3)
         (y (+ x 2))
         (z (+ x y 5)))
    (* x z))

  (let ((x 3))
    (let ((y (+ x 2)))
      (let ((z (+ x y 5)))
        (* x z))))

  ((lambda (x)
    ((lambda (y)
       ((lambda (z)
          (* x z)) (+ x y 5))) (+ x 2))) 3)
#+END_SRC

Пишем преобразование let* в вложенные let:

#+BEGIN_SRC scheme
  (define (make-let param-and-expr-list body)
    (list 'let param-and-expr-list body))

  (define (let*? exp)
    (tagged-list? exp 'let*))

  (define (let*->nested-lets exp)
    (define (iter param-and-expr-list body)
      (if (null? param-and-expr-list)
          body
          (make-let (list (car param-and-expr-list))
                    (iter (cdr param-and-expr-list) body))))
    (iter (cadr exp) (car (last-pair exp))))

  ;; тест
    (let* ((x 3)
           (y (+ x 2))
           (z (+ x y 5)))
      (* x z))

#+END_SRC

#+BEGIN_SRC scheme
  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((if? exp) (eval-if exp env))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((let? exp) (eval (let->combination exp) env))
          ((let*? exp) (eval (let*->nested-lets exp) env))
          ((application? exp)
           (apply (eval (operator exp) env)
                  (list-of-values (operands exp) env)))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))

#+END_SRC

Отдельно преобразовывать let* в вложенные лямбды не нужно, поскольку
~eval~ все доделает за нас:
 - при получении let* eval раскроет его в вложенные let благодаря
   сработавшей ветке  ~(eval (let*->nested-lets exp) env)~,
 - затем let будет преобразован в лямбду, а все вложенные let станут телом
   лямбды.
 - при вычислении процедуры вычисляется ее тело и аргументы. При
   вычислении тела лямбды мы наткнемся на вложенные ~let~ и раскроем их
   тоже.

И так до тех пор, пока выражение не превратится в такое, которое можно
вычислить полностью, поскольку именно к этому стремится ~eval~

~Упражнение 4.8.~
«Именованный let» — это вариант let, который имеет вид
(let <переменная> <связывание> <тело>)
Измените преобразование ~let->combination~ из упражнения 4.6 так, чтобы оно
поддерживало именованный let.

Пример именованного ~let~:
#+BEGIN_SRC scheme
  (define (fib n)
    (let fib-iter ((a 1)
                   (b 0)
                   (count n))
      (if (= count 0)
          b
          (fib-iter (+ a b) a (- count 1)))))
#+END_SRC

Обычно ~let~ раскрывается в вызов лямбды, а именованая лямбда выглядит так:
#+BEGIN_SRC scheme
  (define square
    (lambda (x) (* x x)))
#+END_SRC

Соответственно, нам просто нужно ракрыть вызов именованного ~let~ в
именованную лямбду. Это в общем случае. В конкретном пришлось
использовать промисы из-за имеющейся рекурсии, поэтому данное
преобразование годится только для этого примера.

Пока в матециклическом интерпретаторе проверить не удалось.
#+BEGIN_SRC scheme
  (define (fib n)
    (let fib-iter ((a 1)
                   (b 0)
                   (count n))
      (if (= count 0)
          b
          (fib-iter (+ a b) a (- count 1)))))

  ;; именованный let должен раскрыться в:
    (define fib-iter
      (lambda (a b count)
        (cons-stream a
                     (if (= count 0)
                         b
                         (fib-iter (+ a b) a (- count 1))))))

  (define (make-lambda parameters body)
    (cons 'lambda (cons parameters body)))

  (define (show-stream stream n)
    (if (= n 0)
        'done
        (begin
          (display (stream-car stream))
          (newline)
          (show-stream (stream-cdr stream) (- n 1)))))

  (define (let->combination exp)
    (define (get-all-params exp)
      (map (lambda (x) (car x)) exp))
    (define (get-all-exps exp)
      (map (lambda (x) (cadr x)) exp))
    (list 'define (cadr exp)
          (make-lambda (get-all-params (caddr exp))
                       (list (list
                              'cons-stream (car (get-all-params (caddr exp)))
                              (cadddr exp))))))

  (let->combination '(let fib-iter ((a 1)
                                    (b 0)
                                    (count n))
                       (if (= count 0)
                           b
                           (fib-iter (+ a b) a (- count 1)))))
#+END_SRC

~Упражнение 4.9~.
Во многих языках имеются различные конструкции для построения циклов,
например, do, for, while и until. В Scheme итеративные процессы можно
выразить через обычные вызовы процедур, так что особые конструкции не
дают никакого существенного выигрыша в вычислительной мощности.
С другой стороны, часто они удобны. Придумайте какие-нибудь
конструкции для итерации, дайте примеры их использования и покажите, как
их реализовать в виде производных выражений.

Попробуем реализовать относительно несложный цикл ~while~. Итерации
происходят до тех пор, пока условие while истинно.

#+BEGIN_SRC scheme
  (define (make-while condition step-form body)
    (list 'while condition step-form body ))

  (define (while? exp)
    (tagged-list? exp 'while))

  (define (eval-while exp env)
    (define (eval-while-iter condition body)
      (if (eval condition env)
          (begin
            (eval-sequence body env)
            (eval-while-iter condition body))
          'done
          ))
    (let ((exp-without-tag (rest-exps exp)))
      (eval-while-iter (first-exp exp-without-tag) (rest-exps exp-without-tag))))


  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((if? exp) (eval-if exp env))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((let? exp) (eval (let->combination exp) env))
          ((let*? exp) (eval (let*->nested-lets exp) env))
          ((while? exp) (eval-while exp env))
          ((application? exp)
           (apply (eval (operator exp) env)
                  (list-of-values (operands exp) env)))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))

  (define test 0)

  (while (< test 10)
         (display test)
         (set! test (+ test 1)))


#+END_SRC

И попробуем реализовать цикл ~for~.

#+BEGIN_SRC scheme
  (define (make-for var-and-init-value step-form condition body)
    (list 'for var-and-init-value step-form condition body))


  (define test (for (list i 0) (set! i (+ i 1)) (> i 20)
                     (display i))

  (define (for? exp)
    (tagged-list? exp 'for))

  (define (eval-for exp env)
    (define (eval-for-iter condition step-form-and-body)
      (if (not (eval condition env))
          (begin
            (eval-sequence step-form-and-body env)
            (eval-for-iter condition step-form-and-body))
          'done))
    (let* ((initial-form (first-exp (rest-exps exp)))
           (var (car initial-form))
           (init-value (cadr initial-form))
           (step-form (third exp))
           (condition (fourth exp))
           (step-form-and-body (append (cddddr exp) (list step-form))))
      (eval `(define ,var ,init-value) env)
      (eval-for-iter condition step-form-and-body)))

  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((if? exp) (eval-if exp env))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((let? exp) (eval (let->combination exp) env))
          ((let*? exp) (eval (let*->nested-lets exp) env))
          ((while? exp) (eval-while exp env))
          ((for? exp) (eval-for exp env))
          ((application? exp)
           (apply (eval (operator exp) env)
                  (list-of-values (operands exp) env)))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))
#+END_SRC

~Упражнение 4.11.~
Вместо того, чтобы представлять кадр в виде списка списков, его можно
представить как список связываний, где каждое связывание является парой из имени и
значения. Перепишите операции с окружениями в соответствии с этим
альтернативным представлением.

Исходное представление окружения:
- окружение - это список, состоящий из списокв
- каждый подсписок - это кадр
- каждый кадр содержит в себе два списка: список переменных и список их значений:

~'((a b c d) (1 2 3 4))~
Вместо исходного представления кадра нам предлагается представить кадр
как список списков, где каждый подсписок - это пара переменная-значение:
~'((a 1) (b 2) (c 3) (d 4))~

Значит, нам надо только изменить процедуры, работающие непосредственно с
кадрами.

Функции ~look-up-for-variable~ и ~extend-environment~ изменять не
пришлось
Проверено через обычную схему
#+BEGIN_SRC scheme
  (define the-empty-environment '())

  (define (enclosing-environment env) (cdr env))

  (define (first-frame env) (car env))

  (define (make-frame vars vals)
    (map (lambda (x y)
           (list x y )) vars vals))

  (define test-frame (make-frame '(a b c d) '(1 2 3 4)))

  (define (frame-variables frame)
    (map (lambda (x)
           (car x)) frame))

  (frame-variables test-frame)

  (define (frame-values frame)
    (map (lambda (x)
           (cadr x)) frame))

  (frame-values test-frame)

  (define (add-binding-to-frame! var val frame)
    (cons (list var val) frame))

  (add-binding-to-frame! 'e 5 test-frame)

  (define base-env (list test-frame test-frame))

  ;; присоединяем новый кадр к текущему окружению
  ;; изменять не пришлось
  (define (extend-environment vars vals base-env)
    (if (= (length vars) (length vals))
        (cons (make-frame vars vals) base-env)
        (if (< (length vars) (length vals))
            (error "Получено слишком много аргументов" vars vals)
            (error "Получено слишком мало аргументов" vars vals))))

  (set! base-env (extend-environment '(r t y u) '(5 6 7 8) base-env))

  (define (define-variable! var val env)
    (let ((cur-frame (first-frame env)))
      (define (scan frame)
        (if (null? frame)
            (begin
            (set-car! env
                      (add-binding-to-frame! var val cur-frame))
            #t)
            (let ((cur-pair (car frame)))
              (if (eq? var (car cur-pair))
                  (begin
                    (set-cdr! cur-pair (list val))
                    #t)
                  (scan (cdr frame))))))
      (scan cur-frame)))

  (define-variable! 't 0 base-env)
  (define-variable! 'k 0 base-env)

  (define (set-variable-value! var val env)
    (define (env-loop env)
      (define (scan frame)
        (if (null? frame)
            (env-loop (enclosing-environment env))
            (let ((cur-pair (car frame)))
              (if (eq? var (car cur-pair))
                  (begin
                    (set-cdr! cur-pair (list val))
                    #t)
                  (scan (cdr frame))))))
      (if (eq? env the-empty-environment)
          (error "Несвязанная переменная -- SET!" var)
          (let ((frame (first-frame env)))
            (scan frame))))
    (env-loop env))

  (set-variable-value! 'r 13 base-env)
  (set-variable-value! 'a 8 base-env)
  (set-variable-value! 'g 0 base-env)

  ;; ничего менять не пришлось
  (define (lookup-variable-value var env)
    (define (env-loop env)
      (define (scan vars vals)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((eq? var (car vars))
               (car vals))
              (else (scan (cdr vars) (cdr vals)))))
      (if (eq? env the-empty-environment)
          (error "Несвязанная переменная" var)
          (let ((frame (first-frame env)))
            (scan (frame-variables frame)
                  (frame-values frame)))))
    (env-loop env))

  (lookup-variable-value 'd base-env)
#+END_SRC

~Упражнение 4.12.~
Процедуры ~set-variable-value!~, ~define-variable!~ и ~lookup-variable-value~
можно выразить посредством более абстрактных процедур для просмотра структуры
окружений. Определите абстракции, которые фиксируют общую схему
поведения, и с их помощью перепишите эти три процедуры.

Я так понимаю, что нам нужно написать общую процедуру, через которую мы
сможем выразить три названные процедуры.

Чем похожи эти процедуры?
- все три ищут переменные в окружении
- все делают это более-менее похожим образом

Напишем общую процедуру для поиска чего-либо внутри окружения/кадра. Она
будет искать переменную в кадре и если найдет, то вернет ее индекс в
списке переменных (индекс начинается с нуля) или же #f если ничего нет.

Так же внутри исходной функции ~scan~ при нахождении нужной переменной
выполняются заданные действия, например, присвоение переменной другого
значения или же генерирование нового связывния и добавления его в текущий
кадр.

Мы для этого напишем отдельные функции: ~get-value-by-indx!~ и
~set-value-by-indx!~, они оба принимают индекс.
~get-value-by-indx!~ - возвращает хначение пересенной
~set-value-by-indx!~ - устанавливает значение переменной

Зачем нам индексы вообще? Дело в том, что список переменных и их значений
идет параллельно. Т.е. первый элемент списка переменных соответстввует
первому элементу писка значений и т.д. Соответственно, когда мы ищем
переменную, мы возвращаем ее порядковый номер, индекс, чтоб в дальнейшем
могли добраться до ее значения или ее самой по индексу.

Недостаток этого подхода заключается в том, что приходится дважды
проходить по спискам: первый раз когда ищем переменную и второй, когда
возвращаем/устанавливаем значение

Проверено через обычную схему
#+BEGIN_SRC scheme
  (define (make-frame variables values)
    (cons variables values))

  (define (frame-variables frame) (car frame))

  (define (frame-values frame) (cdr frame))

  (define (add-binding-to-frame! var val frame)
    (set-car! frame (cons var (car frame)))
    (set-cdr! frame (cons val (cdr frame))))

  (define base-env (list (make-frame '(a b c d) '(1 2 3 4))
                         (make-frame '(e f v n) '(5 6 7 8))))

  (define (set-value-by-indx! val vals indx)
    (if (= indx 0)
        (set-car! vals val)
        (set-value-by-indx! val (cdr vals) (- indx 1))))

  (define (scan var vars vals indx)
    (if (null? vars)
        #f
        (if (eq? var (car vars))
            indx
            (scan var (cdr vars) (cdr vals)))))

  (define (get-value-by-indx! vals indx)
    (if (= indx 0)
        (car vals)
        (get-value-by-indx! (cdr vals) (- indx 1))))

  (define (define-variable! var val env)
    (let* ((frame (first-frame env))
           (get-var-indx (scan var
                               (frame-variables frame)
                               (frame-values frame) 0)))
      (if get-var-indx
          (set-value-by-indx! val (frame-values frame)
                              get-var-indx)
          (add-binding-to-frame! var val frame))))

  (define-variable! 'd 10 base-env)

  (define (set-variable-value! var val env)
    (define (env-loop env)
      (if (eq? env the-empty-environment)
          (error "Несвязанная переменная -- SET!" var)
          (let* ((frame (first-frame env))
                 (get-var-indx (scan var
                                     (frame-variables frame)
                                     (frame-values frame) 0)))
                 (if get-var-indx
                     (set-value-by-indx! val (frame-values frame)
                                         get-var-indx)
                     (env-loop (cdr env))))))
    (env-loop env))

  (set-variable-value! 'd 14 base-env)

  (define (lookup-variable-value var env)
    (define (env-loop env)
      (if (eq? env the-empty-environment)
          (error "Несвязанная переменная" var)
          (let* ((frame (first-frame env))
                (get-var-indx (scan var
                                    (frame-variables frame)
                                    (frame-values frame) 0)))
            (if get-var-indx
                (get-value-by-indx! (frame-values frame)
                                    get-var-indx)
                (env-loop (cdr env))))))
    (env-loop env))

  (lookup-variable-value 'd base-env)
#+END_SRC

~Упражнение 4.13.~
Scheme позволяет создавать новые связывания через define, но не дает
никакого способа избавиться от связывания. Реализуйте в интерпретаторе особую форму
make-unbound!, которая изымает связывание данного символа из окружения, в
котором make-unbound! выполняется.

Задача определена не до конца. Например, нужно ли удалять связывания в
других кадрах, кроме первого? Дополните спецификацию и объясните свой выбор вариантов.

Наверное, прежде чем дополнять спецификацию, стоит подумать, зачем нам
отвязывание.

Освободить имя? Но имен очень много, вряд ли возникнет ситуация, когда
нужен именно этот символ и именно для конкретных целей, а он уже занят
какой-то другой привязкой.

Я думаю, что имеет смысл отвязывать переменные ради экономии
памяти. Тогда нам нужно отвязаться переменную во всех кадрах окружения,
убедившись перед этим, что на нее нигде нет ссылок. Тогда мы
сконструируем нечто, сильно напоминающее "сборщик мусора", а это сделать
непросто.

Поэтому я сделаю промежуточную версию сборщика мусора. Если поступит
команда отвязать переменную, я буду отвязывать ее во всех кадрах текущего
окружения. Мне кажется это более безопасным с точки зрения
программирования. Если этого не сделать, то могут возникнуть
сложноотслеживаемые баги. Например, у нас есть два кадра с одной и той же
переменной. Предположим, в первом кадре мы отвязали символ от текущей
переменной и присвоили его функции. Но во втором кадре этот символ занят
все еще переменной. Через какое-то время можно легко забыть, с чем в
каком кадре связан символ и потом долго гадать, почему интерпретатор
утверждает, что мы пытаемся обратиться к переменной как к функции и
наоборот. Особенно весело будет отлаживать такие вещи в большом проекте.

Предполагается, что кадры организованы как в мане, т.е. в виде пары с
двумя подсписками: в одном все переменные, в другом их значения

Проверено через обычную схему
#+BEGIN_SRC scheme
  (define (make-frame variables values)
    (cons variables values))

  (define (frame-variables frame) (car frame))

  (define (frame-values frame) (cdr frame))

  (define (scan-and-copy-frame var old-vars-list old-vals-list
                               new-vars-list new-vals-list)
    (cond ((null? old-vars-list)
           (make-frame new-vars-list new-vals-list))
          ((eq? var (car old-vars-list))
           (make-frame (append new-vars-list (cdr old-vars-list))
                       (append new-vals-list (cdr old-vals-list))))
          (else (scan-and-copy-frame var (cdr old-vars-list) (cdr old-vals-list)
                                     (append new-vars-list (list (car old-vars-list)))
                                     (append new-vals-list (list (car old-vals-list)))))))

  (scan-and-copy-frame 'f '(a s d f) '(1 2 3 4) '() '())

  (define (make-unbound! var env)
    (define (env-loop env)
      (if (eq? env the-empty-environment)
          'ok
          (let ((frame (first-frame env)))
            (set-car! env
                  (scan-and-copy-frame var (frame-variables frame)
                                       (frame-values frame)'() '()))
            (env-loop (cdr env)))))
    (env-loop env))

  (define test-env (list (make-frame '(a s d f) '(1 2 3 4))
                         (make-frame '(g s f k) '(5 6 7 8))))

  (make-unbound! 'd test-env)
  (make-unbound! 's test-env)
  (make-unbound! 'e test-env)
#+END_SRC

~Упражнение 4.14.~
Ева Лу Атор и Хьюго Дум экспериментируют с метациклическим
интерпретатором каждый по отдельности. Ева вводит определение ~map~ и
запускает несколько тестовых программ с его использованием. Они
замечательно работают.
Хьюго, со своей стороны, ввел системную версию ~map~
как примитив метациклического интерпретатора. Когда он пытается его
выполнить, все ломается самым ужасным образом.
Объясните, почему у Хьюго map не работает, а у Евы работает.

Ответ:
Думаю дело в парсинге всего выражения. Иными словами, если
метациклический интерпретатор встретит map Хьюго, map будет воспринят как
примитив.
Значит, eval сразу передаст метациклическому ~apply~ оператор и
аргументы, чтобы ~apply~ вызвал вызвал нижележащий ~apply~ и исполнил
вызов примитива. Возможная проблема в том, что перед передачей аргументов
в apply метациклический eval попытается вычислить аргументы операции,
чтоб передать в процедуру их значения. А аргументы map - это лямбда и
список. Если список eval еще можен корректно вычислить, то как она
вычислит лямбду, то вычисление лямбды может не совпадать у
метациклического и нижележащего интерпретатора. Нам в мане говорилось,
что данные eval и apply достаточно примитивны и совершенно не отражают
всю полноту вычислений и всех нюансов, которые происходят в настоящем
интерпретаторе.

~Упражнение 4.15.~
Если даны одноаргументная процедура p и объект a, то говорят, что p
«останавливается» на a, если выражение (p a) возвращает значение
(а не печатает сообщение об ошибке или выполняется
вечно).
Покажите, что невозможно написать процедуру halts?, которая бы
точно определяла для любой процедуры p и любого объекта a, останавливается ли p на
a. Используйте следующее рассуждение: если бы имелась такая процедура
halts?, можно было бы написать следующую программу:

#+BEGIN_SRC scheme
  (define (run-forever) (run-forever))

  (define (try p)
    (if (halts? p p)
        (run-forever)
        'halted))
#+END_SRC

Теперь рассмотрите выражение (try try) и покажите, что любое возможное
завершение (остановка или вечное выполнение) нарушает требуемое поведение
halts?

Разберем код, представленный выше. Нам сказано, что ~p~ - это
одноаргументная процедура. В процедуре ~try~ мы пытаемся
выявить, останавливается ли процедура ~p~ на переданном ей параметре - той
же процедуре ~p~. Процедура здесь является и данными, и процедурой.

Теперь рассмотрим вызов (try try). При проверке условия ифа, мы вызовем
операцию ~p~ с аргументов  ~p~ - в нашем случае это превратится в вызов
(try try) снова, и так до бесконечности. То есть мы просто навечно
зациклимся внутри ~try~, а до предиката исполнение так и не дойдет. То
есть мы не можем вернуть ~false~, если вычисление не останавливается,
потому что чтоб что-то вернуть, вычисление должно остановиться.

Чтоб построить процедуру ~halts?~, нам бы понадобился многопоточный
интерпретатор, если такой вообще можно сделать. Тогда, предположим, если
один поток интерпретатора долго не отвечает, то другие потоки могут
известить прогаммиста, что вычисление в одном из потоков зациклилось.

~Упражнение 4.16.~
В этом упражнении мы реализуем только что описанный метод обработки
внутренних определений. Мы предполагаем, что интерпретатор поддерживает
let (см. упражнение 4.6).
а. Измените процедуру ~lookup-variable-value~ (раздел 4.1.3) так, чтобы
она, обнаруживая в качестве значения символ *unassigned*, сообщала об ошибке.
б. Напишите процедуру ~scan-out-defines~, которая берет тело процедуры и
возвращает его эквивалент без внутренних определений, выполняя описанное нами
преобразование.
в. Вставьте ~scan-out-defines~ в интерпретатор, либо в ~make-procedure~, либо
в ~procedure-body~. Какое из этих мест лучше? Почему?

Проверено через обычную схему
#+BEGIN_SRC scheme
  ;;преобразование, описанное в мане
  (lambda <переменные>
    (define u <e1>)
    (define v <e2>)
    <e3>)

  (lambda <переменные>
    (let ((u '*unassigned*)
          (v '*unassigned*))
      (set! u <e1>)
      (set! v <e2>)
      <e3>))

  ;; необходимые для работы функции
  (define (definition? exp)
    (tagged-list? exp 'define))

  (define (tagged-list? exp tag)
    (if (pair? exp)
        (eq? (car exp) tag)
        #f))

  ;; задание А
  (define (lookup-variable-value var env)
    (define (env-loop env)
      (define (scan vars vals)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((eq? var (car vars))
               (if (eq? (car vals) '*unassigned*)
                   (error "Значение не определено" (car vals))
                   (car vals)))
              (else (scan (cdr vars) (cdr vals)))))
      (if (eq? env the-empty-environment)
          (error "Несвязанная переменная" var)
          (let ((frame (first-frame env)))
            (scan (frame-variables frame)
                  (frame-values frame)))))
    (env-loop env))

  (define env (list (make-frame '(a b c d) '(1 2 3 *unassigned*))
                    (make-frame '(h b s f) '(3 9 5 7))))

  (lookup-variable-value 'd env)

  ;;Задание Б

  ;; принимает тело исходной лямбды
  ;; возвращает список, состоящий из трех подсписков: имена, значения имен, остальное тело
  (define (split-names-values-body body-proc names values body)
    (if (null? body-proc)
        (list names values body)
        (let ((exp (car body-proc)))
          (if (definition? exp)
              (split-names-values-body  (cdr body-proc)
                             (append names (list (cadr exp)))
                             (append values (list (caddr exp))) body)
              (split-names-values-body  (cdr body-proc) names values
                                        (append body (list exp)))))))

  ;; создает заготовку для let:
  ;; принимает список имен
  ;; возвращает список списков, где car каждого подсписка - имя, а cdr - символ '*unassigned*
  (define (make-unassigned-let names)
    (map (lambda (name)
           (list name '*unassigned*)) names))

  ;; создает "присваивания" (ничего не присваивается на самом деле, мы просто соединяем
  ;; элементы присваивания (set! имя значение) в спики
  ;; возвращаем список, где все подсписки - это формы готовые выражения для присваивания
  (define (make-sets names values sets)
    (if (null? names)
        sets
        (make-sets (cdr names) (cdr values)
                   (append sets (list (list 'set! (car names) (car values)))))))

  ;; (make-sets (car test) (cadr test) '())

  (define (scan-out-defines proc)
    (let ((names-values-body (split-names-values-body (cddr proc)
                                                      '() '() '())))
      (list 'lambda (cadr proc)
            (append (list 'let (make-unassigned-let (car names-values-body)))
                          (make-sets (car names-values-body)
                                     (cadr names-values-body) '())
                          (caddr names-values-body)))))

  (define test '(lambda (x y z)
                  (define u 4)
                  (define k 5)
                  (+ u k)
                  (define h 6)))

  (scan-out-defines test)

#+END_SRC

Я бы вставила ~scan-out-defines~ непосредственно в интерпретатор, так мы
бы смогли использовать процедуру где угодно.

~Упражнение 4.17~.
Нарисуйте диаграммы окружения, которое находится в силе в момент
выполнения выражения <e3i> из процедуры выше по тексту, и сравните его устройство при
последовательной обработке определений и при описанном выше
преобразовании.
Откуда в преобразованной программе берется дополнительный кадр?
Объясните, почему это различие никогда не отражается на поведении
корректных программ. Придумайте, как заставить интерпретатор реализовать
правило «одновременной» сферы действия для внутренних определений без создания
дополнительного кадра.

#+BEGIN_SRC scheme
  (lambda <переменные>
    (define u <e1>)
    (define v <e2>)
    <e3>)

  (lambda <переменные>
    (let ((u '*unassigned*)
          (v '*unassigned*))
      (set! u <e1>)
      (set! v <e2>)
      <e3>))

#+END_SRC

Итак, дополнительный кадр образуется из-за использования формы ~let~,
которая всегда создает свое собственное окружение, поскольку раскрывается
в лямбду. Тело letстановится телом лямбды, объявляемые переменные
становятся параметрами лямбды, а выражения, которые присваивались
переменным, становятся аргументами, которые мы передаем лямбде при ее
вызове.

Справедливости ради надо отметить, что ~define~ тоже создает свое
собственное окружение, просто оно "закрывается" раньше, что <e3> начнет
выполняться, поскольку ~define~ объявляет свою переменную "глобально" для
окружения, в котором находится, поскольку раскрывается в именованную
лямбду. Поэтому к ней можно обратиться даже за пределами ее соственного
окружения, при условии, что ссылка на имя происходит после определения.

Разичия в поведении коректных программ из-за объявления через ~define~ или
через ~let~ нет, поскольку, фактически, все что не ~define~, т.е. не
определение - это тело функции. В нашем случае тело функции заключается в
тело ~let~, внутри которого мы имеем свободный доступ к объявленным
переменным.

Чтоб нам не пришлось создавать дополнительный кадр, нужно, чтоб у нас
остались ~define~, только при объявлении мы сделаем их *unassigned*, а
затем присвоим значение, какое планировали изначально.
Таким образом у нас получится такое преобразование:

#+BEGIN_SRC scheme
  (lambda <переменные>
    (define u <e1>)
    (define v <e2>)
    <e3>)

  (lambda <переменные>
    (define u '*unassigned*)
    (define v '*unassigned*)
    (set! u <e1>)
    (set! v <e2>)
      <e3>)

#+END_SRC

~Упражнение 4.18~.
Рассмотрим альтернативную стратегию обработки определений, которая
совершает такое преобразование:

#+BEGIN_SRC scheme
  (lambda <переменные>
    (define u <e1>)
    (define v <e2>)
    <e3>)

  (lambda <переменные>
    (let ((u '*unassigned*)
          (v '*unassigned*))
      (let ((a <e1i>)
            (b <e2>))
        (set! u a)
        (set! v b))
      <e3>))
#+END_SRC

Здесь a и b представляют новые имена переменных, созданные
интерпретатором, которые не встречаются в пользовательской программе.
Рассмотрим процедуру solve из раздела 3.5.4. Будет ли эта процедура
работать, если внутренние определения преобразуются так, как предлага-
ется в этом упражнении? А если так, как в тексте раздела? Объясните.

#+BEGIN_SRC scheme
  (define (solve f y0 dt)
    (define y (integral (delay dy) y0 dt))
    (define dy (stream-map f y))
    y)
#+END_SRC

Итак, solve - это пример цикличского задержанного выражения или промисов
внутри промисов. Чтоб вычислить ~y~ нам нужно знать ~dy~ и
наоборот. Поэтому мы вычисляем оба этих потока по очереди и поэтому
вычисление ~dy~ отложено.
Посмотрим, во что раскроется это выражение согласно тому, как это
предложено в этом упражнении:

#+BEGIN_SRC scheme
  (define solve
    (lambda (f y0 dt)
      (let ((y '*unassigned*)
            (dy '*unassigned*))
        (let ((a (integral (delay dy) y0 dt))
              (b (stream-map f y)))
          (set! y a)
          (set! dy b)) y)))   ;;----------->

  (define solve
    (lambda (f y0 dt)
      ((lambda  (y dy)
         ((lambda (a b)
            (set! y a)
            (set! dy b)) (integral (delay dy) y0 dt)
            (stream-map f y))
         y)
       '*unassigned* '*unassigned*)))

#+END_SRC

Данная трансформация не сработает. До присвоение мы попытаемся вычислить
аргументы ~a~ и ~b~ во внутренней лямбде. С аргументов ~a~ у нас все
получится, поскольку вычисление ~dy~ задержано. Но вот вычисление
аргумента ~b~ не состоится, поскольку выражение ~(stream-map f y)~
использует ~y~, значение которого не определено.

Теперь рассматриваем, что будет, если выражение раскроется, как описано в тексте:
#+BEGIN_SRC scheme
  (define solve
    (lambda (f y0 dt)
      (let ((y '*unassigned*)
            (dy '*unassigned*))
        (set! y (integral (delay dy) y0 dt))
        (set! dy (stream-map f y))
        y))) ;; --------------->

  (define solve
    (lambda (f y0 dt)
      ((lambda (y dy)
        (set! y (integral (delay dy) y0 dt))
        (set! dy (stream-map f y))
        y) '*unassigned* '*unassigned*)))

#+END_SRC

При вычислении этого выражения все сработает. Сначала значение ~y~ и ~dy~
не определено, но затем мы вычисляем выражения одно за другим и вовремя
присваиваем переменным реультаты вычисления выражения.

~Упражнение 4.19.~
Бен Битобор, Лиза П. Хакер и Ева Лу Атор спорят о том, каким должен быть
результат выражения

#+BEGIN_SRC scheme
  (let ((a 1))
    (define (f x)
      (define b (+ a x))
      (define a 5)
      (+ a b))
    (f 10))
#+END_SRC

Бен говорит, что следует действовать согласно последовательному правилу
для ~define~: ~b~ равно 11, затем ~a~ определяется как 5, так что общий
результат равен 16. Лиза возражает, что взаимная рекурсия требует правила
одновременной сферы действия для внутренних определений и нет причин
рассматривать имена процедур отдельно от прочих имен. То есть она
выступает за механизм, реализованный в упражнении 4.16.
При этом ~a~ оказывается не определено в момент, когда определяется ~b~.
Следовательно, по мнению Лизы, процедура должна выдавать ошибку. Ева не согласна с
обоими. Она говорит, что если определения вправду должны считаться
одновременными, то 5 как значение ~a~ должно использоваться при вычислении
~b~. Следовательно, по мнению Евы, ~a~ должно равняться 5, ~b~ должно
быть 15, а общий результат 20.
Какую из этих точек зрения Вы поддерживаете (если у Вас нет своей
четвертой)?
Можете ли Вы придумать способ реализации внутренних определений, который
бы работал так, как предлагает Ева?

Я попробовала запустить данное выражение и столкнулась с ошибкой
"переменная а уже зарезервирована". Это понятно, потому что происходит
внутри окружения ~let~, которая объявляет переменную ~a~ и присваивает ей
значение 1.
Соответственно, мы не можем объявить переменную с таким же именем.
Теперь предположим, что нам это все-таки удалось.
Тогда в этом случае при определении ~b~ мы будем использоват ранее
объявленное значение ~a~ и тогда пойдем по сценарию Бена, особенно если
будем использовать интерпретатор, который описан в этой главе.
В нем если мы встречаем повторное объявление переменной в том же
окружении, то мы просто присваиваем ей новое значение.

Чтоб реализовать вариант Евы, мы можем использовать промисы внутри
промисов. То есть отложить вычисление ~a~ или ~b~ до тех пор, пока они не
понадобятся.

Получится что-то вроде этого:
#+BEGIN_SRC scheme
  (let ((a 1))
    (define (f x)
      (define b (cons-stream x (+ (delay a) x)))
      (define a (cons-stream 5 5))
      (cons-stream x (add-streams a (force b)))
    (f 10)))
#+END_SRC

Это несовершенный вариант (я даже не уверена, что он может сработать),
поскольку первое значение, которое вернет нам поток, не будет правильным,
придеся ждать второе, к тому времени ~b~ будет полность вычислено и мы
сможем корректно посчитать результат.

~Упражнение 4.20.~
Поскольку внутренние определения выглядят последовательными, а на самом
деле параллельны, некоторые предпочитают их вовсе избегать и вместо этого
пользуются особой формой ~letrec~.
Letrec выглядит так же, как ~let~, поэтому неудивительно, что переменные в
нем связываются одновременно и имеют одинаковую для всех сферу действия.
Можно переписать процедуру-пример ~f~ из текста без внутренних
определений, но при этом в точности с тем же
значением, так:

#+BEGIN_SRC scheme
  (define (f x)
    (define (even? n)
      (if (= n 0)
          true
          (odd? (- n 1))))
    (define (odd? n)
      (if (= n 0)
          false
          (even? (- n 1))))
    <остаток тела f>) ;; -------->

  (define (f x)
    (letrec ((even?
              (lambda (n)
                (if (= n 0)
                    true
                    (odd? (- n 1)))))
             (odd?
              (lambda (n)
                (if (= n 0)
                    false
                    (even? (- n 1))))))
      <остаток тела f>))
#+END_SRC

Letrec является вариантом let, в котором выражения <выр i>, устанавливающие
начальные значения для переменных <пер i>, вычисляются в окружении,
которое включает все связывания letrec.
Это делает возможным рекурсию между связываниями, к примеру, взаимную
рекурсию even? и odd? в последнем примере, или вычисление факториала 10
через

#+BEGIN_SRC scheme
  (letrec ((fact
            (lambda (n)
              (if (= n 1)
                  1
                  (* n (fact (- n 1)))))))
    (fact 10))
#+END_SRC

а. Реализуйте ~letrec~ как производное выражение, переводя выражение letrec
в выражение ~let~, как показано в тексте раздела или в упражнении 4.18. То есть
переменные ~letrec~ должны создаваться в ~let~, а затем получать значение через set!.

б. Хьюго Дум совсем запутался во всех этих внутренних определениях. Ему
кажется, что если кому-то не нравятся ~define~ внутри процедуры, то пусть
пользуются обычным ~let~.
Покажите, что́ в его рассуждениях неверно. Нарисуйте диаграмму, показывающую
окружение, в котором выполняется <остаток тела f> во время вычисления
выражения (f 5), если ~f~ определена как в этом упражнении.
Нарисуйте диаграмму окружений для того же вычисления, но только с ~let~
на месте ~letrec~ в определении ~f~.

Проверено через обычную схему.
Задание а:
#+BEGIN_SRC scheme
  ;;получаем список имен и список значений, с ними связанных
  (define (split-names-values letrec-binds names values)
    (if (null? letrec-binds)
        (list names values)
        (let ((cur-bind (car letrec-binds)))
          (split-names-values (cdr letrec-binds)
                              (append names (list (car cur-bind)))
                              (append values (cdr cur-bind))))))

  (split-names-values (cadr test) '() '())

  ;; создаем связывания имен с *unassigned*
  (define (make-unassigned-let names)
    (map (lambda (name)
           (list name '*unassigned*)) names))

  ;;присваиваем именам правильные значения
  (define (make-sets names values sets)
    (if (null? names)
        sets
        (make-sets (cdr names) (cdr values)
                   (append sets (list (list 'set! (car names) (car values)))))))


  ;; совершаем трансформацию
  (define (letrec->let expr)
    (let ((names-and-values (split-names-values (cadr expr) '() '())))
      (append (list 'let (make-unassigned-let (car names-and-values)))
              (make-sets (car names-and-values)
                         (cadr names-and-values) '())
              (cddr expr))))


  (define test '(letrec ((even?
                          (lambda (n)
                            (if (= n 0)
                                true
                                (odd? (- n 1)))))
                         (odd?
                          (lambda (n)
                            (if (= n 0)
                                false
                                (even? (- n 1))))))
                  '()))

  (letrec->let test)
#+END_SRC

Задание б:
Проблема в окружениях, которые создают ~let~ и ~define~. Если мы везде
используем ~let~,то все операции, которые выполняются с переменными,
объявленными через let, должны выполняться внутри тела самого ~let~. Если
мы определяем пременную через ~define~, то можем ссылаться на нее и за
пределами ее окружения - если define раскрывается в именованную лямбду.

Теперь рассмотрим наш случай: если let реализован как обычно, не как в
упр. 4.18, то связывание происходит последовательно, а не одновременно,
как в ~letrec~,поэтому в ~let~ не получится реализовать взаимную
рекурсию.

~Упражнение 4.21.~
Как ни удивительно, интуитивная догадка Хьюго (в упражнении 4.20)
оказывается верной. Действительно, можно строить рекурсивные процедуры
без использования ~letrec~ (и даже без define), только способ это сделать
намного тоньше, чем казалось Хьюго.
Следующее выражение вычисляет факториал 10 с помощью рекурсивной процедуры:

#+BEGIN_SRC scheme
  ((lambda (n)
     ((lambda (fact)
        (fact fact n))
      (lambda (ft k)
        (if (= k 1)
            1
            (* k (ft ft (- k 1)))))))
   10)
#+END_SRC

Задание а.
Проверьте, что это выражение на самом деле считает факториалы
(вычисляя его). Постройте аналогичное выражение для вычисления чисел
Фибоначчи.
Итак, выражение действительно вычисляет факториал. Вариант для Фибоначчи:

#+BEGIN_SRC scheme
  ;;исходный вариант
  (define (fib n)
    (define (fib-iter a b count )
      (if (= count 0)
          b
          (fib-iter (+ a b) a (- count 1))))
    (fib-iter 1 0 n))

  ;; переработанный
  ((lambda (n a b)
     ((lambda (fib-iter)
        (fib-iter fib-iter a b n))
      (lambda (fib-it a b count)
        (if (= count 0)
            b
            (fib-it fib-it (+ a b) a (- count 1)))))
     )
   4 1 0 )
#+END_SRC

Задаие б:
Рассмотрим следующую процедуру, включающую взаимно рекурсивные внутренние
определения:

#+BEGIN_SRC scheme
  (define (f x)
    (define (even? n)
      (if (= n 0)
          true
          (odd? (- n 1))))
    (define (odd? n)
      (if (= n 0)
          false
          (even? (- n 1))))
    (even? x))
#+END_SRC

Восстановите пропуски в выражениях:

#+BEGIN_SRC scheme
  (define (f x)
    ((lambda (even? odd?)
       (even? even? odd? x))
     (lambda (ev? od? n)
       (if (= n 0) true (od? ev? od? (- n 1))))
     (lambda (ev? od? n)
       (if (= n 0) false (ev? ev? od? (- n 1))))))

#+END_SRC

~Упражнение 4.22.~
Расширьте интерпретатор из этого раздела так, чтобы он поддерживал
let. (См. упражнение 4.6.)

Упражнение 4.6 гласит:
выражения let производны, поскольку раскрываются в лямбду.
Напишите синтаксическое преобразование ~let->combination~, которое сводит
вычисление let-выражений к вычислению комбинаций указанного вида, и добавьте
соответствующую ветку для обработки let к eval.

Значит, сейчас нам надо сейчас вставить уже имеющееся преобразование ~let~
в новый интерпретатор.
Реализация преобразования let из упражнение 4.6:

#+BEGIN_SRC scheme
  (define (make-lambda parameters body)
    (cons 'lambda (cons parameters body)))

  (define (let? exp)
    (tagged-list? exp 'let))

  (define (let->combination exp)
    (define (get-all-params exp)
      (if (null? exp)
          '()
          (cons (caar exp) (get-all-params (cdr exp)))))
    (define (get-all-exps exp)
      (if (null? exp)
          '()
          (cons (cadar exp) (get-all-exps (cdr exp)))))
    (append (list (make-lambda (get-all-params (cadr exp))
                               (cddr exp)))
            (get-all-exps (cadr exp))))

  (let ((a 1)
        (b 2))
    (+ a b))
#+END_SRC
Добавление его в интерпретатор:

#+BEGIN_SRC scheme
  (define (eval exp env)
    ((analyze exp) env))

  (define (analyze exp)
  (cond ((self-evaluating? exp)
         (analyze-self-evaluating exp))
        ((quoted? exp) (analyze-quoted exp))
        ((variable? exp) (analyze-variable exp))
        ((assignment? exp) (analyze-assignment exp))
        ((definition? exp) (analyze-definition exp))
        ((if? exp) (analyze-if exp))
        ((let? exp) (analyze (let->combination exp)))
        ((lambda? exp) (analyze-lambda exp))
        ((begin? exp) (analyze-sequence (begin-actions exp)))
        ((cond? exp) (analyze (cond->if exp)))
        ((application? exp) (analyze-application exp))
        (else
         (error "Неизвестный тип выражения -- ANALYZE" exp))))
#+END_SRC

~Упражнение 4.23~.
Лиза П. Хакер не понимает, зачем делать ~analyze-sequence~ такой
сложной. Все остальные процедуры анализа — простые трансформации
соответствующих вычисляющих процедур (или ветвей eval) из раздела 4.1.1.
Лиза ожидала, что ~analyze-sequence~ будет выглядеть так:

#+BEGIN_SRC scheme
  (define (analyze-sequence exps)
    (define (execute-sequence procs env)
      (cond ((null? (cdr procs)) ((car procs) env))
            (else ((car procs) env)
                  (execute-sequence (cdr procs) env))))
    (let ((procs (map analyze exps)))
      (if (null? procs)
          (error "Пустая последовательность -- ANALYZE"))
      (lambda (env) (execute-sequence procs env))))
#+END_SRC

Ева Лу Атор объясняет Лизе, что версия в тексте проделывает больше работы
по вычислению последовательности во время анализа. В Лизиной исполнительной процедуре
вызовы частичных исполнительных процедур, вместо того, чтобы быть встроенными,
перебираются в цикле. В результате, хотя отдельные выражения в
последовательности оказываются проанализированы, сама последовательность
анализируется во время выполнения.
Сравните две версии ~analyze-sequence~. Рассмотрите, например, обычный
случай (типичный для тел процедур), когда в последовательности только одно
выражение. Какую работу будет делать исполнительная процедура,
предложенная Лизой?
А процедура из текста раздела? Как соотносятся эти две процедуры в случае
последовательности из двух выражений?

Исходный вид ~analyze-sequence~:
#+BEGIN_SRC scheme
  ;;анализирует блоки выражений типа begin или тела процедуры
  (define (analyze-sequence exps)
    (define (sequentially proc1 proc2)
      (lambda (env) (proc1 env) (proc2 env)))
    (define (loop first-proc rest-procs)
      (if (null? rest-procs)
          first-proc
          (loop (sequentially first-proc (car rest-procs))
                (cdr rest-procs))))
    ;; получаем все исполнительные проедуры для выражения
    (let ((procs (map analyze exps)))
      (if (null? procs)
          (error "Пустая последовательность -- ANALYZE"))
      (loop (car procs) (cdr procs))))
#+END_SRC

Исходный вариант ~analyze-sequence~ сначала применит ~analyse~ к
выражению (выражениям), таким образом мы получим исполнительную процедуру
выражения. Затем вызовется ~loop~, и поскольку процедура одна, мы сразу
ее вернем. Если ~analyze-sequence~ на вход получит 2 выражения, то мы все
так же их проанализируем, затем ~loop~ соберет их в общую исполнительную
процедуру и так вернет.
Теперь посмотрим на Лизин вариант.
Мы возвращаем лямбду, внутри которой вызов ~execute-sequence~. Таким
образом у нас преобразование не закончено:
только при вызове этой лямбды мы начнем анализировать выражения дальше. К
тому же это еще и каждый раз делать придется.

~Упражнение 4.25.~
Предположим, что мы (в обычной Scheme с аппликативным порядком
вычислений) определяем ~unless~ как показано выше, а затем определяем
~factorial~ через ~unless~:

#+BEGIN_SRC scheme
  (define (unless condition usual-value exceptional-value)
    (if condition exceptional-value usual-value))

  (define (factorial n)
    (unless (= n 1)
            (* n (factorial (- n 1)))
            1))
#+END_SRC

Что произойдет, если мы попытаемся вычислить (factorial 5)? Будут ли наши
определения работать в языке с нормальным порядком вычислений?

Итак, в апликативном порядке вычислений аргументы процедуры вычисляются
до ее использования. Это значит, что все аргументы ~unless~ будут
вычислены до ее вызова, в том числе и  ~(* n (factorial (- n 1)))~,
попытавшись вычислить эото аргумент ~unless~, мы входим в бесконечную
рекурсию. Почему? Пока ~unless~ не вычислит все свои аргументы, она не
запуститcя, а до вычисления своего третьего аргумента она дойти никак не
может: вычисляя второй аргумент мы "проваливаемся" в вызов факториала,
затем снова пытаемся вычислить аргументы ~unless~ и так до тех пор, пока
стек не кончится.

В нормальном порядке вычислений этого не произошло бы, поскольку там
аргументы вычисляются только по требованию, когда они нужны. ~unless~
спокойно бы запустилась, мы бы проверили условие и в зависимости от того,
как оно сработало, мы бы вычислили остальные аргументы. Бесконечной
рекурссии бы не было.

~Упражнение 4.26.~
Бен Битобор и Лиза П. Хакер расходятся во мнениях о важности ленивых
вычислений для реализации конструкций вроде ~unless~.  Бен указывает, что
при аппликативном порядке ~unless~ можно реализовать как особую форму.
Лиза отвечает, что в таком случае ~unless~ будет просто синтаксисом, а не
процедурой, которую можно использовать в сочетании с процедурами высших
порядков. Проясните детали в обеих позициях. Покажите, как реализовать
~unless~ в виде производного выражения (вроде cond или let), и приведите
пример ситуации, когда имеет смысл, чтобы ~unless~ была процедурой,
а не особой формой.

Трансформация ~unless~ в соответствующее ему условное выражение.
#+BEGIN_SRC scheme
  (define (unless->if exp)
    (let ((condition (cadr exp))
          (usual-value (caddr exp))
          (exceptional-value (cadddr exp)))
      (list 'if condition exceptional-value usual-value)))


  (unless->if '(unless (= n 1)
                      (* n (factorial (- n 1)))
                      1))
#+END_SRC

Если использовать ~unless~ как особую форму при аппликативном порядке,
как предлагает Бен, то все будет работать правильно, поскольку в ифе
будут вычисляться только те ветки, которые будут соответствовать условию,
а не все подряд. С другой стороны, ~unless~  просто станет синтаксическим
сахаром для ифа.

Может возникнуть ситуация, когда нам не нужно будет вычислять аргументы
~unless~, то есть ~unless~ должна стать нестрогой процедурой по своим
аргументам. Например, если ~unless~ понадобится для работы над
структурами данных, хотя я не очень представляю, зачем нам может быть
нужна ~unless~ в этом случае.

~Упражнение 4.27.~
Допустим, мы вводим в ленивый интерпретатор следующее выражение:

#+BEGIN_SRC scheme
  (define count 0)

  (define (id x)
    (set! count (+ count 1))
    x)
#+END_SRC

Вставьте пропущенные значения в данной ниже последовательности действий и
объясните свои ответы:

#+BEGIN_SRC scheme
  (define w (id (id 10)))

  ;;; Ввод L-Eval:
  count
  ;;; Значение L-Eval:
  <вывод>
  ;;; Ввод L-Eval:
  w
  ;;; Значение L-Eval:
  <вывод>
  ;;; Ввод L-Eval:
  count
  ;;; Значение L-Eval:
  <вывод>

#+END_SRC

Рассмотрим, что произойдет при вводе ~(define w (id (id 10)))~.
Вызов  ~(id 10)~, переданный как аргумент, вычислен не будет, станет
санком. Так что при вызове ~id~ с таким аргументом, мы его же и вернем,
не вычисляя.

Так что:
#+BEGIN_SRC scheme
  (define w (id (id 10)))

  ;;Ввод:
  count
  ;; Вывод, поскольку санк вычислен не будет, присовение count стработает только 1 раз
  1

  ;; Ввод:
  w
  ;; Вывод, поскольку при вызове w санк, который она собой представляет, вычислится
  10

  ;;; Ввод:
  count
  ;; Вывод, поскольку раз вычислился и санк, то присваивание внутри id сработало второй раз.
  2

#+END_SRC

~Упражнение 4.28.~
~Eval~, передавая оператор в ~apply~, вычисляет его не при помощи ~eval~, а
через ~actual-value~, чтобы вынудить. Приведите пример, который показывает, что такое
вынуждение необходимо.

Оператор мы вычисляем сразу, чтоб понять, составная это процедура или
примитив. При этом нигде не сказано, что оператор не может быть санком. А
попытка применить аргументы к невычисленному санку обернется ошибкой.

Эта ситуация может возникнуть, есть оператор - это евычесленный аргумент
какой-то процедуры, который аон вернула.

Например:
#+BEGIN_SRC scheme
  (cons (lambda (x)
          (* x x))
        (lambda (y)
          (+ y y )) ......)
#+END_SRC

Если cons у нас нестрогая и интерпретатор у нас ленивый, то cons вообще не
нужно вычислять свои аргументы, чтоб составить из них список. Тем более,
что с точки зрения интерпретатора любое выражение - это список. То есть
для cons вообще нет никакой разницы, что представляет собой список на
самом деле: вызов процедуры, список чисел и т.д.

Теперь представляем себе, что полученный список процедур мы будем
применять к разным аргументам. А по факту у нас не список процедур, а
список санков и вычисление санка нужно вынудить. А еще при вычислении
санка мы можем получить новый санк, так что нужно будет вынудить все
санки до того, как мы получим оператор, который можно применить к
аргументам.

~Упражнение 4.29~.
Придумайте пример программы, которая, по Вашему мнению, будет работать
намного медленнее без мемоизации, чем с мемоизацией.

Рассмотрим, помимо
этого, следующую последовательность действий, в которой процедура ~id~
определена как в упражнении 4.27, а счетчик ~count~ начинает с 0.
Укажите, как будет выглядеть вывод в случае с мемоизирующим
интерпретатором и с немемоизирующим.

#+BEGIN_SRC scheme
  ;;меморизирующий
  (define (square x)
    (* x x))

  ;; Ввод L-Eval:
  (square (id 10))
  ;;; Значение L-Eval:
  100
  ;;; Ввод L-Eval:
  count
  ;;; Значение L-Eval:
  1 ;; потому что санк вычисляет один раз, соответственно, присваивание срабатывает 1 раз

#+END_SRC

При немеморизирующих санках вычисление ~(id 10)~, переданного как
аргумент ~square~, произойдет дважды, поэтому ~count~ будет = 2.

А вообще меморизация окажется дико полезна в циклах, где мы вычисляем
одно и то же с незначительными вариациями. К примеру:

#+BEGIN_SRC scheme
  (define (square x)
    (* x x))

  (define (test n arg)
    (if (< n 0)
        'ok
        (begin
        (display (square arg))
        (newline)
        (test (- n 1) arg))))

  (test 10 (id 10))
#+END_SRC

Без меморизации ~(id 10)~ будет вычислено 20 раз вместо одного. И это у
цикла только 10 итераций и процедура ~id~ сравнительно простая.

~Упражнение 4.30~
Пабло Э. Фект, бывший программист на языке C, беспокоится, что ленивый
интерпретатор не вынуждает выражения в последовательности, и оттого некоторые побочные
эффекты могут никогда не произойти. Поскольку ни у одного выражения
в последовательности, помимо конечного, значение не используется
(выражение стоит там только ради своего эффекта, например, чтобы
присвоить значение переменной или что-нибудь напечатать), у значения
такого выражения не может впоследствии быть применения, для которого его потребуется
вынудить (например, в качестве аргумента элементарной процедуры). Поэтому
П.Э. Фект считает, что при выполнении последовательности нужно все
выражения, кроме последнего, вынуждать. Он предлагает изменить
~eval-sequence~ из раздела 4.1.1 так, чтобы она вместо eval использовала actual-value:

#+BEGIN_SRC scheme
  (define (eval-sequence exps env)
    (cond ((last-exp? exps) (eval (first-exp exps) env))
          (else (actual-value (first-exp exps) env)
                (eval-sequence (rest-exps exps) env))))
#+END_SRC

а. Бен Битобор считает, что Пабло неправ. Он показывает ему процедуру
for-each из упражнения 2.23 — важный пример последовательности с
побочными эффектами:

#+BEGIN_SRC scheme
  (define (for-each proc items)
    (if (null? items)
        'done
         (begin (proc (car items))
                (for-each proc (cdr items)))))
#+END_SRC
Он утверждает, что интерпретатор из текста (с исходным eval-sequence)
правильно работает с этой процедурой:

#+BEGIN_SRC scheme
  (for-each (lambda (x) (newline) (display x))
            (list 57 321 88))

#+END_SRC

Объясните, почему Бен прав насчет поведения for-each.
Итак, побочные эффекты - это любое измениене окружения, объекта или файла
из-за вызова процедуры. Например, присваивание глобальной переменной
какое-то значение внутри процедуры - это побочный эффект процедуры.

Исходный вид ~eval-sequaence~:
#+BEGIN_SRC scheme
  (define (eval-sequence exps env)
    (cond ((last-exp? exps) (eval (first-exp exps) env))
          (else (eval (first-exp exps) env)
                (eval-sequence (rest-exps exps) env))))
#+END_SRC

Бен прав, потому что ~display~ внутри лямбды является примитивной процедурой,
следовательно, ее аргументы будут вычислены до вызова. В ленивом
интерпретаторе примитивы - строгие процедуры.

б. Пабло соглашается с Беном по поводу примера с for-each, но говорит,
что, предлагая изменить eval-sequence, он имел в виду другой тип
программ. Он определяет в ленивом интерпретаторе следующие две процедуры:

#+BEGIN_SRC scheme
  (define (p1 x)
    (set! x (cons x '(2)))
    x)

  (define (p2 x)
    (define (p e)
      e
      x)
    (p (set! x (cons x '(2)))))
#+END_SRC

Какие значения вернут (p1 1) и (p2 1) с исходной eval-sequence? Каковы
будут значения с изменением, которое предлагает Пабло?

C исходной ~eval-sequence~:
~(p1 1)~ вернет (1 2)
~(p2 1)~ вернет 1. Процедура ~p~ принимает аргумент ~e~, мы ей в
качестве аргумента передаем выражение ~(set! x (cons x '(2)))~, которое
является санком, поскольку интерпретатор ленивый, и  вычисляется не
сразу, а только внутри процедуры ~p~, когда мы возвращаем ~e~. Только вот
~eval~ санки вычислять не умеет, соответственно, присваивание не
сработает И ЗНАЧЕНИЕ ~x~ останется прежним.

С версией Пабло:
~(p1 1)~ вернет (1 2)
~(p2 1)~ вернет (1 2).
Внутри ~eval-sequence~ верссии Пабло вызывается
~actual-value~, которая вызывает процедуру ~force-it~ - она вынуждает
санк. Соответственно присваивание будет вычислено.

в. в. Пабло указывает также, что изменение eval-sequence, которое он
предлагает, не влияет на поведение примера из части a. Объясните, почему
это так.

Потому что внутри лямбды у нас используются примитивы, следовательно, их
аргументы в любом случае были бы вычислены. Теперь мы просто вычисляем
их, потому что они санки, а не потому что они аргументы примитивов.

г. Как, по-Вашему, нужно работать с последовательностями в ленивом
интерпретаторе? Что Вам нравится больше: подход Пабло, подход,
приведенный в тексте, или что-нибудь третье?

Подход пабло хорош, потому что используя ленивый интерпретатор, мы будем
постоянно натыкаться на санки и в последовательностях тоже, так что их
нужно вынуждать, чтоб они вычислились.

~Упражнение 4.31. разобраться~
Подход, принятый в этом разделе, нехорош тем, что вносит изменение в
Scheme, не сохраняя ее семантику. Было бы приятнее реализовать ленивые вычисления как
совместимое расширение (upward-compatible extension), то есть так, чтобы
обычные программы на Scheme работали как прежде.
Например, определение

#+BEGIN_SRC scheme
  (define (f a (b lazy) c (d lazy-memo))
    ...)
#+END_SRC

делало бы f процедурой от четырех аргументов, причем первый и третий
вычисляются при вызове процедуры, второй задерживается, а четвертый
задерживается и мемоизируется.
Таким образом, обыкновенные определения процедур будут задавать такое же
поведение, как в обычной Scheme, а добавление декларации ~lazy-memo~ к
каждому параметру каждой составной процедуры приведет к поведению, как у
ленивого интерпретатора, описанного в этом разделе. Разработайте и реализуйте
изменения, с помощью которых можно получить такое расширение Scheme. Вам
придется реализовать новые синтаксические процедуры для нового синтаксиса
~define~.
Кроме того, надо будет добиться, чтобы eval и apply определяли,
когда надо задерживать аргументы, и соответствующим образом задерживали и
вынуждали их. Наконец, придется обеспечить,чтобы вынуждение было с
мемоизацией или без оной, смотря по обстоятельствам.

Итак, если раньше мы отдельано реализовывали аппликативный порядок
вычислений и отдельно нормальный, то теперь нас просят реализовать
гибрид.

Главный финт - это вычислить сразу все аргументы, кроме тех, что
отложены. А те, что отложены, вычислить только перед их непосредственным
применением.
Значит, мы вычислим с помощью ~eval~ все, что не задержано и передадим
процедуру с аргументами, среди которых могут оказаться санки, в
~apply~. А apply перед применением процедуры к аргументам должна пройтись
по аргументам и вынудить те, что являются санками и только после этого
исполнить процедуру.

К тому же, у нас санки могут быть меморизированные, а могут быть и нет.
Процедура вынуждения для не меморизированного санка:

#+BEGIN_SRC scheme
  (define (force-it-not-memo obj)
    (if (thunk? obj)
        (actual-value (thunk-exp obj) (thunk-env obj))
        obj))
#+END_SRC

Механизм вынуждения санка с меморизацией:

#+BEGIN_SRC scheme
  (define (evaluated-thunk? obj)
    (tagged-list? obj 'evaluated-thunk))

  (define (thunk-value evaluated-thunk) (cadr evaluated-thunk))

  (define (force-it-memo obj)
    (cond ((thunk? obj)
           (let ((result (actual-value
                          (thunk-exp obj)
                          (thunk-env obj))))
             (set-car! obj 'evaluated-thunk)
             (set-car! (cdr obj) result)
                                          ; заменить exp на его значение
             (set-cdr! (cdr obj) '()) ; забыть ненужное env
             result))
          ((evaluated-thunk? obj)
           (thunk-value obj))
          (else obj)))
#+END_SRC

В мане обе процедуры вынуждения имеют название force-it, но поскольку
нужны нам обе, то воизбежание переопределения назовем их по-разному и
будем вызывать каждую в зависимости от ситуации.

Создадим предикаты и процедуры, который будут превращать аргументы в
санки того или иногт вида.

#+BEGIN_SRC scheme
  (define (tagged-list? exp tag)
    (if (pair? exp)
        (eq? (car exp) tag)
        false))

  ;; создает санк с меморизацией или без, в зависимости от аргумта tag
  (define (delay-it exp env tag)
    (list tag exp env))

  ;;проверяет, является ли санк меморизированным
  (define (memo-thunk? obj)
    (tagged-list? obj 'lazy-memo))

  ;; проверяет, является ли санк не меморизированным
  (define (not-memo-thunk? obj)
    (tagged-list? obj 'lazy))

  ;; задерживает аргумент, если пользователь хочет его задержать и возвращает как есть,
  ;; если пользователь задерживать аргумент не планирует
  (define (delay-arg? arg env)
    (cond ((not (pair? arg))
           arg)
           ((memo-thunk? (last-pair arg))
            (delay-it exp env 'lazy-memo))
           ((not-memo-thunk? (last-pair arg))
            (delay-it exp env 'lazy))
          (else arg)))

  ;; тесты
  (delay-arg? '((lambda (x)
                  (+ x x)) lazy) '(some-env))

  (delay-arg? '(lambda (x)
                 (+ x x)) '(some-env))

  (delay-arg? 1 '(some-env))
#+END_SRC

~delay-arg~ устроена таким образом, что если последняя пара переданного
аргумента - это символ lazt или lazy-memo, мы считаем, что пользователь
хочет задержать данный аргумент. В остальном случае мы возвращаем
аргумент в том виде, в котором его получили.

Данная процедура не рассматривает 2 аспекта:
- символами lazy и lazy-memo могут быть названы переменные (ну,
  вдруг). Надо бы проверять окружение на наличие этих символов, чтоб
  обедиться, что игде нет таких переменных, и если есть, выдывать
  ошибку.
- мы не учитываем, что пользователь может передать какой-то другой тэг
  для аргумента или написать опечататься.

Но поскольку у нас примитивная модель интерпретатора думаю, эти проблемы
можно опустить, и представить, что наши юзеры всегда точно знают, что
делают.

Теперь нам нужно встроить механизм упаковки аргументов в санки (если
этого хочет пользователь) в ~eval~.

Для этого мы изменим процедуру ~list-of-values~, которая собирает все
аргументы вызова процедуры в список перед тем, как будет вызван
apply. Мы не просто объединим все аргументы в список, а проверим, не
хочет ли пользователь задержать какие-то из них. И если да, то мы сначала
упакуем данные аргументы санки и только потом вклчим их в общий список
аргументов.

Пишем определение дефайна.
eval получает на вход определение. Срабатывает ветка ~definition?~ в
cond, вызывается ~eval-definition~ , которая должна вычислить определение:

#+BEGIN_SRC scheme
  (define (eval-definition exp env)
    (define-variable! (definition-variable exp)
      (eval (definition-value exp) env)
      env)
    'ok)
#+END_SRC

Мы берем имя. полученное из переданного выражения, и вычисляем значение
выражения и упаковываем все это вместе с окружением в новую
переменную. Если мы определяем процедуру,то имени присваивается лямбда с
указанными в определении аргументами.

#+BEGIN_SRC scheme
  (define (definition-value exp)
    (if (symbol? (cadr exp))
        (caddr exp)
        (make-lambda (cdadr exp)
                     (cddr exp))))
#+END_SRC

То есть определение раскроется так:

#+BEGIN_SRC scheme
  (define (f a (b lazy) c (d lazy-memo))
    ...)

  (define f
    (lambda (a (b lazy) c (d lazy-memo))
      <тело>))


  (define (f a (b lazy) c (d lazy-memo))
    ...)

  (define f
    (lambda (a b  c d))
      <тело>))
#+END_SRC

 Теперь надо понять, устраивает нас такое раскрытие или нет. По идее,
 должно быть как-то так:

#+BEGIN_SRC scheme
  (define (f a (b lazy) c (d lazy-memo))
    ...)

  (define f
    (lambda (a b c d))
      <тело>)

  ;; не сработает, потому что b и d сначала вычислятся, только потом вызовется лямбда,
  ;; и только после этого они станут санками. А если один из них бесконечный поток данных?
  ;; зациклимся до конца стека
  (define f
    (lambda (a b c d))
    (b lazy)
    (d lazy-memo)
    <тело>)

#+END_SRC

И при этом где-то надо хранить информацию, что перед вызовом лямбды
аргументы b и dнадо задержать указанными способами и передать в лямбду уже санками.



#+BEGIN_SRC scheme
  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((if? exp) (eval-if exp env))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((application? exp)
           (apply (eval (operator exp) env)
                  (list-of-values (operands exp) env)))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))

  (define (apply procedure arguments)
    (cond ((primitive-procedure? procedure)
           (apply-primitive-procedure procedure arguments))
          ((compound-procedure? procedure)
           (eval-sequence
            (procedure-body procedure)
            (extend-environment
             (procedure-parameters procedure)
             arguments
             (procedure-environment procedure))))
          (else
           (error
            "Неизвестный тип процедуры -- APPLY" procedure))))
#+END_SRC

Разберемся с изначальным синтаксисом ~define~. Он у нас различный, в зависимости от
того, объявляем мы процедуру или переменную.
Синтаксис для объявления переменной:
Обяъвление представляет собой список, который наинчается с define. Затем
идет символ, обозначающий имя переменной, затем выраение или число,
значение которых станет значеним переменной.
Синтексис для процедуры:
Тоже список, начинается с define. Затем идет подсписок, где первый
символ - имя процедуры, а остальные элементы - аргументы. Следующий
подсписок - это тело объявляемой процедуры.

Значит, мы модем определить, что если за символом define следует список -
мы объявляем процедуру. А иначе - переменную. В обоих случаях нам надо
будет определить,

~Упражнение 4.32.~
Приведите несколько примеров, которые показывают разницу между потоками
из главы 3.5.4 и «более ленивыми» списками, описанными в этом разделе. Как можно
воспользоваться этой дополнительной ленивостью?

Итак, у ранее описанных ленивых потоков задерживался только ~cdr~. Теперь
у них задерживает и ~car~, и ~cdr~, более того, то, что мы "вынудим"
какой-то элемент потока, совершенно не значит, что его значение
вычислится. Оно может быть обернуто в санк и будет вычисляться только
когда в нем возникнет прямая необходимость.

У нас было упражнение 3.80, в котором требовалось построить/симулировать
работу RLC-цепи. Так выглядело опрееление процедуры с потоками из главы
3:

#+BEGIN_SRC scheme
  (define (RLC R L C dt)
    (lambda (vC0 iL0)
      (define Li (integral (delay diL) iL0 dt))
      (define vC (integral (delay dvC) vC0 dt))
      (define dvC (scale-stream Li (exact->inexact (/ -1 C))))
      (define diL (add-streams (scale-stream Li (exact->inexact (/  (/ R -1) L)))
                               (scale-stream vC (exact->inexact (/ 1 L)))))
      (cons Li vC)
      ))
#+END_SRC

 А вот так будет выглядеть сейчас:

#+BEGIN_SRC scheme
  (define (RLC R L C dt)
    (lambda (vC0 iL0)
      (define Li (integral diL iL0 dt))
      (define vC (integral dvC vC0 dt))
      (define dvC (scale-stream Li (exact->inexact (/ -1 C))))
      (define diL (add-streams (scale-stream Li (exact->inexact (/  (/ R -1) L)))
                               (scale-stream vC (exact->inexact (/ 1 L)))))
      (cons Li vC)
      ))
#+END_SRC

Похожие изменения будут в упражнении 3.79.

Ранее нам было показано, что деление на процедуры и данные может быть
достаточно условным, и что процедуры можно представлять как
данные. Предположим, что у нас поток состоит из вызовов процедур. Внутри
этих процедур у нас динамически выделяется память, а так же предположим,
что они обладают побочными эффектами, например, меняют окружение из-за
присваивания. Если мы пользуемся потоками, показаными в главе три, то при
вычислении ~car~ потока мы уже не можем отсрочить выполнение вызова
процедуры, хотя, предположим, нам нужно само выражение, а не результат
его вызова. Тогда придется его дополнительно задерживать или же оформлять
вызовы процедур в виде заковчнных списков.

~Упражнение 4.33.~
Бен Битобор проверяет вышеописанную реализацию при помощи выражения
~(car '(a b c))~

К его большому удивлению, в ответ выдается ошибка. После некоторого
размышления он понимает, что «списки». которые получаются при чтении
кавычек, отличаются от списков, управляемых новыми определениями cons,
car и cdr.
Измените работу интерпретатора с закавыченными выражениями так, чтобы при
вводе списковых выражений в цикле управления получались настоящие
ленивые списки.

Новые определения cons, car и cdr:
#+BEGIN_SRC scheme
  (define (cons x y)
    (lambda (m) (m x y)))

  (define (car z)
    (z (lambda (p q) p)))

  ;;((lambda (m) (m x y)) (lambda (p q) p))

  (define (cdr z)
    (z (lambda (p q) q)))

  ;; эксперимент
  (define f (cons 1 2))
  (car f)
  (cdr f)

  (define (list-ref items n)
    (if (= n 0)
        (car items)
        (list-ref (cdr items) (- n 1))))

  (define (map proc items)
    (if (null? items)
        '()
         (cons (proc (car items))
               (map proc (cdr items)))))

  (define (scale-list items factor)
    (map (lambda (x) (* x factor))
         items))

  (define (add-lists list1 list2)
    (cond ((null? list1) list2)
          ((null? list2) list1)
          (else (cons (+ (car list1) (car list2))
                      (add-lists (cdr list1) (cdr list2))))))

  (define ones (cons 1 ones))

  (define integers (cons 1 (add-lists ones integers)))
#+END_SRC

Итак, проблема у Бена возникает потому, что новая версия cons возвращает
не список: она возвращает лямбду, которая принимает процедуру ~m~. И вот
уже в зависимости от процедуры мы увидим тот или иной результат. Поэтому
новый ~car~ на месте заковыченного списка ожидает увидеть на самом деле
лямбду, соответственно, все ломается.

Итак, при встрече заковыченного выражения в ~eval~ срабатывает ветка
~quoted?~ и вызывается вот эта процедура:

#+BEGIN_SRC scheme
  (define (text-of-quotation exp) (cadr exp))
#+END_SRC

Как мы видим, она просто возвращает выражение без ковычки. А нам нужно,
чтоб вызывался новый cons, да еще и неоднократно, если в выражении больше
двух элементов.

Немножно изменим eval так, чтоб при вызове text-of-quatation  в нее
передавалось и окружение. Это нужно, чтоб обратиться к eval если
переданное закавыченное выражение состоит из подпар (ну, вдруг).

Сначала мы составляем выражение, которое представляет собой вызов
вложенных друг в друга cons и только затем вычисляем его.

Есть очень важное дополнение: мы переопределили car, cons и cdr внутри
ленивого интерпретатора, т.е. внутри driver-loop. То есть в встроенном,
изначальном интерпретаторе у нас cons, car и cdr
стандартные. Соответственно, мы можем их использовать, чтоб проходиться
по списку, пока мы строим выражение, которое, будучи пропущенное через
eval и apply внутри ленивого интерпретатора, построит новое представление
списка. То есть у нас параллельно в двух интерпретаторах существуют два
разных представления cons, car и cdr и не пересекаются они потому, что у
каждого интерпретатора свое базовое окружение.

#+BEGIN_SRC scheme
  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp env))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((if? exp) (eval-if exp env))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((application? exp)
           (apply (actual-value (operator exp) env)
                  (operands exp)
                  env))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))

  (define (text-of-quotation exp env)
    (let ((result (cadr exp)))
      (if (pair? result)
          (eval (make-lst result) env)
          result)))

  (define (make-lst s)
    (if (null? s)
        '()
        (list 'cons
              (list 'quote (car s))
                          (make-lst (cdr s)))))
#+END_SRC

~Упражнение 4.34.~
Измените управляющий цикл интерпретатора так, чтобы ленивые пары и списки
печатались каким-либо разумным образом. (Как Вы собираетесь работать с бесконечными
списками)? Вероятно, понадобится также изменить представление ленивых
пар, чтобы при печати интерпретатор их распознавал и печатал особым образом.

Итак, нам нужно научить цикл печатать ленивые пары (пары, в которых cdr -
промис), списки (которые сейчас фактически являются вложенными лямбдами)
и бесконечные списки.

Основная проблема состоит в том, что с точки зрения driver-loop список -
это такая же процедура (лямбда), как и другие процедуры. Соответственно,
надо как-то указать, что вот эта процедура на самом деле список, а вот
эта - не список.


В мане нам сказано, что благодаря ленивому вычислению списки и
потоки-данных, которые мы проходили в главе 3, теперь одно и то же. И
благодаря переопределенным cons, car и cdr мы можем больше не делать
между ними разницы. Соответственно, любая пара теперь ленивая, поскольку
мы не вычисляем ее car и cdr до тех пор, пока они не понадобятся и любой
список у нас потенциально бесконечный, поскольку пока мы не вычислим cdr,
мы не узнаем, что в нем.

Основная проблема состоит в том, что с точки зрения driver-loop список -
это такая же процедура (лямбда), как и другие процедуры. Соответственно,
мы изменим представление пары. Данные функции надо вгрузить в стандартный
интерпретатор (если вгрузить внутри драфвер лупа, то list не
распознается), заnем обновить окружение ленивого интерпретатора.

#+BEGIN_SRC scheme
  (define (new-cons x y)
    (cons 'pair (lambda (m) (m x y))))

  (define (new-car z)
    ((cadr z) (lambda (p q) p)))

  (define (new-cdr z)
    ((cadr z) (lambda (p q) q)))

  (define (new-pair? exp)
    (tagged-list? exp 'pair))

  (define primitive-procedures
    (list (list 'cons cons)
          (list 'car new-car)
          (list 'cdr new-cdr)
          (list 'pair? new-pair?)
          (list 'null? null?)
          (list '= =)
          (list '/ /)
          (list '* *)
          (list 'display display)
          (list '+ +)
          (list '- -)
          ))

  (define the-global-environment (setup-environment))
#+END_SRC


#+BEGIN_SRC scheme
  (define (user-print object)
    (cond ((pair? object)
           (let ((pair (cadr object)))
           (display (list 'pair
                          (list (new-car pair))
                          '<promise>))))
          ((compound-procedure? object)
           (display (list 'compound-procedure
                          (procedure-parameters object)
                          (procedure-body object)
                          '<procedure-env>)))
          (else (display object))))


#+END_SRC

Не понимаю, почему не работает.

~Упражнение 4.35.~
Напишите процедуру ~an-integer-between~, которая возвращает целое число,
лежащее между двумя заданными границами. С ее помощью можно следующим образом
реализовать процедуру для поиска Пифагоровых троек, то есть троек чисел
(i, j, k) между заданными границами, таких, что i ≤ j и i^2 + j^2 = k^2 :

#+BEGIN_SRC scheme
  (define (a-pythagorean-triple-between low high)
    (let ((i (an-integer-between low high)))
      (let ((j (an-integer-between i high)))
        (let ((k (an-integer-between j high)))
          (require (= (+ (* i i) (* j j)) (* k k)))
          (list i j k)))))
#+END_SRC

Итак, новый интерпретатор (который нам пока не показали)
реализует поиск в глубину следующим образом:
при возможных вариантах выбора мы всегда выбираем самый первый вариант.
Если этот выбор приводит к неудаче, мы возвращаемся к точке
выбора  и выбираем второй вариант и т.д., пока либо мы не исчерпаем
варианты, либо не вернем какое-то выражение. Надо учитывать, что один
выбор может приводить к другим точкам выбора.

Пока что мы знаем о процедуре ~amb~ 2 вещи:
1. она инициирует поиск выборов в глубину, описанный выше
2. принимает 2 параметра: первый выбор и остальные.

Так что мы будем создавать всех возможных начений от нижней до верхней
границы, нижнюю границу будем передавать как первый выбор, а cdr
полученного списка значений как остальные возможные выборы.

#+BEGIN_SRC scheme
  (define (an-integer-between min max)
    (define (make-integers min max)
      (if (> min max)
          '()
          (cons min (make-integers (+ min 1) max))))
    (let ((integers (make-integers min max)))
      (amb (car integers) (cdr integers))))
#+END_SRC


~Упражнение 4.36.~
В упражнении 3.69 рассматривалась задача порождения потока всех
Пифагоровых троек, без всякой верхней границы диапазона целых чисел, в котором надо
искать. Объясните, почему простая замена ~an-integer-between~ на
~an-integer-starting-from~ в процедуре из упражнения 4.35
не является адекватным способом порождения произвольных Пифагоровых
троек.
Напишите процедуру, которая решает эту задачу. (Это значит, что Вам нужно написать
процедуру, для которой многократный запрос try-again в принципе способен
породить все Пифагоровы тройки.)

Отсутствие верхней границы означает, что нам нужны бесконечные потоки
чисел. То есть списки становятся потоками (не очень поняла, является ли
данный интерпретатор ленивым.. На всякий случай будем
считать, что нет)

В упражнении 3.69 мы создавали 3 бесконечных потока и перемешивали их таким образом,
чтоб тройки выходили "случайными": если бы мы пытались перемешать их
обычным способом, пытаясь поставить в пару каждым элементом первого
потока каждый элемент второго, то зависли бы навечно, поскольку первый
поток никогда не кончился бы. Здесь будет та же проблема, поскольку мы
будем двигаться по потокам "параллельно", поскольку всегда рассматриваем
все первые варианты как верные, затем вторые и т.д.
Так что нам надо не только породить 3 потока чисел, но и перемешать их между
собой. И вот уже оттуда выбирать чила.

#+BEGIN_SRC scheme
  ;; функция для перемешивания потоков
  (define (interleave s1 s2)
    (if (stream-null? s1)
        s2
        (cons-stream (stream-car s1)
                     (interleave s2 (stream-cdr s1)))))

  (define ones (cons-stream 1 ones))

  (define (add-streams s1 s2)
    (stream-map + s1 s2))

  (define integers (cons-stream 1 (add-streams ones integers)))

  ;; перемешиваем 3 потока в один
  (define interleave-integers
    (interleave (stream-cdr integers)
                (interleave integers (stream-cdr integers))))

  ;; получаем число "рандомно"
  (define (an-integer)
    (amb (stream-car interleave-integers)
         (stream-cdr interleave-integers)))

  ;; вид собранной процедуры
  (define (a-pythagorean-triple-between)
    ;; получили 3 числа
    (let* ((i (an-integer))
           (j (an-integer))
           (k (an-integer)))
      ;; добавили новое условие, что i <= j
      (require (and (<= i j)
                    (= (+ (* i i) (* j j)) (* k k))))
      (list i j k)))
#+END_SRC

~Упражнение 4.37~.
Бен Битобор утверждает, что следующий метод порождения Пифагоровых троек
эффективнее, чем приведенный в упражнении 4.35. Прав ли он?
(Подсказка: найдите, сколько вариантов требуется рассмотреть.)

#+BEGIN_SRC scheme
  (define (a-pythagorean-triple-between low high)
    ;; получаем числов внутри диапазона
    (let ((i (an-integer-between low high))
          ;; получаем максимально большой возможный квадрат числа в данном диапазоне
          (hsq (* high high)))
      (let ((j (an-integer-between i high)))
        ;; получаем сумму квадратом i и j
        (let ((ksq (+ (* i i) (* j j))))
          (require (>= hsq ksq))
          (let ((k (sqrt ksq)))
            (require (integer? k))
            (list i j k))))))
#+END_SRC

Да, Бен однозначно прав. Мы знаем, что пифагоровы тройки - это тройки,
где: i ≤ j и i^2 + j^2 = k^2, ищем мы эти тройки в заданных границах.
Мы знаем, что максимальное значение k^2 - это верхняя граница диапазона в
квадрате. Соответственно, сразу установив ее, мы можем сразу отмести
варианты i и j, суммы квадратов которых больше верхней границы в
квадрате. Если это условие совпадает -   k мы не ищем среди всех
возможных вариантов, а определяем как квадрат суммы уже известных i и j.
Таким образом мы ведем поиск в глубину по двум элементам i и j, вместо
трех: i, j и k.

~Упражнение 4.38.~
Измените процедуру ~multiple-dwelling~, отказавшись от требования, что Смит
и Флетчер живут не на соседних этажах. Сколько решений имеется у
измененной загадки?

Текст загадки:
Бейкер, Купер, Флетчер, Миллер и Смит живут на разных этажах пятиэтаж-
ного дома. Бейкер живет не на верхнем этаже. Купер живет не на первом
этаже. Флетчер не живет ни на верхнем, ни на нижнем этаже. Миллер жи-
вет выше Купера. Смит живет не на соседнем с Флетчером этаже. Флетчер
живет не на соседнем с Купером этаже. Кто где живет?

#+BEGIN_SRC scheme
  (define (distinct? items)
    (cond ((null? items) true)
          ((null? (cdr items)) true)
          ((member (car items) (cdr items)) false)
          (else (distinct? (cdr items)))))

  (define (multiple-dwelling)
    (let ((baker (amb 1 2 3 4 5))
          (cooper (amb 1 2 3 4 5))
          (fletcher (amb 1 2 3 4 5))
          (miller (amb 1 2 3 4 5))
          (smith (amb 1 2 3 4 5)))
      (require
       (distinct? (list baker cooper fletcher miller smith)))
      (require (not (= baker 5)))
      (require (not (= cooper 1)))
      (require (not (= fletcher 5)))
      (require (not (= fletcher 1)))
      (require (> miller cooper))
      ;; (require (not (= (abs (- smith fletcher)) 1)))  - убрали условие
      (require (not (= (abs (- fletcher cooper)) 1)))
      (list (list 'baker baker)
            (list 'cooper cooper)
            (list 'fletcher fletcher)
            (list 'miller miller)
            (list 'smith smith))))

  ;; все возможные варианты:
  ((baker 1) (cooper 2) (fletcher 4) (miller 3) (smith 5))
  ((baker 1) (cooper 2) (fletcher 4) (miller 5) (smith 3))
  ((baker 1) (cooper 4) (fletcher 2) (miller 5) (smith 3))
  ((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1))
  ((baker 3) (cooper 4) (fletcher 2) (miller 5) (smith 1)))
#+END_SRC

~Упражнение 4.39.~
Влияет ли порядок ограничений в процедуре multiple-dwelling на ответ?
Влияет ли он на время, необходимое для поиска ответа? Если Вы считаете, что он имеет
значение, то покажите, как можно ускорить программу, переупорядочив
ограничения. Если Вы считаете, что порядок значения не имеет, объясните,
почему.

Я думаю, что порядок ограничений не меняет ответа задачи, поскольку нам
нужно проверить их все, поэтому если какое-то из ограничений мы не
соблюли, мы об этом узнаем.
Но да, я думаю, что порядок ограничений может влиять на скорость.
Мы знаем, что каждый раз в ситуации выбора будем выбирать первый
указанный вариант, надеясь, что он верный. Если он таковым не окажется,
мы вернемся в точку выбора и выберем следующий. Соответственно, имеет
смысл первыми выставить ограничения, которые сообщают нам, что первый
выбор - не верный. В данном случае это "флетчер не живет на первом
этаже" и "купер не живет на первом этаже". Встретив два эти ограничения
сразу, мы должны будем тут же вернуться в точку выбора. Таким образом
сэкономим время.
Затем я бы поставила ограничение "миллер живет выше купера" и "смит и
флетчер живут не на соседних этажах" и "флетчер и купер живут не на
соседних этажах" и только после этого "бейкер не живет на верхнем этаже",
"флетчер не живет на верхнем этаже", поскольку они наименее вероятные,
поскольку чтоб их достигнуть, надо перебрать все остальные.

Получилось бы так:
#+BEGIN_SRC scheme
  (define (multiple-dwelling)
    (let ((baker (amb 1 2 3 4 5))
          (cooper (amb 1 2 3 4 5))
          (fletcher (amb 1 2 3 4 5))
          (miller (amb 1 2 3 4 5))
          (smith (amb 1 2 3 4 5)))
      (require
       (distinct? (list baker cooper fletcher miller smith)))
      (require (not (= cooper 1)))
      (require (not (= fletcher 1)))
      (require (> miller cooper))
      (require (not (= (abs (- smith fletcher)) 1)))
      (require (not (= (abs (- fletcher cooper)) 1)))
      (require (not (= baker 5)))
      (require (not (= fletcher 5)))
      (list (list 'baker baker)
            (list 'cooper cooper)
            (list 'fletcher fletcher)
            (list 'miller miller)
            (list 'smith smith))))
#+END_SRC

~Упражнение 4.40.~
Сколько возможных соответствий между людьми и этажами имеется в задаче о
проживании, если учитывать требование, что все живут на разных этажах, и если его не
учитывать? Крайне неэффективно порождать все возможные соответствия между
людьми и этажами, а затем полагаться на то, что поиск с возвратом отсечет
лишнее.
Например, большая часть ограничений зависит только от одной или двух
переменных, соответствующих людям, и их можно было бы проверять
раньше, чем этажи выбраны для всех действующих лиц. Напишите и
продемонстрируйте значительно более эффективную недетерминистскую
процедуру, которая бы решала задачу, порождая только те варианты, которые
еще не исключены благодаря предыдущим ограничениям. (Подсказка:
потребуется набор вложенных выражений let.)

Если у нас нет условия, что все жильцы проживают на разных этажах, то
число возможных комбинаций резко увеличивается.

Новый вариант будет выглядеть так:
#+BEGIN_SRC scheme
  (define (multiple-dwelling)
    (let ((baker (amb 1 2 3 4 5)))
      (require (not (= baker 5)))
      (let ((cooper (amb 1 2 3 4 5)))
        (require (not (= cooper 1)))
        (let ((fletcher (amb 1 2 3 4 5)))
          (require (not (= fletcher 1)))
          (require (not (= fletcher 5)))
          (let ((miller (amb 1 2 3 4 5)))
            (require (> miller cooper))
            (let ((smith (amb 1 2 3 4 5)))
              (require
               (distinct? (list baker cooper fletcher miller smith)))
              (require (> miller cooper))
              (require (not (= (abs (- smith fletcher)) 1)))
              (require (not (= (abs (- fletcher cooper)) 1)))
              (list (list 'baker baker)
                    (list 'cooper cooper)
                    (list 'fletcher fletcher)
                    (list 'miller miller)
                    (list 'smith smith))))))))
#+END_SRC

Второй вариант.
Есть идея, что если мы знаем ограничения заранее (а мы их знаем из текста
задачи), то некоторые варианты можно и не предлагать. Например, не имеет
смысла предлагать варианты всех этажей для Флетчера и затем проверять их с
первого по пятый, если мы знаем, что Флетчер не живет ни на первом, ни на
пятом.
УБрав некоторые варианты, мы уже можем не кодировать некоторые
ограничения.
#+BEGIN_SRC scheme
  (define (multiple-dwelling)
    ;; Купер не живет на 1 этаже
    (let ((cooper (amb 2 3 4 5))
          ;; а Миллер может быть только выше Купера
          (miller (amb 3 4 5)))
      (require (> miller cooper))
      ;; флетчер не живет ни на 1 ни на 5
      (let ((fletcher (amb 2 3 4))
            ;; Смит живет на любом этаже
            (smith (amb 1 2 3 4 5))
            ;; Бэйкер не живет на последнем
            (baker (amb 1 2 3 4)))
        ;; теперь вставляем оставшиеся ограничения
        (require
         (distinct? (list baker cooper fletcher miller smith)))
        (require (not (= (abs (- smith fletcher)) 1)))
        (require (not (= (abs (- fletcher cooper)) 1)))
          (list (list 'baker baker)
                        (list 'cooper cooper)
                        (list 'fletcher fletcher)
                        (list 'miller miller)
                        (list 'smith smith)))))
#+END_SRC

~Упражнение 4.41.~
Напишите процедуру для решения задачи о проживании на обычной Scheme

Текст загадки:
Бейкер, Купер, Флетчер, Миллер и Смит живут на разных этажах пятиэтаж-
ного дома. Бейкер живет не на верхнем этаже. Купер живет не на первом
этаже. Флетчер не живет ни на верхнем, ни на нижнем этаже. Миллер жи-
вет выше Купера. Смит живет не на соседнем с Флетчером этаже. Флетчер
живет не на соседнем с Купером этаже. Кто где живет?

Тут начинаешь понимать прелести недетерминистского
интерпретатора. Программа проучилась неэффективной.
#+BEGIN_SRC scheme
  (define (distinct? items)
    (cond ((null? items) true)
          ((null? (cdr items)) true)
          ((member (car items) (cdr items)) false)
          (else (distinct? (cdr items)))))

  (define (multiple-dwelling)
    (define (iter baker cooper fletcher miller smith)
      (display baker) (display cooper) (display fletcher)
      (display miller) (display smith) (newline)
      (cond ((<= cooper 1) (iter baker (+ cooper 1) fletcher miller smith))
            ((< smith 1) (iter baker cooper fletcher miller (+ smith 1)))
            ((< baker 1) (iter (+ baker 1) cooper fletcher miller smith))
            ((<= fletcher 1) (iter baker cooper (+ fletcher 1) miller smith))
            ((>= baker 5) (iter (- baker 1) cooper fletcher miller smith))
            ((>= fletcher 5) (iter baker cooper (- fletcher 1) miller smith))
            ((> miller 5) (iter baker cooper fletcher (- miller 1) smith))
            ((<= miller cooper) (iter baker (- cooper 1) fletcher (+ miller 1) smith))
            ((= (abs (- smith fletcher)) 1)
             (iter baker cooper (random  5) miller (random  6)))
            ((= (abs (- fletcher cooper)) 1)
             (iter baker (random  6) (random  5) miller smith))
            ((distinct? (list baker cooper fletcher miller smith))
             (list (list 'baker baker)
                   (list 'cooper cooper)
                   (list 'fletcher fletcher)
                   (list 'miller miller)
                   (list 'smith smith)))
            (else (iter (random  5) (random  6) (random  5) (random  6) (random  6)))))
    (iter (random  5) (random  6) (random  5) (random  6) (random  6)))
#+END_SRC
~Упражнение 4.42.~

Решите задачу «Лгуньи» (из Phillips 1934):
Пять школьниц писали экзаменационную работу. Им показалось, что их
родители чересчур интересовались результатом, и поэтому они решили, что каждая
девочка должна написать домой о результатах экзамена и при этом сделать одно
верное и одно неверное утверждение. Вот соответствующие выдержки из их писем:
Бетти: «Китти была на экзамене второй, а я только третьей».
Этель: «Вам будет приятно узнать, что я написала лучше всех. Второй была
Джоан».
Джоан: «Я была третьей, а бедная Этель последней».
Китти: «Я оказалась второй. Мэри была только четвертой».
Мэри: «Я была четвертой. Первое место заняла Бетти».

В каком порядке на самом деле расположились отметки девочек?

Нам известно:
- каждая девочка написала 2 утверждения
- одно из этих утверждения ложно, другое правдиво
- позиции девочек в рейтинге не повторяются

?:
- результат должен быть независим от порядка утверждений девочек в
  задачке

В качестве данных у нас утверждения.
#+BEGIN_SRC scheme
  (define (xor a b)
    ;; или первое утверждение НЕ правда, а второе тогда правда,
    ;; или второе утверждение НЕ правда, а первое тогда правда
    ;;( мы знаем, что одно из утверждений всегда true, а другое всегда false)
    (or (and (not a) b)
        (and (not b) a)))

  ;; если бетти не третья, то китти вторая (и наоборот)
  (define (betty-statement betty kitty)
    (xor (= betty 3) (= kitty 2)))

  ;; если этель не первая, то джоан - вторая (и наоборот)
  (define (ethel-statement ethel joan)
    (xor (= ethel 1) (= joan 2)))

  ;; если джоан не третья, то этель - пятая (и наоборот)
  (define (joan-statement joan ethel)
    (xor (= joan 3) (= ethel 5)))

  ;; если китти не вторая, то мэри - четвертая (и наоборот)
  (define (kitty-statement kitty mary)
    (xor (= kitty 2) (= mary 4)))

  ;; если мэри не четвертая, то бетти - первая
  (define (mary-statement mary betty)
    (xor (= mary 4) (= betty 1)))

#+END_SRC

Теперь у нас есть 5 утверждений, каждое из которых принимает 2 числовых
значения от 1 до 5.
Если в ~betty-statement~ будет передано 1 и 2 (Бетти первая, а Джоан -
вторая), то ~xor~ вернет #t - нам достаточно, чтоб только один операнд
~or~ дал #t. Таким образом получится, что утверждение "Джоан - вторая"
верно. Принцип сохранится для всех утверждений.

Теперь надо собрать все утверждения, прогнать через них разные значения,
собрать результаты и объединить их в список.

С недетерминистским интерпретатором:
#+BEGIN_SRC scheme
  (define (liers)
    (let ((betty (amb 1 2 3 4 5))
          (ethel (amb 1 2 3 4 5))
          (joan (amb 1 2 3 4 5))
          (kitty (amb 1 2 3 4 5))
          (mary (amb 1 2 3 4 5)))
      (require (distinct? (list betty ethel joan kitty mary)))
      (require (betty-statement betty kitty))
      (require (ethel-statement ethel joan))
      (require (joan-statement joan ethel))
      (require (kitty-statement kitty mary))
      (require (mary-statement mary betty))
      (list (list 'betty betty)
            (list 'ethel ethel)
            (list 'joan joan)
            (list 'kitty kitty)
            (list 'mary mary))))
#+END_SRC

Через обычную scheme:
#+BEGIN_SRC scheme
  (define prev-n #f)

  ;; создадим функцию, которая генерит случайные числа в заданном интервали
  ;; при этом мы следим, чтоб не выпадало подряд дважды одно и то же число
  (define (generate-number-interval min max)
    (let ((n (random (+ max 1))))
      (cond ((eq? prev-n n) (if (< n max)
                                (begin (set! prev-n (+ prev-n 1))
                                       (+ n 1))
                                (begin (set! prev-n (- prev-n 1))
                                       (- n 1))))
            ((< n min) (begin (set! prev-n min) min))
            (else (begin (begin (set! prev-n n) n))))))

  (define (liers)
    (define (iter betty ethel joan kitty mary)
      (if  (and (distinct? (list betty ethel joan kitty mary))
                (and (betty-statement betty kitty)
                     (ethel-statement ethel joan)
                     (joan-statement joan ethel)
                     (kitty-statement kitty mary)
                     (mary-statement mary betty)))
           (list (list 'betty betty)
                 (list 'ethel ethel)
                 (list 'joan joan)
                 (list 'kitty kitty)
                 (list 'mary mary))
           (iter (generate-number-interval 1 5)
                 (generate-number-interval 1 5)
                 (generate-number-interval 1 5)
                 (generate-number-interval 1 5)
                 (generate-number-interval 1 5))))
    (iter 1 2 3 4 5))
#+END_SRC


~Упражнение 4.43.~
Решите с помощью amb-интерпретатора следующую задачу:
У отца Мэри Энн Мур есть яхта, и у каждого из четверых его друзей
тоже. Эти четверо друзей — полковник Даунинг, мистер Холл, сэр Барнакл Худ и доктор
Паркер. У каждого из них тоже есть по дочери, и каждый из них назвал свою
яхту в честь дочери одного из своих друзей. Яхта сэра Барнакла называется
Габриэлла, яхта мистера Мура — Лорна, а у мистера Холла яхта Розалинда. Мелисса, яхта
полковника Даунинга, названа в честь дочери сэра Барнакла. Отец Габриэллы владеет
яхтой, названной в честь дочери доктора Паркера. Кто отец Лорны?

Попытайтесь написать программу так, чтобы она работала эффективно
(см. упражнение 4.40).
Кроме того, определите, сколько будет решений, если не указывается, что
фамилия Мэри Энн — Мур.

Итак, у нас есть 5 друзей: Даунинг, Холл, Худ, Мур и Паркер. У каждого из
них есть яхта, и имя яхты - это имя дочери кого-то из его друзей.
Известно:
- дочь Мура - Мэри, яхта - Лорна.
- яхта Даунинга - Мелисса
- дочь Худа - Мелисса, яхта - Габриэлла,
- яхта Холла - Розалинда
- отец Габриэллы владеет яхтой, которая названа в честь дочери Паркера

Неизвестены:
- отец Габриэллы
- отец Розалинды
- отец Лорны
- яхта и дочь Паркера

?:
- дочь Паркера - Розалинда, яхта - Мэри
- дочь Холла - Габриэлла
- дочь Даунинга - Лорна.

Отец Габриэллы - Холл, поскольку:
- имя его дочери мы не знаем
- Даунинг - не отец Габриэллы, поскольку сказано, что его яхта назыана в
  честь дочери Худа, а не Паркера
- имена дочерей остальных известны, кроме имени дочери Паркера.

Про реазизацию:
- На выходе мы должны получить списки из 3х имен, где первым будет идти
  имя одного из друзей, затем имя его дочери и потом имя его яхты
- исходные данные: каждому женскому имени присваиваем пару отец-хозяин
  яхты

Требования (негласные):
- имя дочери и имя яхты не повторяется у одного и того же друга:
  у отца Габриэллы яхта НЕ называется Габриэлла
- имена дочерей НЕ повторяются
- имена яхт НЕ повторяются

Реализация осуществлена согласно идее из второго варианта решения упр. 4.40
Исходим из идеи, что мы предлагаем ~amb~ только действительно возможные
варианты. Например, если нам известно, что дочь Мура - Мэри, а яхта -
Лорна, то мы сразу это установить и таким образом не писать явным образом
это ограничение + уберем лишние исследования вариантов для
интерпретатора.

#+BEGIN_SRC scheme
  (define (distinct? items)
    (cond ((null? items) true)
          ((null? (cdr items)) true)
          ((member (car items) (cdr items)) false)
          (else (distinct? (cdr items)))))

  (define (map fn args-list)
    (define (iter fn args-list result-list)
      (if (null? args-list)
          result-list
          (iter fn (cdr args-list) (append result-list (list (fn (car args-list)))))))
  (iter fn args-list'()))

  (define (require p)
    (if (not p) (amb)))

  (define daughter first)

  (define boat second)


  (define (daughters-and-boats)
    ;; дочь и яхта Мура известны, варианты ни к чему
    ;; теперь мы помним, что имя Мэри занято для дочери, а Лорна - для яхты
    (let ((moor (list 'mary 'lorna))
          ;; известна яхта Холла
          (hall (list (amb 'lorna 'gabrielle 'melissa)
                      'rosalinda))
          ;; известна яхта Даунинга
          (downing (list (amb 'lorna 'gabrielle 'rosalinda)
                         'melissa)))
      ;; яхта Худа известна, а имя дочери = яхта Даунингаа
      (let ((hood (list (second downing) 'gabrielle))
            ;; дочь и яхта Паркера неизвесты, но:
            ;; для яхт заняты все имена кроме Мэри
            (parcker (list (amb 'lorna 'gabrielle 'rosalinda)
                           'mary)))
        (let ((gabrielle-father (amb hall downing parcker))
              (lorna-father (amb hall downing parcker)))
        ;; -- осуществляем все оставшиеся ограничения--
        ;; имена дочерей у мужчин не повторяются
        (require
         (distinct? (map (lambda (x)
                           (daughter x)) (list downing moor hood parcker hall))))
        ;; имена яхт не повторяются
        (require
         (distinct? (map (lambda (x)
                           (boat x)) (list downing moor hood parcker hall))))
        (require (eq? (daughter gabrielle-father) 'gabrielle))
        (require (eq? (daughter lorna-father) 'lorna))
        (require (distinct? lorna-father))
        (require (distinct? gabrielle-father))
        (require (eq? (daughter parcker)
                      (boat gabrielle-father)))

        (list (list 'moor's 'daughter: (daughter moor) 'boat: (boat moor))
              (list 'hall's 'daughter: (daughter hall) 'boat: (boat hall))
              (list 'downing's 'daughter: (daughter downing) 'boat: (boat downing))
              (list 'hood's 'daughter: (daughter hood) 'boat: (boat hood))
              (list 'parcker's 'daughter: (daughter parcker) 'boat: (boat parcker)))
        ))))

#+END_SRC

Если не говорить, что Мур - отец Мэри, то у Даунинга, Паркера и Холла
появляется одно имя для Дочери, а у Мура - сразу 4 возможных. При этом
количество возможных комбинаций вырастает больше, чем
экспоненциально. Думаю, если раньше это был !3, то теперь это !4.

~Упражнение 4.44.~
В упражнении 2.42 описывалась «задача о восьми ферзях», в которой
требуется расставить на шахматной доске восемь ферзей так, чтобы ни один
не бил другого. Напишите недетерминистскую программу для решения этой задачи.

Один из способов решать эту задачу состоит в том, чтобы идти поперек
доски, устанавливая по ферзю в каждой вертикали. После того, как k − 1
ферзя мы уже разместили, нужно разместить k-го в таком месте, где он не
бьет ни одного из тех, которые уже находятся на доске. Этот подход можно
сформулировать рекурсивно: предположим, что мы уже породили
последовательность из всех возможных способов разместить k − 1 ферзей на
первых k − 1 вертикалях доски. Для каждого из этих способов мы порождаем
расширенный набор позиций, добавляя ферзя на каждую горизонталь k-й
вертикали. Затем эти позиции нужно отфильтровать, оставляя только те, где
ферзь на k-й вертикали не бьется ни одним из остальных. Продолжая этот
процесс, мы породим не просто одно решение, а все решения этой задачи.

Воспользумся наработками из упражнения 2.42
#+BEGIN_SRC scheme
  (define (queens board-size)
    (define (queen-cols k)
      (if (= k 0)
          (list empty-board)
          (map (lambda (rest-of-queens)
                 ;; произвольным образом выбираем номер от 1 до максимума и прсоединяем его
                 ;; к остальным взможным вариантам
                 (let ((new-board (adjoin-position (an-element-of
                                                    (enumerate-interval 1 board-size))
                                                   rest-of-queens)))
                   ;; проверяем, пересекается ли k с каким-либо из вариантов
                   (require (safe? new-board))
                   ;; если нет, возвращаем полученные варианты
                   ;; иначе amb вернется назад и будет пробовать остальные варианты
                   new-board))
               (queen-cols (- k 1)))))
    (queen-cols board-size))

  (define (adjoin-position new-row rest-of-queens)
    (cons new-row rest-of-queens))

  (define empty-board
    (list))

  ;; проверяем, занимает ли какой-то ферзь дигональ или вертикаль других ферзей
  (define (safe? k positions)
    (not (or (= k (car positions)) (= k (cdr positions)))))
#+END_SRC


~Упражнение 4.45.~
Согласно заданной выше грамматике, следующее предложение можно
проанализировать пятью различными способами: The professor lectures to
the student in the class with the cat («Профессор читает лекцию студенту
в аудитории с кошкой»). Покажите эти пять разборов и объясните разницу
в оттенках значения между ними.

Заданная грамматика:
#+BEGIN_SRC scheme
  (define nouns '(noun student professor cat class))
  (define verbs '(verb studies lectures eats sleeps))
  (define articles '(article the a))
  (define prepositions '(prep for to in by with))
  ;;сюда зпишем весь ввод
  (define *unparsed* '())

  ;; запускает парсинг ввода и возвращает результат парсинга
  (define (parse input)
    (set! *unparsed* input)
    (let ((sent (parse-sentence)))
      (require (null? *unparsed*))
      sent))

  ;; принимает список слов и ищет среди этого списка первое слово из нераспарсенных
  (define (parse-word word-list)
    (require (not (null? *unparsed*)))
    (require (memq (car *unparsed*) (cdr word-list)))
    ;; если нашел, то выкидывает это слово из списка нераспарсенных
    (let ((found-word (car *unparsed*)))
      (set! *unparsed* (cdr *unparsed*))
      ;; соединяет слово с тегом (какая это часть речи) и возвращает
      (list (car word-list) found-word)))

  ;; парсим словосочетание предлог + существительное
  (define (parse-prepositional-phrase)
    (display "parse-prepositional-phrase")
    (newline)
    (list 'prep-phrase
           (parse-word prepositions)
           (parse-noun-phrase)))

  ;; парсим предложение подлежащие + сказуемое
  (define (parse-sentence)
    (list 'sentence
           (parse-noun-phrase)
           (parse-verb-phrase)))

  ;; парсим глагол (может оказаться как одним словом, так и с предлогом)
  (define (parse-verb-phrase)
    (define (maybe-extend verb-phrase)
      (display "parse-verb-phrase")
      (newline)
      (display verb-phrase)
      (newline)
      (amb verb-phrase
           (maybe-extend (list 'verb-phrase
                                verb-phrase
                                (parse-prepositional-phrase)))))
    (maybe-extend (parse-word verbs)))

  ;; парсинг существительных с артиклями
  (define (parse-simple-noun-phrase)
    (list 'simple-noun-phrase
           (parse-word articles)
           (parse-word nouns)))

  ;; парсинг существительных в связке с другими существительными и предлогами
  (define (parse-noun-phrase)
    (define (maybe-extend noun-phrase)
      (display "parse-noun-phrase")
      (newline)
      (display noun-phrase)
      (newline)
      (amb noun-phrase
           (maybe-extend (list 'noun-phrase
                               noun-phrase
                               (parse-prepositional-phrase)))))
    (maybe-extend (parse-simple-noun-phrase)))
#+END_SRC

"The professor lectures to the student in the class with the cat"
Все это предложение попадает в  *unparsed*, затем мы вызываем
~parse-sentence~. ~parse-sentence~ представляет из себя вызов ~parse-noun-phrase~
и ~parse-verb-phrase~. ~parse-noun-phrase~ распарсит все существительные
с их предлогами, а ~parse-verb-phrase~ распарсит все глаголы с их
предлогами.

#+BEGIN_SRC scheme
  ;; профессор с кошкой читают лекцию студенту в классе
  (sentence (simple-noun-phrase (article the)
                                (noun professor))
            (verb-phrase
             (verb-phrase
              (verb-phrase
               (verb lectures)
               (prep-phrase (prep to)
                            (simple-noun-phrase (article the) (noun student))))
              (prep-phrase (prep in) (simple-noun-phrase (article the) (noun class))))
             (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))))

  ;; профессор читает лекцию  в классе кошкой студенту
  (sentence (simple-noun-phrase (article the) (noun professor))
            (verb-phrase
             (verb-phrase
              (verb lectures)
              (prep-phrase (prep to)
                           (simple-noun-phrase (article the) (noun student))))
             (prep-phrase (prep in)
                          (noun-phrase
                           (simple-noun-phrase (article the) (noun class))
                           (prep-phrase (prep with)
                                        (simple-noun-phrase (article the) (noun cat)))))))

  ;; профессор с кошккой (типа на руках) читает лекцию студенту в классе
  (sentence (simple-noun-phrase (article the) (noun professor))
            (verb-phrase
             (verb-phrase
              (verb lectures)
              (prep-phrase (prep to)
                           (noun-phrase
                            (simple-noun-phrase (article the) (noun student))
                            (prep-phrase (prep in)
                                         (simple-noun-phrase (article the) (noun class))))))
             (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))))

  ;; профессор читает лекцию студенту  с кошкой (типа кошка на руках у студента) в классе
  (sentence (simple-noun-phrase (article the) (noun professor))
            (verb-phrase
             (verb lectures)
             (prep-phrase (prep to)
                          (noun-phrase
                           (noun-phrase
                            (simple-noun-phrase (article the) (noun student))
                            (prep-phrase (prep in)
                                         (simple-noun-phrase (article the) (noun class))))
                           (prep-phrase (prep with)
                                        (simple-noun-phrase (article the) (noun cat)))))))

  ;; профессор читает лекцию студенту в классе, где есть кошка
  (sentence (simple-noun-phrase (article the) (noun professor))
            (verb-phrase
             (verb lectures)
             (prep-phrase (prep to)
                          (noun-phrase
                           (simple-noun-phrase (article the) (noun student))
                           (prep-phrase (prep in)
                                        (noun-phrase
                                         (simple-noun-phrase (article the)
                                                             (noun class))
                                         (prep-phrase (prep with)
                                                      (simple-noun-phrase (article the)
                                                                          (noun cat)))))))))
#+END_SRC

~Упражнение 4.46.~
Интерпретаторы в разделах 4.1 и 4.2 не определяют, в каком порядке
вычисляются операнды при вызове процедуры. Мы увидим, что
amb-интерпретатор вычисляет их слева направо. Объясните,
почему программа разбора не стала бы работать, если бы операнды
вычислялись в каком-нибудь другом порядке.

Нам в предложении важен порядок слов (особенно в английском
языке), поэтому и парсить слова следует в том порядке, в котором их
ввели.
К тому же, различные функции парсинга ожидают увидеть определенные
части речи в определенном месте разбираемого предложения. Если мы анализируем
аргументы в другом порядке, то нужных частей речи может просто не
оказаться на месте, соответственно, мы не распарсим предложение.

К примеру, если у нас целиком не распарсено 'the cat sleeps', а мы
сначала вызываем вот эту функцию:

#+BEGIN_SRC scheme
  (define (parse-sentence)
    (list 'sentence
           (parse-noun-phrase)
           (parse-verb-phrase)))
#+END_SRC

и сначала сработает парсиинг глагола, то мы ничего не найдем: the -
значится в списке артиклей, попытка найти его в списке глаголов сфейлится
и мы ничего не распарсим.
Кстати говоря, данная программа, даже используя вычисление слева направо,
не распарсит предложение а-ля мастер Йода "чувствую силу в тебе я",
программа ожидает увидеть в начале предложения подлежащее, как в любом
нормальном предложении английского языка.


~Упражнение 4.47.~
Хьюго Дум говорит, что поскольку глагольная группа — это либо глагол,
либо глагольная группа плюс предложная группа, было бы намного
естественнее  определить процедуру parse-verb-phrase так
(и то же сделать для именных групп):
#+BEGIN_SRC scheme
  (define (parse-verb-phrase)
    (amb (parse-word verbs)
         (list 'verb-phrase
                (parse-verb-phrase)
                (parse-prepositional-phrase))))

#+END_SRC

Работает ли этот вариант? Изменится ли поведение программы, если мы
поменяем местами выражения в amb?

Исходный вид parse-verb-phrase:
#+BEGIN_SRC scheme
  (define (parse-verb-phrase)
    (define (maybe-extend verb-phrase)
      ;; аmb получает на вход первый глагол из распарсенных и
      ;; список, который вернет рекурсивный вызов
      (amb verb-phrase
           (maybe-extend (list 'verb-phrase
                                verb-phrase
                                (parse-prepositional-phrase)))))
    ;; пытаемся распарсить первое слово из оставшихся и думаем, что это слово - глагол
    ;; затем полученный глагол как параметр
    (maybe-extend (parse-word verbs)))

  (define (parse-word word-list)
    (require (not (null? *unparsed*)))
    (require (memq (car *unparsed*) (cdr word-list)))
    (let ((found-word (car *unparsed*)))
      (set! *unparsed* (cdr *unparsed*))
      (list (car word-list) found-word)))
#+END_SRC

Я думаю, что вариант Хьюго будет работать не совсем
правильно. parse-word вызванный с verbs (списком глаголов) будет пытаться
найти текущее слово в списке глаголов. Если оно там есть, то мы получим
на выходе ('verb какой-то глагол). Один вызов ~parse-word~ = один найденный
(или нет) глагол. В исходном виде ~parse-verb-phrase~ ~parse-word~ будет
вызвана 1 раз и результат ее вызова - найденный глагол - будет передан в
~maybe-extend~ как параметр, соответственно, если в ходе аналища мы
придем к выводу, что распарсенный глагол - это глагол с предлогом и его
надо парсить дальше, мы будем парсить тот же самый глагол, поскольку он
является нашим параметром ~verb-phrase~.

Теперь смотрим, что делает Хьюго. Он обходится без внутренней функции,
если первый вариант, переданный ~amb~ не сработает - результат
~parse-word~ - то мы вызовем
рекурсивно ~parse-verb-phrase~. Что происходит внутри рекурсивного
вызова? Правильно, еще один вызов amb, первым вариантом выбора которого
становится результат вызова ~parse-word~ . Это уже второй вызов, а
значит, мы проанализировали уже следующий нераспарсенный глагол. Таким
образом первый мы так и не распарсили правильно. Более того, мы не сможем
распарсить ни один глагол с препозицией правильно, пока не достигнем дна
от рекурсивного вызова ~parse-verb-phrase~, то есть нам надо, чтоб у нас
как минимум кочились все нераспарсенные слова. А среди нераспарсенных у
нас и предлоги к первому глаголу, которых, естесвенно, не будет в списке
глаголов, то есть весь парсинг провалится.

Если поменять местами выражения в вызове ~amb~, т.е. по умолчанию
считать, что все глаголы с препозициями, а если нет - без них, ситуация
несколько улучшится, но только при условии, что мы парсим глагол с
препозицией. Если нет, то отработка остальных вариантов повлечет за собой
новые рекурсивные вызовы ~parse-verb-phrase~ и дальше мы легко можем
попасть в сценарий, описанный выше, когда не можем распарсить ничего.

К тому же способ Хьюго не учитывает, что у нас может быть не один глагол
или же могут быть больше одной связги глагола с чем-либо. Мы не будем
рекурсивно проходить по этоя глаголольной связке, пока не наткнемся на
существительное.

~To Do! Упражнение 4.48.~
Дополните описанную выше грамматику так, чтобы она могла работать с более
сложными предложениями. Например, можно позволить именным и глагольным
группам включать прилагательные и наречия, или же можно обрабатывать
сложные предложения.

Дополним грамматику прилагательными и наречиями.

- добавляем список прилагательных
- добавляем функцию парсинга словосочетания прилагательное +
  существительное ~parse-adj-phrase~. ~parse-adj-phrase~ пробует
  распарсить первое слово как прилагательное и если за ним больше ничего
  не следует, то так его и вернет. Такое может получиться, если у нас
  предложение звучит как "Sky is blue". Если же этот вариант не подошел,
  ищем дальше. У нас может быть более одного прилагательного, например.

#+BEGIN_SRC scheme
  ; добавлем список прилагательных
  (define adjectives '(adj big small white))

  (set! *unparsed* (cdr *unparsed*))

  (set! *unparsed* '(big small white cat))

  (set! *unparsed* '(lectures sleeps))
  (set! *unparsed* '())
  ;; добавляем функцию парсинга для прилагательного в связке с существительным
  (define (parse-adj-phrase)
    (define (maybe-extend adj-phrase)
      ;; (display adj-phrase)
      ;; (newline)
      (amb adj-phrase
           (maybe-extend (list 'adj-noun-phrase
                                adj-phrase
                                (parse-simple-adj-noun)
                               ))))
    (maybe-extend (parse-word adjectives)))

  ;; усовершенствуем парсинг простой именной группы так, чтоб в связке с существительным
  ;; могло идти прилагательное
  (define (parse-simple-noun-phrase)
    (list 'simple-noun-phrase
          (parse-word articles)
          (parse-adj-phrase)))

  (define (parse-simple-noun-phrase)
    (list 'simple-noun-phrase
          (parse-word articles)
          (parse-simple-adj-noun)))

  ;; парсинг прилагательное + существительное
  (define (parse-simple-adj-noun)
    (list 'simple-adj-noun-phrase
          (parse-word adjectives)
          (parse-word nouns)))

  (define (parse-sentence)
    (list 'sentence
          (parse-noun-phrase)
          (parse-verb-phrase)))


  (define (parse-adj-phrase)
      (list 'adj-noun-phrase
            (parse-simple-adj-noun))

                               (parse-simple-adj-noun)
                               ))))
    (maybe-extend (parse-word adjectives)))
#+END_SRC

Теперь добавляем наречия. Рассчитываем, что наречие может идти либо сразу
после глагола, либо не идет вообще.

То есть "профессор говорит громко" наша система распознает, а "профессор
сказал студенту громко" - уже нет.

К тому же нам надо соединить это с поиском дальнейших связок
- вводим список наречий
- вводим функцию парсинга наречия ~parse-adverb~
Она может распознавать как единичные наречия, так и наречия с дальнейшими
"продолжениями", т. е. "профессор сказал громко студенту....", т.е. после
нахождения наречия возможен поиск предлогов и обстоятельств.
- изменим ~parse-verb-phrase~, чтоб включить в нее ~parse-adverb~, так мы
  будем искать не только обстоятельства, но и наречия в связке с
  глаголами.

#+BEGIN_SRC scheme
  ; добавлем список наречий
  (define adverbs '(adv slowly loudly))


  ;; добавляем функцию наречия (возможно с дальнейшими связками)
  (define (parse-adverb)
    (define (maybe-adverb-with-prep adverb-phrase)
      (amb adverb-phrase
           (maybe-adverb-with-prep
            (list 'adverb-phrase
                  adverb-phrase
                  (parse-prepositional-phrase)))))
    (maybe-adverb-with-prep (parse-word adverbs)))

    (define (maybe-extend adj-phrase)
      (amb verb-phrase
           (maybe-extend (list 'verb-phrase
                               verb-phrase
                               (parse-word nouns)
                               ))))
    (maybe-extend (parse-word verbs)))

  (define (parse-verb-phrase)
    (define (maybe-extend verb-phrase)
      (amb verb-phrase
           (maybe-extend (list 'verb-phrase
                               verb-phrase
                               (parse-adverb)))))
    (maybe-extend (parse-word verbs)))
#+END_SRC

~Упражнение 4.49.~
Лизу П. Хакер больше интересует не анализ предложений, а их
порождение. Она замечает, что если изменить процедуру ~parse-word~ так,
чтобы она игнорировала «входное предложение», всегда заканчивалась
успехом и порождала подходящее слово, мы сможем использовать те же
программы, которые мы написали для анализа, для порождения
предложений. Реализуйте идею Лизы и покажите первые пять-шесть
порожденных предложений.

Это требует иного подхода, фактически это означает, что мы не анализируем
входное предложение, а предлагаем свои варианты. Подозреваю, что походим
образом работают подсказки при вводе в Т9 или переводчиках, погда
пользователю предлагаются разные слова на выбор после того, как он ввел
текущее слово. ТО есть пока юзер вводит слово "быстро", Т9 уже предлагает
ему варинты "бегать" "прыгать" "ходить".

Соответственно, нам надо сформулировать новые правила
грамматики для такой процедуры.
К примеру:
- предложение всегда начинается с артикля
- после артикля всегда следует существительное
- после существительного всегда следует глагол.

Возьмем этот мини-вариант, который будет наиболее просто реализовать.
Чтоб слова каждый раз выбирались рандомно, а не генерилось постоянно одно
и то же предложение, мы будем обращаться к элементам списков с частями
речи по индексу, а индекс будем псевдорандомно генерить.

Проверено через обычную схему.
~generate-number-interval~ взята из упражнения "Лгуньи".
#+BEGIN_SRC scheme
  (define nouns '(noun student professor girl dog cat class))
  (define verbs '(verb studies lectures eats sleeps))
  (define articles '(article the a an))

  ;; доступ к элементу списка по его индексу
  (define (nth n lst)
    (if (= n 0)
        (car lst)
        (nth (- n 1) (cdr lst))))

  (define prev-n #f)

  ;; создадим функцию, которая генерит случайные числа в заданном интервали
  ;; при этом мы следим, чтоб не выпадало подряд дважды одно и то же число
  (define (generate-number-interval min max)
    (let ((n (random (+ 1 max))))
      (cond ((eq? prev-n n) (if (< n max)
                                (begin (set! prev-n (+ prev-n 1))
                                       (+ n 1))
                                (begin (set! prev-n (- prev-n 1))
                                       (- n 1))))
            ((< n min) (begin (set! prev-n min) min))
            (else (begin (begin (set! prev-n n) n))))))

  (define (parse-word)
    (define (make-phrase phrase)
      (cond ((null? phrase) (make-phrase (list (list 'article
                                                     (nth (generate-number-interval 0 2)
                                                          (cdr articles))))))
            ((eq? (caar (last-pair phrase)) 'article)
             (make-phrase (append phrase (list (list 'noun
                                                     (nth (generate-number-interval 0 5)
                                                                 (cdr nouns)))))))
            ((eq? (caar (last-pair phrase)) 'noun)
             (make-phrase (append phrase
                                  (list (list 'verb
                                              (nth (generate-number-interval 0 4)
                                                   (cdr verbs)))))))
            (else phrase)))
    (make-phrase '()))


  ;; (parse-word)
#+END_SRC

 ~amb-интерпретатор~

Заливаем все из метациклического и анализирующего интерпретаторов + код
ниже +

Некоторые вещи из прошлых интерпретаторов нам не понадобятся или они
переопределяются, но проще залить все, чем выиискивать, что действительно
нужно.

#+BEGIN_SRC scheme
  ;; это выражение для amb-процедуры?
  (define (amb? exp) (tagged-list? exp 'amb))

  ;; список возможных выборов
  (define (amb-choices exp) (cdr exp))

#+END_SRC

#+BEGIN_SRC scheme
  ;; анализирует полученное выражение и применяет получившуюся в результате анализа
  ;; исполнительную процедуру к окружению и двум продолжениям
  (define (ambeval exp env succeed fail)
    ((analyze exp) env succeed fail))

  (define (analyze exp)
    (cond ((self-evaluating? exp)
           (analyze-self-evaluating exp))
          ((quoted? exp) (analyze-quoted exp))
          ((variable? exp) (analyze-variable exp))
          ((assignment? exp) (analyze-assignment exp))
          ((definition? exp) (analyze-definition exp))
          ((let? exp) (analyze (let->combination exp)))
          ((if? exp) (analyze-if exp))
          ((lambda? exp) (analyze-lambda exp))
          ((begin? exp) (analyze-sequence (begin-actions exp)))
          ((cond? exp) (analyze (cond->if exp)))
          ;; добавляем анализ для amb
          ((amb? exp) (analyze-amb exp))
          ((application? exp) (analyze-application exp))
          (else
           (error "Неизвестный тип выражения -- ANALYZE" exp))))

  (define (let? exp)
    (tagged-list? exp 'let))

  (define (let->combination exp)
    (define (get-all-params exp)
      (if (null? exp)
          '()
          (cons (caar exp) (get-all-params (cdr exp)))))
    (define (get-all-exps exp)
      (if (null? exp)
          '()
          (cons (cadar exp) (get-all-exps (cdr exp)))))
    (append (list (make-lambda (get-all-params (cadr exp))
                               (cddr exp)))
            (get-all-exps (cadr exp))))

  (define (distinct? items)
    (cond ((null? items) true)
          ((null? (cdr items)) true)
          ((member (car items) (cdr items)) false)
          (else (distinct? (cdr items)))))

  (define (map fn args-list)
    (define (iter fn args-list result-list)
      (if (null? args-list)
          result-list
          (iter fn (cdr args-list) (append result-list (list (fn (car args-list)))))))
    (iter fn args-list'()))

  (define (require p)
    (if (not p) (amb)))

  (define (analyze-or exp)
    (lambda (env)
      (display "analyze-or")
      (newline)
      (display exp)
      (newline)
      (eval-or exp env)))

  (define (analyze-and exp)
    (lambda (env)
      (eval-and exp env)))

  ;; анализ самовычисляющегося выражения
  ;; передаем успешному продолжению выражение и продолжение неудачи и вычисляем
  ;; продолжения успеха в имеющемся окружении
  (define (analyze-self-evaluating exp)
    (lambda (env succeed fail)
      (succeed exp fail)))

  ;; анализ заковыченного выражения
  ;; аналогично самовычисляющемуся, только мы передаем не само заковыченное выражение, а
  ;; только его "текст"
  (define (analyze-quoted exp)
    (let ((qval (text-of-quotation exp)))
      (lambda (env succeed fail)
        (succeed qval fail))))

  ;; анализ поиска переменной
  ;; передаем в успешное продолжение результат от вызова lookup-variable-value, которая
  ;; должна найти нам переменную. Если не найдет, то получим ошибку и никакие другие варианты
  ;; рассматривать больше не будем - прогер ошибся и использует несуществующую переменную
  (define (analyze-variable exp)
    (lambda (env succeed fail)
      (succeed (lookup-variable-value exp env)
               fail)))

  ;; анализ лямбд
  (define (analyze-lambda exp)
    ;; получаем параметры
    (let ((vars (lambda-parameters exp))
          ;; запускаем анализ тела лямбды
          (bproc (analyze-sequence (lambda-body exp))))
      (lambda (env succeed fail)
        ;; передаем в успешное продолжение созданную процедуру и продолжение неудачи
        (succeed (make-procedure vars bproc env)
                 fail))))

  (define (analyze-if exp)
    ;; анализируем предикат и ветки
    (let ((pproc (analyze (if-predicate exp)))
          (cproc (analyze (if-consequent exp)))
          (aproc (analyze (if-alternative exp))))
      ;; пинимает на вход окружение и 2 продолжения
      (lambda (env succeed fail)
        ;; передаем предикату окружение и новые продолжения
        (pproc env
               ;; новое продолжение успеха
               ;; получает на вход значение предиката и второе продолжение неудачи
               (lambda (pred-value fail2)
                 ;; если предикат true
                 (if (true? pred-value)
                     ;; передаем ветке true изначальное продолжение успеха
                     ;; и новое продолжение неудачи
                     (cproc env succeed fail2)
                     ;; передаем ветке false то же самое
                     (aproc env succeed fail2)))
               ;; продолжение неудачи при вычислении предиката
               fail))))

  ;; анализируем последовательности
  (define (analyze-sequence exps)
    ;; исполняет выражение b, если выражение a исполнилось успешно
    (define (sequentially a b)
      (lambda (env succeed fail)
        (a env
           ;; продолжение успеха при вызове a
           (lambda (a-value fail2)
             (b env succeed fail2))
           ;; продолжение неудачи при вызове a
           fail)))
    ;; цикл анализирования и выражений одного за другим, пока они не кончатся
    (define (loop first-proc rest-procs)
      (if (null? rest-procs)
          first-proc
          (loop (sequentially first-proc (car rest-procs))
                (cdr rest-procs))))
    ;; получаем исполнительные процедуры выражений
    (let ((procs (map analyze exps)))
      (if (null? procs)
          (error "Пустая последовательность -- ANALYZE"))
      (loop (car procs) (cdr procs))))

  ;; анализ определения
  (define (analyze-definition exp)
    ;; получаем имя определения
    (let ((var (definition-variable exp))
          ;; получаем исполнительную процедуру выражения
          (vproc (analyze (definition-value exp))))
      (display var)
      (newline)
      (display vproc)
      (newline)
      (lambda (env succeed fail)
        ;; если выполнение присваевомого значения успешно
        (vproc env
               (lambda (val fail2)
                 ;; определяем переменную
                 (define-variable! var val env)
                 (succeed 'ok fail2))
               ;; иначе вызываем продолжеие неудачи
               fail))))

  ;; анализ присваивания
  ;; основная проблема присваивания в данном интерпретаторе - это возможная необходимость
  ;; откатить назад присваивание, присвоив переменной прежнее значение, если общее
  ;; вычисление зашло в тупик или потерпело иную неудачу и нам необходимо вернуться в
  ;; предыдущую точку выбора
  (define (analyze-assignment exp)
    ;; сначала поступаем как при определении
    (let ((var (assignment-variable exp))
          (vproc (analyze (assignment-value exp))))
      ;; принимает окружение и 2 продолжения
      (lambda (env succeed fail)
        (display "succeed")
        (display succeed)
        (newline)
        (display "fail")
        (display fail)
        (newline)
        ;; если присваевымое выражение исполнилось успешно
        (vproc env
               ;; вызываем продолжение успеха
               (lambda (val fail2)
                 ;; сохраняем прежнее значение переменной
                 (let ((old-value
                        (lookup-variable-value var env)))
                   ;; присваеваем ей новое значение
                   (set-variable-value! var val env)
                   ;; если все успех распространился дальше, возвращаем 'ok
                   (succeed 'ok
                             ;; если где-то потерпели неудачу
                             (lambda ()
                               ;; присваиваем переменной старое значение
                               (set-variable-value! var
                                                    old-value
                                                    env)
                               ;; вызываем продолжение неудачи
                               (fail2)))))
               fail))))
  ;; анализ вызова процедур
  (define (analyze-application exp)
    ;; получаем исполнительную процедуру операнда
    (let ((fproc (analyze (operator exp)))
          ;; получаем исполнительные процедуры операндов
          (aprocs (map analyze (operands exp))))
      (lambda (env succeed fail)
        ;; если операнд вычислился успешно
        (fproc env
               ;; исполняем продолжение успеха
               (lambda (proc fail2)
                 ;; получаем список аргументов для оператора
                 (get-args aprocs
                           env
                           ;; если список успешно получен
                           (lambda (args fail3)
                             ;; применяем оператор к аргументам
                             (execute-application
                              proc args succeed fail3))
                           ;; иначе исполняем продолжение неудачи
                           fail2))
               fail))))

  ;; исполняет исполнительные процедуры аргументов вызываемой процедры и возвращает
  ;; список их значений
  (define (get-args aprocs env succeed fail)
    (if (null? aprocs)
        (succeed '() fail)
        ;; если первая исполнительная процедура выполнилась успешно
        ((car aprocs) env
         ;; продолжение успеха для этой aproc
         (lambda (arg fail2)
           ;; продолжаем исполнять остальные процедуры аргументов
           (get-args (cdr aprocs)
                     env
                     ;; и если все исполнительные процедуры были вычислены
                     ;; продолжение успеха для
                     ;; рекурсивного вызова get-args
                     (lambda (args fail3)
                       ;; соединяем их значения в список
                       (succeed (cons arg args)
                                fail3))
                     fail2))
         fail)))

  ;; исполнение вызова процедуры
  (define (execute-application proc args succeed fail)
    ;; если процедцура примитивная
    (cond ((primitive-procedure? proc)
           ;; то передаем успешному продолжению значение ее вызова и продолжение неудачи
           (succeed (apply-primitive-procedure proc args)
                    fail))
          ;; если процедура непримитив
          ((compound-procedure? proc)
           ;; получаем тело процедуры
           ;; и передаем ему (?)
           ((procedure-body proc)
            ;; новый кадр окружения
            (extend-environment (procedure-parameters proc)
                                args
                                (procedure-environment proc))
            ;; продолжения успеха и неудачи
            succeed
            fail))
          (else
           (error
            "Неизвестный тип процедуры -- EXECUTE-APPLICATION"
            proc))))

  ;; анализируем выражение amb
  (define (analyze-amb exp)
    ;; получаем исполнительные процедуры выборов amb
    (let ((cprocs (map analyze (amb-choices exp))))
      (lambda (env succeed fail)
        (define (try-next choices)
          ;; если выборы кончились - неудача
          (if (null? choices)
              (fail)
              ;; иначе первому выбору передаем окружение, продолжение успеха и неудачи
              ((car choices) env
               succeed
               ;; продолжение неудачи - это перебор остальных вариантов
               (lambda ()
                 (try-next (cdr choices))))))
        (try-next cprocs))))
#+END_SRC


управляющий цикл:
#+BEGIN_SRC scheme
  (define input-prompt ";;; Ввод Amb-Eval:")

  (define output-prompt ";;; Значение Amb-Eval:")

  (define (announce-output string)
    (newline) (display string) (newline))

  (define (user-print object)
    (if (compound-procedure? object)
        (display (list 'compound-procedure
                       (procedure-parameters object)
                       (procedure-body object)
                       '<procedure-env>))
        (display object)))

  (define (setup-environment)
    (let ((initial-env
           (extend-environment (primitive-procedure-names)
                               (primitive-procedure-objects)
                               the-empty-environment)))
      (define-variable! 'true true initial-env)
      (define-variable! 'false false initial-env)
      initial-env))

  (define the-global-environment (setup-environment))

  (define the-empty-environment '())

  (define primitive-procedures
    (list (list 'car car)
          (list 'cdr cdr)
          (list 'cons cons)
          (list 'null? null?)
          (list 'list list)
          (list '= =)
          (list '/ /)
          (list '* *)
          (list 'display display)
          (list '+ +)
          (list '- -)

          ))

  (define (driver-loop)
    (define (internal-loop try-again)
      ;; печатаем приглашение к вводу
      (prompt-for-input input-prompt)
      ;; считываем ввод
      (let ((input (read)))
        ;; если пользователь хочет попробовать вычислить данное выражение еще раз
        ;; (перебрать другие варианты), пробуем вычислить еще раз
        (if (eq? input 'try-again)
            (try-again)
            ;; иначе
            (begin
              ;; считаем, что у юзера новая задача
              (newline)
              (display ";;; Начало новой задачи ")
              ;; передадим введенному выражению глобальное окружение и 2 продолжения
              (ambeval input
                       the-global-environment
                       ;; успех ambeval
                       (lambda (val next-alternative)
                         ;; печатаем уведомление о значении
                         (announce-output output-prompt)
                         ;; печатаем само значение
                         (user-print val)
                         ;; вычисляем следующую альтернативу
                         (internal-loop next-alternative))
                       ;; неудача ambeval
                       (lambda ()
                         (announce-output
                          ";;; Нет больше значений")
                         (user-print input)
                         (driver-loop)))))))
    (internal-loop
     ;; печать ошибки, если пользователь пытается вычислить альтернативы, не
     ;; поставив задачу
     (lambda ()
       (newline)
       (display ";;; Задача не задана")
       (driver-loop))))
#+END_SRC
~Упражнение 4.50.~
Реализуйте новую особую форму ramb, которая подобна amb, однако
перебирает варианты не слева направо, а в случайном порядке.
Покажите, как такая форма может пригодиться в Лизиной задаче из упражнения 4.49

Итак, для случайного выбора выражений мы воспользуемся ранее
определенными процедурами:

#+BEGIN_SRC scheme
  (define prev-n #f)

  ;; создадим функцию, которая генерит случайные числа в заданном интервали
  ;; при этом мы следим, чтоб не выпадало подряд дважды одно и то же число
  (define (generate-number-interval min max)
    (let ((n (random (+ 1 max))))
      (cond ((eq? prev-n n) (if (< n max)
                                (begin (set! prev-n (+ prev-n 1))
                                       (+ n 1))
                                (begin (set! prev-n (- prev-n 1))
                                       (- n 1))))
            ((< n min) (begin (set! prev-n min) min))
            (else (begin (begin (set! prev-n n) n))))))
#+END_SRC

Мы будем случайным образом генерировать индекс выражения в списке и
выбирать его.

Теперьнапишем процедуру ramb.
#+BEGIN_SRC scheme

  ;; принимает индекс и список выражений
  ;; поднимает выражение с заданным индексом в car списка
  ;; возвращает новый список
  (define (bubble-exp indx exps-list)
    (define (iter indx exps-list new-exps-list)
      (if (= indx 0)
          (append (list (car exps-list))
                  (append new-exps-list (cdr exps-list)))
          (iter (- indx 1) (cdr exps-list) (append new-exps-list
                (list (car exps-list))))))
    (if (>= indx (length exps-list))
        #f
        (iter indx exps-list '())))

  (define (ramb? exp)
    (tagged-list? exp 'ramb))

  (define (ramb-choices exp)
    (cdr exp))

  (define (analyze-ramb exp)
    ;; получаем исполнительные процедуры выборов amb
    (let ((cprocs (map analyze (ramb-choices exp))))
      (lambda (env succeed fail)
        (define (try-next choices)
          ;; если выборы кончились - неудача
          (if (null? choices)
              (fail)
              ;; иначе рандомно генерируем индекс и "поднимаем" выражение с таким индексом
              ;; в car списка
              (let* ((choices-length (length choices))
                     (bubbled-choices
                      (if (= choices-length 1)
                          (list (car choices))
                          (bubble-exp (generate-number-interval 0 (- (length choices) 1))
                                      choices))))

                (set! choices bubbled-choices)
                ;; (display choices)
                ;; (display newline)
                ((car choices) env succeed
                 ;; продолжение неудачи - это перебор остальных вариантов
                 (lambda ()
                   (try-next (cdr choices)))))))
          (try-next cprocs))))

  (define (analyze exp)
    (cond ((self-evaluating? exp)
           (analyze-self-evaluating exp))
          ((require? exp) (analyze-require exp))
          ((quoted? exp) (analyze-quoted exp))
          ((variable? exp) (analyze-variable exp))
          ((assignment? exp) (analyze-assignment exp))
          ((permanent-assignment? exp) (analyze-permanent-assignment exp))
          ((definition? exp) (analyze-definition exp))
          ((let? exp) (analyze (let->combination exp)))
          ((if? exp) (analyze-if exp))
          ((if-fail? exp) (analyze-if-fail exp))
          ((lambda? exp) (analyze-lambda exp))
          ((begin? exp) (analyze-sequence (begin-actions exp)))
          ((cond? exp) (analyze (cond->if exp)))
          ((amb? exp) (analyze-amb exp))
          ((ramb? exp) (analyze-ramb exp))
          ((application? exp) (analyze-application exp))
          (else
           (error "Неизвестный тип выражения -- ANALYZE" exp))))

  ;;(list (ramb 1 2 3 4) (ramb 1 2 3 4))
#+END_SRC

#+BEGIN_SRC scheme
  (define (parse-word)
    (define (make-phrase phrase)
      (cond ((null? phrase) (make-phrase (list (list 'article
                                                     (ramb 'the 'a 'an)))))
            ((eq? (caar (last-pair phrase)) 'article)
             (make-phrase (append phrase (list (list 'noun (ramb 'student 'professor
                                                                 'girl 'dog
                                                                 'cat 'class))))))
            ((eq? (caar (last-pair phrase)) 'noun)
             (make-phrase (append phrase
                                  (list (list 'verb (ramb 'studies 'lectures
                                                          'eats 'sleeps))))))
            (else phrase)))
    (make-phrase '()))


  ;; (parse-word)
#+END_SRC


~Упражнение 4.51.~
Реализуйте новую разновидность присваивания permanent-set! —
присваивание, которое не отменяется при неудачах. Например, можно выбрать
два различных элемента в списке и посчитать, сколько для этого
потребовалось попыток,
следующим образом:

#+BEGIN_SRC scheme
  (define count 0)

  (define (an-element-of items)
    (require (not (null? items)))
    (amb (car items) (an-element-of (cdr items))))

  (let ((x (an-element-of '(a b c)))
        (y (an-element-of '(a b c))))
    (permanent-set! count (+ count 1))
    (require (not (eq? x y)))
    (list x y count))

  ;;; Начало новой задачи
  ;;; Значение Amb-Eval:
  (a b 2)
  ;;; Ввод Amb-Eval:
  try-again
  ;;; Значение Amb-Eval:
  (a c 3)
#+END_SRC

Какие значения были бы напечатаны, если бы мы вместо ~permanent-set!~
использовали здесь обычный ~set!~?

Итак, у нас есть ~analyse-assigment~, которая анализирует присваивания.
Она возвращает исполнительную процедуру присваивания, которое можно
откатить назад. Значит, нам просто нужно убрать этот "откат", т.е. не
сохранять прежнее значение переменной и при неудаче не откатывать ее
назад.

заливаем в обычную схему и тестим с выражением выше:
#+BEGIN_SRC scheme
  (define (analyze exp)
    (cond ((self-evaluating? exp)
           (analyze-self-evaluating exp))
          ((quoted? exp) (analyze-quoted exp))
          ((variable? exp) (analyze-variable exp))
          ((assignment? exp) (analyze-assignment exp))
          ((permanent-assignment? exp) (analyze-permanent-assignment exp))
          ((definition? exp) (analyze-definition exp))
          ((let? exp) (analyze (let->combination exp)))
          ((if? exp) (analyze-if exp))
          ((lambda? exp) (analyze-lambda exp))
          ((begin? exp) (analyze-sequence (begin-actions exp)))
          ((cond? exp) (analyze (cond->if exp)))
          ;; добавляем анализ для amb
          ((amb? exp) (analyze-amb exp))
          ((application? exp) (analyze-application exp))
          (else
           (error "Неизвестный тип выражения -- ANALYZE" exp))))

  (define (permanent-assignment? exp)
    (tagged-list? exp 'permanent-set!))

  (define (analyze-permanent-assignment exp)
    ;; сначала поступаем как при определении
    (let ((var (assignment-variable exp))
          (vproc (analyze (assignment-value exp))))
      ;; принимает окружение и 2 продолжения
      (lambda (env succeed fail)
        ;; если присваевымое выражение исполнилось успешно
        (vproc env
               ;; вызываем продолжение успеха
               (lambda (val fail2)
                   ;; присваеваем новое значение
                   (set-variable-value! var val env)
                   ;; если все успех распространился дальше, возвращаем 'ok
                   (succeed 'ok (lambda () (fail2))))
               fail))))

#+END_SRC


Если мы будем испольновать set! в указанном выше выражении, то count = 1,
поскольку если попытка неудачная, она как бы "не считается", при откате
назад мы будем откатывать и значение переменной, следовательно, зачтется
только удачная попытка.

~Упражнение 4.52.~
Реализуйте новую конструкцию if-fail, которая позволяет пользователю
перехватить неудачу при выполнении выражения.
If-fail принимает два выражения. Первое она выполняет как
обычно и, если вычисление успешно, возвращает его результат. Однако если
вычисление неудачно, то возвращается значение второго выражения,
как в следующем примере:

#+BEGIN_SRC scheme
  ;;; Ввод Amb-Eval:
  (if-fail (let ((x (an-element-of '(1 3 5))))
             (require (even? x))
             x)
           'all-odd)

  ;;; Начало новой задачи
  ;;; Значение Amb-Eval:
  all-odd
  ;;; Ввод Amb-Eval:

  (if-fail (let ((x (an-element-of '(1 3 5 8))))
             (require (even? x))
             x)
           'all-odd)
  ;;; Начало новой задачи
  ;;; Значение Amb-Eval:
  8
#+END_SRC

Фактически это аналог обычного ~if~, только этот ~if~ оперирует
выражениями и продолжениями.

Принимает 2 выражения. При этом второе будет являться продолжением
неудачи. А продолжение успеха - это значение первого выражения.
#+BEGIN_SRC scheme
  (define (if-fail? exp)
    (tagged-list? exp 'if-fail))

  (define (if-fail-exp exp)
    (cadr exp))

  (define (if-fail-case-false exp)
    (caddr exp))

  (define (analyze-if-fail exp)
    (let ((vproc-exp (analyze (if-fail-exp exp)))
          (vproc-false (analyze (if-fail-case-false exp))))
      (display vproc-exp)
      (newline)
      (display vproc-false)
      (newline)
      (lambda (env succeed fail)
        (vproc-exp env
                   (lambda (val fail2)
                     (succeed val (lambda ()
                                    (fail2))))
                   (lambda ()
                     (vproc-false env succeed fail))))))

  (define (analyze exp)
    (cond ((self-evaluating? exp)
           (analyze-self-evaluating exp))
          ((quoted? exp) (analyze-quoted exp))
          ((variable? exp) (analyze-variable exp))
          ((assignment? exp) (analyze-assignment exp))
          ((permanent-assignment? exp) (analyze-permanent-assignment exp))
          ((definition? exp) (analyze-definition exp))
          ((let? exp) (analyze (let->combination exp)))
          ((if? exp) (analyze-if exp))
          ((if-fail? exp) (analyze-if-fail exp))
          ((lambda? exp) (analyze-lambda exp))
          ((begin? exp) (analyze-sequence (begin-actions exp)))
          ((cond? exp) (analyze (cond->if exp)))
          ;; добавляем анализ для amb
          ((amb? exp) (analyze-amb exp))
          ((application? exp) (analyze-application exp))
          (else
           (error "Неизвестный тип выражения -- ANALYZE" exp))))

#+END_SRC

~Упражнение 4.53.~
Если у нас есть permanent-set!, описанное в упражнении 4.51, и if-fail из
упражнения 4.52, то каков будет результат вычисления

#+BEGIN_SRC scheme

  (define (smallest-divisor n)
    (find-divisor n 2))

  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor n (+ test-divisor 1)))))

  (define (divides? a b)
    (= (remainder b a) 0))

  (define (prime? n)
    (= n (smallest-divisor n)))

  (define (square x)
    (* x x))

  (define (an-element-of items)
    (require (not (null? items)))
    (amb (car items) (an-element-of (cdr items))))

  (define (prime-sum-pair list1 list2)
    (let ((a (an-element-of list1))
          (b (an-element-of list2)))
      (require (prime? (+ a b)))
      (list a b)))

  (let ((pairs '()))
    (if-fail (let ((p (prime-sum-pair '(1 3 5 8) '(20 35 110))))
               (permanent-set! pairs (cons p pairs))
               (amb))
             pairs))
#+END_SRC

Вывод: ~((8 35) (3 110) (3 20))~

~Упражнение 4.54.~
Если бы мы не догадались, что конструкцию require можно реализовать как
обычную процедуру с помощью amb, так что пользователь сам может
определить ее в своей недетерминистской программе, то нам пришлось бы
задать эту конструкцию в виде особой формы. Допишите следующие процедуры:

#+BEGIN_SRC scheme
  (define (require? exp) (tagged-list? exp 'require))

  (define (require-predicate exp) (cadr exp))

  (define (analyze-require exp)
    (let ((pproc (analyze (require-predicate exp))))
      (lambda (env succeed fail)
        (pproc env
               (lambda (pred-value fail2)
                 (if (not (true? pred-value))
                     (fail2)
                     (succeed 'ok fail2)))
               fail))))

  (define (analyze exp)
    (cond ((self-evaluating? exp)
           (analyze-self-evaluating exp))
          ((require? exp) (analyze-require exp))
          ((quoted? exp) (analyze-quoted exp))
          ((variable? exp) (analyze-variable exp))
          ((assignment? exp) (analyze-assignment exp))
          ((permanent-assignment? exp) (analyze-permanent-assignment exp))
          ((definition? exp) (analyze-definition exp))
          ((let? exp) (analyze (let->combination exp)))
          ((if? exp) (analyze-if exp))
          ((if-fail? exp) (analyze-if-fail exp))
          ((lambda? exp) (analyze-lambda exp))
          ((begin? exp) (analyze-sequence (begin-actions exp)))
          ((cond? exp) (analyze (cond->if exp)))
          ;; добавляем анализ для amb
          ((amb? exp) (analyze-amb exp))
          ((application? exp) (analyze-application exp))
          (else
           (error "Неизвестный тип выражения -- ANALYZE" exp))))


  (require (< (+ 3 4) (+ 1 2)))
  (require (+ (+ 3 4) (+ 1 2)))
#+END_SRC

*** Логическое программирование

~реализация запросной системы~

#+BEGIN_SRC scheme
  (define (insert! key value table)
    (let ((record (assoc key (cdr table))))
      (if record
          (set-cdr! record value)
          (set-cdr! table
                    (cons (cons key value) (cdr table)))))
    'ok)

  (define (make-table)
    (list '*table*))
#+END_SRC


#+BEGIN_SRC scheme
   (define input-prompt ";;; Ввод запроса:")
  (define output-prompt ";;; Результаты запроса:")

  (define (query-driver-loop)
    (prompt-for-input input-prompt)
    (let ((q (query-syntax-process (read))))
      (cond ((assertion-to-be-added? q)
             (add-rule-or-assertion! (add-assertion-body q))
             (newline)
             (display "Утверждение добавлено в базу данных.")
             (query-driver-loop))
            (else
             (newline)
             (display output-prompt)
             (display-stream
              (stream-map
               (lambda (frame)
                 (instantiate q
                              frame
                              (lambda (v f)
                                (contract-question-mark v))))
               (qeval q (singleton-stream '()))))
             (query-driver-loop)))))

  (define (instantiate exp frame unbound-var-handler)
    (define (copy exp)
      (cond ((var? exp)
             (let ((binding (binding-in-frame exp frame)))
               (if binding
                   (copy (binding-value binding))
                   (unbound-var-handler exp frame))))
            ((pair? exp)
             (cons (copy (car exp)) (copy (cdr exp))))
            (else exp)))
    (copy exp))

  (define (qeval query frame-stream)
    (let ((qproc (get (type query) 'qeval)))
      (if qproc
          (qproc (contents query) frame-stream)
          (simple-query query frame-stream))))

  (define (simple-query query-pattern frame-stream)
    (stream-flatmap
     (lambda (frame)
       (stream-append-delayed
        (find-assertions query-pattern frame)
        (delay (apply-rules query-pattern frame))))
     frame-stream))

  (define (conjoin conjuncts frame-stream)
    (if (empty-conjunction? conjuncts)
        frame-stream
        (conjoin (rest-conjuncts conjuncts)
                 (qeval (first-conjunct conjuncts)
                        frame-stream))))

  (define (disjoin disjuncts frame-stream)
    (if (empty-disjunction? disjuncts)
        the-empty-stream
        (interleave-delayed
         (qeval (first-disjunct disjuncts) frame-stream)
         (delay (disjoin (rest-disjuncts disjuncts)
                         frame-stream)))))

  ;; (put 'and 'qeval conjoin)
  ;; (put 'or 'qeval disjoin)

  (define (negate operands frame-stream)
    (stream-flatmap
     (lambda (frame)
       (if (stream-null? (qeval (negated-query operands)
                                (singleton-stream frame)))
           (singleton-stream frame)
           the-empty-stream))
     frame-stream))

  ;;(put 'not 'qeval negate)

  (define (lisp-value call frame-stream)
    (stream-flatmap
     (lambda (frame)
       (if (execute
            (instantiate
             call
             frame
             (lambda (v f)
               (error "Неизвестная переменная -- LISP-VALUE" v))))
           (singleton-stream frame)
           the-empty-stream))
     frame-stream))

  ;;(put 'lisp-value 'qeval lisp-value)

  (define (execute exp)
    (apply (eval (predicate exp) user-initial-environment)
           (args exp)))

  ;; (define (always-true ignore frame-stream) frame-stream)
  ;; (put 'always-true 'qeval always-true)

  (define (find-assertions pattern frame)
    (stream-flatmap (lambda (datum)
                      (check-an-assertion datum pattern frame))
                    (fetch-assertions pattern frame)))

  (define (check-an-assertion assertion query-pat query-frame)
    (let ((match-result
           (pattern-match query-pat assertion query-frame)))
      (if (eq? match-result 'failed)
          the-empty-stream
          (singleton-stream match-result))))

  (define (pattern-match pat dat frame)
    (cond ((eq? frame 'failed) 'failed)
          ((equal? pat dat) frame)
          ((var? pat) (extend-if-consistent pat dat frame))
          ((and (pair? pat) (pair? dat))
           (pattern-match (cdr pat)
                          (cdr dat)
                          (pattern-match (car pat)
                                         (car dat)
                                         frame)))
          (else 'failed)))

  (define (extend-if-consistent var dat frame)
    (let ((binding (binding-in-frame var frame)))
      (if binding
          (pattern-match (binding-value binding) dat frame)
          (extend var dat frame))))

  (define (apply-rules pattern frame)
    (stream-flatmap (lambda (rule)
                      (apply-a-rule rule pattern frame))
                    (fetch-rules pattern frame)))

  (define (apply-a-rule rule query-pattern query-frame)
    (let ((clean-rule (rename-variables-in rule)))
      (let ((unify-result
             (unify-match query-pattern
                          (conclusion clean-rule)
                          query-frame)))
        (if (eq? unify-result 'failed)
            the-empty-stream
            (qeval (rule-body clean-rule)
                   (singleton-stream unify-result))))))

  (define (rename-variables-in rule)
    (let ((rule-application-id (new-rule-application-id)))
      (define (tree-walk exp)
        (cond ((var? exp)
               (make-new-variable exp rule-application-id))
              ((pair? exp)
               (cons (tree-walk (car exp))
                     (tree-walk (cdr exp))))
              (else exp)))
      (tree-walk rule)))

  (define (unify-match p1 p2 frame)
    (cond ((eq? frame 'failed) 'failed)
          ((equal? p1 p2) frame)
          ((var? p1) (extend-if-possible p1 p2 frame))
          ((var? p2) (extend-if-possible p2 p1 frame))
          ((and (pair? p1) (pair? p2))
           (unify-match (cdr p1)
                        (cdr p2)
                        (unify-match (car p1)
                                     (car p2)
                                     frame)))
          (else 'failed)))

  (define (extend-if-possible var val frame)
    (let ((binding (binding-in-frame var frame)))
      (cond (binding
             (unify-match
              (binding-value binding) val frame))
            ((var? val)
                                          ; ***
             (let ((binding (binding-in-frame val frame)))
               (if binding
                   (unify-match
                    var (binding-value binding) frame)
                   (extend var val frame))))
            ((depends-on? val var frame)
                                          ; ***
             'failed)
            (else (extend var val frame)))))

  (define (depends-on? exp var frame)
    (define (tree-walk e)
      (cond ((var? e)
             (if (equal? var e)
                 true
                 (let ((b (binding-in-frame e frame)))
                   (if b
                       (tree-walk (binding-value b))
                       false))))
            ((pair? e)
             (or (tree-walk (car e))
                 (tree-walk (cdr e))))
            (else false)))
    (tree-walk exp))

  (define THE-ASSERTIONS the-empty-stream)

  (define (fetch-assertions pattern frame)
    (if (use-index? pattern)
        (get-indexed-assertions pattern)
        (get-all-assertions)))

  (define (get-all-assertions) THE-ASSERTIONS)

  (define (get-indexed-assertions pattern)
    (get-stream (index-key-of pattern) 'assertion-stream))

  (define (get-stream key1 key2)
    (let ((s (get key1 key2)))
      (if s s the-empty-stream)))

  (define THE-RULES the-empty-stream)

  (define (fetch-rules pattern frame)
    (if (use-index? pattern)
        (get-indexed-rules pattern)
        (get-all-rules)))

  (define (get-all-rules) THE-RULES)

  (define (get-indexed-rules pattern)
    (stream-append
     (get-stream (index-key-of pattern) 'rule-stream)
     (get-stream '? 'rule-stream)))

  (define (add-rule-or-assertion! assertion)
    (if (rule? assertion)
        (add-rule! assertion)
        (add-assertion! assertion)))

  (define (add-assertion! assertion)
    (store-assertion-in-index assertion)
    (let ((old-assertions THE-ASSERTIONS))
      (set! THE-ASSERTIONS
            (cons-stream assertion old-assertions))
      'ok))

  (define (add-rule! rule)
    (store-rule-in-index rule)
    (let ((old-rules THE-RULES))
      (set! THE-RULES (cons-stream rule old-rules))
      'ok))

  (define (store-assertion-in-index assertion)
    (if (indexable? assertion)
        (let ((key (index-key-of assertion)))
          (let ((current-assertion-stream
                 (get-stream key 'assertion-stream)))
            (put key
                 'assertion-stream
                  (cons-stream assertion
                               current-assertion-stream))))))

  (define (store-rule-in-index rule)
    (let ((pattern (conclusion rule)))
      (if (indexable? pattern)
          (let ((key (index-key-of pattern)))
            (let ((current-rule-stream
                   (get-stream key 'rule-stream)))
              (put key
                   'rule-stream
                    (cons-stream rule
                                 current-rule-stream)))))))

  (define (indexable? pat)
    (or (constant-symbol? (car pat))
        (var? (car pat))))

  (define (index-key-of pat)
    (let ((key (car pat)))
      (if (var? key) '? key)))

  (define (use-index? pat)
    (constant-symbol? (car pat)))

  (define (stream-append-delayed s1 delayed-s2)
    (if (stream-null? s1)
        (force delayed-s2)
        (cons-stream
         (stream-car s1)
         (stream-append-delayed (stream-cdr s1) delayed-s2))))

  (define (interleave-delayed s1 delayed-s2)
    (if (stream-null? s1)
        (force delayed-s2)
        (cons-stream
         (stream-car s1)
         (interleave-delayed (force delayed-s2)
                             (delay (stream-cdr s1))))))

  (define (stream-flatmap proc s)
    (flatten-stream (stream-map proc s)))

  (define (flatten-stream stream)
    (if (stream-null? stream)
        the-empty-stream
        (interleave-delayed
         (stream-car stream)
         (delay (flatten-stream (stream-cdr stream))))))

  (define (singleton-stream x)
    (cons-stream x the-empty-stream))

  (define (type exp)
    (if (pair? exp)
        (car exp)
        (error "Неизвестное выражение TYPE" exp)))

  (define (contents exp)
    (if (pair? exp)
        (cdr exp)
        (error "Неизвестное выражение CONTENTS" exp)))

  (define (assertion-to-be-added? exp)
    (eq? (type exp) 'assert!))

  (define (add-assertion-body exp)
    (car (contents exp)))

  (define (empty-conjunction? exps) (null? exps))

  (define (first-conjunct exps) (car exps))

  (define (rest-conjuncts exps) (cdr exps))

  (define (empty-disjunction? exps) (null? exps))

  (define (first-disjunct exps) (car exps))

  (define (rest-disjuncts exps) (cdr exps))

  (define (negated-query exps) (car exps))

  (define (predicate exps) (car exps))

  (define (args exps) (cdr exps))

  (define (rule? statement)
    (tagged-list? statement 'rule))

  (define (conclusion rule) (cadr rule))

  (define (rule-body rule)
    (if (null? (cddr rule))
        '(always-true)
        (caddr rule)))

  (define (query-syntax-process exp)
    (map-over-symbols expand-question-mark exp))

  (define (map-over-symbols proc exp)
    (cond ((pair? exp)
           (cons (map-over-symbols proc (car exp))
                 (map-over-symbols proc (cdr exp))))
          ((symbol? exp) (proc exp))
          (else exp)))

  (define (expand-question-mark symbol)
    (let ((chars (symbol->string symbol)))
      (if (string=? (substring chars 0 1) "?")
          (list '?
                 (string->symbol
                  (substring chars 1 (string-length chars))))
          symbol)))

  (define (var? exp)
    (tagged-list? exp '?))

  (define (constant-symbol? exp) (symbol? exp))

  (define (new-rule-application-id)
    (set! rule-counter (+ 1 rule-counter))
    rule-counter)

  (define (make-new-variable var rule-application-id)
    (cons '? (cons rule-application-id (cdr var))))

  (define (contract-question-mark variable)
    (string->symbol
     (string-append "?"
                    (if (number? (cadr variable))
                        (string-append (symbol->string (caddr variable))
                                       "-"
                                       (number->string (cadr variable)))
                        (symbol->string (cadr variable))))))

  (define (make-binding variable value)
    (cons variable value))

  (define (binding-variable binding)
    (car binding))

  (define (binding-value binding)
    (cdr binding))

  (define (binding-in-frame variable frame)
    (assoc variable frame))

  (define (extend variable value frame)
    (cons (make-binding variable value) frame))
#+END_SRC

Следующие ниже упражнения делались без проверки через систему запросов
(она описана в мане ниже и на данный момент я не знаю, как заполнять БД)

~Упражнение 4.55.~
Постройте простые запросы, которые извлекают из базы данных следующую
информацию:
а. Все сотрудники, начальником которых является Бен Битобор.
б. Имена и должности всех работников бухгалтерии.
в. Имена и адреса всех сотрудников, живущих в Сламервилле.

#+BEGIN_SRC scheme
  ;; а
  (начальник ?x (Бен Битобор))

  ;; б
  (должность ?x (бухгалтерия . ?type))

  ;; в

  (адрес ?x (Сламервилл . ?type))
#+END_SRC

~Упражнение 4.56.~
Сформулируйте составные запросы для получения следующей информации:

а. имена всех сотрудников, у которых начальником Бен Битобор, и их
адреса;
б. все сотрудники, чья зарплата ниже, чем у Бена Битобора, вместе с их
зарплатой и зарплатой
Бена;
в. все сотрудники, у которых начальник не относится к компьютерному
отделу, вместе с именем
и должностью их начальника.

#+BEGIN_SRC scheme
  ;; а
  (and (начальник ?x (Бен Битобор))
       (адрес ?x))

  ;; б
  (and (зарплата Бен Битобор ?x)
       (lisp-value > (зарплата Бен Битобор ?x) (зарплата ?y ?x))
       (зарплата ?y ?x))

  ;; в

  (and (начальник ?x (not (должность ?person (компьютеры . ?type))))
       (начальник ?x) (должность (начальник ?x)))

#+END_SRC

~Упражнение 4.57.~

Определите правило, которое говорит, что служащий 1 может заменить
служащего 2, если либо служащий 1 имеет ту же должность, что и служащий
2, либо человек с должностью служащего 1 может выполнять работу служащего
2, и при этом служащие 1 и 2 — разные люди.
Используя это правило, составьте запросы, которые находят следующую информацию:
а. все служащие, которые могут заменить П.Э. Фекта.
б. все служащие, которые могут заменить кого-то, кто получает больше их
самих, с указанием
двух зарплат.

#+BEGIN_SRC scheme
  ;; сотрудник 1 замещает сотрудника 2, если:
  (rule (может-замещать ?person1 ?person2)
        ;; это не один и тот же сотрудник
        (and (not same ?person1 ?person2)
             ;; у них либо одна должность
             (or (same (должность ?person1)
                       (должность ?person2))
                 ;; либо ложность первого может замещать должность второго
                 ;; (сеньеор может легко заменить мидла)
                 (может-замещать (должность ?person1)
                                 (должность ?person2)))))

  ;; кто может замещать Фекта
  (может-замещать ?person1 П.Э. Фект)

  ;; сотрудник 1 может замещать сотрудника 2
  (and (может-замещать ?person1 ?person2)
       ;; выводим из зп
       (зарплата ?person1)
       (зарплата ?person2)
       ;; при этом зп сотрудника 1 больше зп сотрудника 2
       (lisp-value > (зарплата ?person1)
                     (зарплата ?person2)))
#+END_SRC

~Упражнение 4.58.~
Определите правило, которое говорит, что человек «независим» в своем
отделе, если он работает в этом отделе, но у него нет начальника,
который работает в том же отделе.

В переводе на русский язык нужно создать правило "работник независим,
если он и его начальники работают в разных отделах"

#+BEGIN_SRC scheme
  (rule (независим ?person1 ?office)
        (and (not same ((начальник ?person1) ?office)
                  (?person1 ?office))))
#+END_SRC

~Упражнение 4.59.~

Бен Битобор пропускает слишком много совещаний. Опасаясь потерять из-за
этой глупой привычки работу, он решает, что с ней надо что-то делать.
Он добавляет данные обо всех еженедельных совещаниях в базу данных
«Микрошафт» в виде следующих утверждений:

(совещание бухгалтерия (понедельник 9))
(совещание администрация (понедельник 10))
(совещание компьютеры (среда 15))
(совещание администрация (пятница 13))

Все эти утверждения сообщают о совещаниях отделов. Кроме того, Бен вводит
утверждение о совещании всей компании, которое относится ко всем отделам. Все
сотрудники компании должны ходить на это совещание.

(совещание вся-компания (среда 16))

a. В пятницу утром Бен хочет спросить у базы данных, какие совещания
происходят в этот день. Как ему надо составить запрос?

ответ: (совещание ?office (пятница))

б. Лиза П. Хакер недовольна. Она считает, что намного полезнее было бы,
если бы можно было спрашивать о совещаниях, указывая свое имя.
Она пишет правило, гласящее, что совещания, куда служащему надо ходить,
это совещания всей компании и совещания отдела, где он работает.
Допишите тело Лизиного правила.

#+BEGIN_SRC scheme
  (rule (время-совещания ?person ?day-and-time)
        (and (совещание вся-компания ?day-and-time)
             (совещание (?person ?office) ?day-and-time)))
#+END_SRC

в. Лиза приходит на работу в среду и хочет узнать, на какие совещания ей
нужно идти в этот день. Если имеется правило время-совещания, то какой
запрос ей надо подать?

ответ:
(время-совещания (Лиза. П. Хакер) (среда))

~Упражнение 4.60.~
Подав запрос ~(живет-около ?person (Хакер Лиза П))~
Лиза П. Хакер может найти людей, которые живут с ней рядом, и с которыми
она вместе может ездить на работу. С другой стороны, когда она пытается
найти все пары людей, живущих друг около друга, при помощи запроса

~(живет-около ?person-1 ?person-2)~

она видит, что каждая подходящая пара людей попадается в выводе дважды,
например

~(живет-около (Хакер Лиза П) (Фект Пабло Э))~
~(живет-около (Фект Пабло Э) (Хакер Лиза П))~

Почему так происходит? Можно ли получить список людей, живущих рядом друг
с другом, в котором каждая пара появлялась бы по одному разу? Ответ объясните.

Так происходит, потому что система сама делает некоторые логические
выводы. В данном случае система сделала вывод, что если Лиза живет рядом
с Пабло, то и Пабло живет рядом с Лизой. А система выдает все варианты,
при которых утверждение будет правильным.

Формально, можно было бы дополнить правило, создав уточнение, что выводы
"ЛИза живет рядом с Пабло" и "Пабло живет рядом с Лизой" - это 2 вида
одного и того же утверждения, соответственно, если мы вывели один
вариант, то второй показывать не нужно.

~Упражнение 4.61.~
Следующие правила определяют отношение next-to, которое находит в списке
соседние элементы:

~(rule (?x next-to ?y in (?x ?y . ?u)))~
~(rule (?x next-to ?y in (?v . ?z))~
~(?x next-to ?y in ?z))~

Каков будет ответ на следующие запросы?
~(?x next-to ?y in (1 (2 3) 4))~
~(?x next-to 1 in (2 1 3 1))~

Сначала расшифруем, как сформулировано правило.
Мы последовательно проходимся по выражению и спрашиваем, стоит ли искомый
элемент рядом с другим элементом в данном выражении. И так мы проходим до
конца выражения.

В первом запросе оба элемента не указаны. Соответственно, мы должны найти
все соседние элементы:
- 1 (2 3)
- (2 3) 4

Во втором запросе один из элементов конкретизирован. Соответственно, надо
найти элементы, соседние с 1.
- 2 1
- 3 1

~Упражнение 4.62.~
Определите правила, которые реализуют операцию last-pair из упражнения
2.17, которая возвращает последнюю пару непустого списка.

Проверьте Ваши правила на таких запросах, как
(last-pair (3) ?x), (last-pair (1 2 3) ?x) и (last-pair (2 ?x)
(3)). Правильно ли Ваши правила работают с запросами вида (last-pair ?x (3))?

Итак, нам нужен проход по списку и перед тем, как он кончится, мы должны
вернуть последний элемент.

#+BEGIN_SRC scheme
  ;; заключение: последняя пара от (?x) - это (?x)
  (rule (last-pair (?x) (?x)))

  ;; ?x -  последняя пара (?y . ?v)
  (rule (last-pair (?y . ?v) ?x)
        ;; если ?x - последняя пара (?v)
        (last-pair (?v) ?x))
#+END_SRC

~Упражнение 4.63~.
Следующая база данных (см. книгу Бытия, 4) содержит генеалогию сыновей
Ады вплоть до Адама, через Каина:
(сын Адам Каин)
(сын Каин Енох)
(сын Енох Ирад)
(сын Ирад Мехиаель)
(сын Мехиаель Мафусал)
(сын Мафусал Ламех)
(жена Ламех Ада)
(сын Ада Иавал)
(сын Ада Иувал)

Сформулируйте правила, такие как «Если S сын F , а F сын G, то S внук G»
и «Если W жена M , а S сын W , то S также сын M » (предполагается, что в библейские
времена это в большей степени соответствовало истине, чем теперь).
Эти правила должны позволить системе найти внука Каина; сыновей Ламеха;
внуков Мафусала. (В упражнении 4.69 можно найти правила, с помощью
которых выводятся более сложные родственные связи.)

#+BEGIN_SRC scheme
  ;; S - сын G
  (rule (внук ?s ?g)
        ;; если S - сын F
        (and (сын ?s ?f)
             ;; если F - cын G
             (сын ?f ?g)))
  ;; s - сын m
  (rule (сын ?s ?m)
        ;; если S - сын w
        (and (сын ?s ?w)
             ;; если w - жена m
             (жена ?w ?m)))
#+END_SRC
